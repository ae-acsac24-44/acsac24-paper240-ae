diff --git a/.gitignore b/.gitignore
index 97ba6b79..00fb02b1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -132,3 +132,9 @@ all.config
 
 # Kdevelop4
 *.kdev4
+
+vmlinux.S
+vmlinuxbis.S
+bivmlinus.S
+core
+output.txt
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 4fa30531..7123a750 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -597,6 +597,13 @@ config VERIFIED_KVM
 	help
 	  Build verified KVM.
 
+config KERNEL_INT
+	bool "Build KINT"
+	select VERIFIED_KVM
+	default y 
+	help 	
+		Build KINT 
+
 choice
 	prompt "Page size"
 	default ARM64_4K_PAGES
diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile
index 23444c69..5b4a4df9 100644
--- a/arch/arm64/Makefile
+++ b/arch/arm64/Makefile
@@ -107,6 +107,7 @@ core-$(CONFIG_KVM) += arch/arm64/kvm/
 core-$(CONFIG_XEN) += arch/arm64/xen/
 core-$(CONFIG_CRYPTO) += arch/arm64/crypto/
 core-$(CONFIG_VERIFIED_KVM) += arch/arm64/sekvm/
+core-$(CONFIG_KERNEL_INT) += arch/arm64/kint/
 libs-y		:= arch/arm64/lib/ $(libs-y)
 core-$(CONFIG_EFI_STUB) += $(objtree)/drivers/firmware/efi/libstub/lib.a
 
diff --git a/arch/arm64/configs/sekvm_defconfig b/arch/arm64/configs/sekvm_defconfig
index 6e1c27b7..84433b42 100644
--- a/arch/arm64/configs/sekvm_defconfig
+++ b/arch/arm64/configs/sekvm_defconfig
@@ -4,7 +4,7 @@
 #
 
 #
-# Compiler: gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0
+# Compiler: gcc (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609
 #
 CONFIG_ARM64=y
 CONFIG_64BIT=y
@@ -35,7 +35,7 @@ CONFIG_ARCH_SUPPORTS_UPROBES=y
 CONFIG_ARCH_PROC_KCORE_TEXT=y
 CONFIG_MULTI_IRQ_HANDLER=y
 CONFIG_CC_IS_GCC=y
-CONFIG_GCC_VERSION=70500
+CONFIG_GCC_VERSION=50400
 CONFIG_CLANG_VERSION=0
 CONFIG_IRQ_WORK=y
 CONFIG_BUILDTIME_EXTABLE_SORT=y
@@ -467,6 +467,7 @@ CONFIG_SOCIONEXT_SYNQUACER_PREITS=y
 CONFIG_HISILICON_ERRATUM_161600802=y
 CONFIG_QCOM_FALKOR_ERRATUM_E1041=y
 CONFIG_VERIFIED_KVM=y
+CONFIG_KERNEL_INT=y
 CONFIG_ARM64_4K_PAGES=y
 # CONFIG_ARM64_16K_PAGES is not set
 # CONFIG_ARM64_64K_PAGES is not set
@@ -3102,8 +3103,6 @@ CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
 CONFIG_HAVE_ARCH_KASAN=y
 # CONFIG_KASAN is not set
 CONFIG_ARCH_HAS_KCOV=y
-CONFIG_CC_HAS_SANCOV_TRACE_PC=y
-# CONFIG_KCOV is not set
 # CONFIG_DEBUG_SHIRQ is not set
 
 #
diff --git a/arch/arm64/configs/stage2_defconfig b/arch/arm64/configs/stage2_defconfig
deleted file mode 100644
index 1499f885..00000000
--- a/arch/arm64/configs/stage2_defconfig
+++ /dev/null
@@ -1,4422 +0,0 @@
-#
-# Automatically generated file; DO NOT EDIT.
-# Linux/arm64 4.9.0 Kernel Configuration
-#
-CONFIG_ARM64=y
-CONFIG_64BIT=y
-CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
-CONFIG_MMU=y
-CONFIG_DEBUG_RODATA=y
-CONFIG_ARM64_PAGE_SHIFT=12
-CONFIG_ARM64_CONT_SHIFT=4
-CONFIG_ARCH_MMAP_RND_BITS_MIN=18
-CONFIG_ARCH_MMAP_RND_BITS_MAX=24
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_RWSEM_XCHGADD_ALGORITHM=y
-CONFIG_GENERIC_BUG=y
-CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ZONE_DMA=y
-CONFIG_HAVE_GENERIC_RCU_GUP=y
-CONFIG_ARCH_DMA_ADDR_T_64BIT=y
-CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_SG_DMA_LENGTH=y
-CONFIG_SMP=y
-CONFIG_SWIOTLB=y
-CONFIG_IOMMU_HELPER=y
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_FIX_EARLYCON_MEM=y
-CONFIG_PGTABLE_LEVELS=3
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-CONFIG_IRQ_WORK=y
-CONFIG_BUILDTIME_EXTABLE_SORT=y
-
-#
-# General setup
-#
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_CROSS_COMPILE=""
-# CONFIG_COMPILE_TEST is not set
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_POSIX_MQUEUE_SYSCTL=y
-CONFIG_CROSS_MEMORY_ATTACH=y
-CONFIG_FHANDLE=y
-# CONFIG_USELIB is not set
-CONFIG_AUDIT=y
-CONFIG_HAVE_ARCH_AUDITSYSCALL=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_AUDIT_WATCH=y
-CONFIG_AUDIT_TREE=y
-
-#
-# IRQ subsystem
-#
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
-CONFIG_GENERIC_IRQ_MIGRATION=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_CHIP=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_DOMAIN_HIERARCHY=y
-CONFIG_GENERIC_MSI_IRQ=y
-CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
-CONFIG_HANDLE_DOMAIN_IRQ=y
-# CONFIG_IRQ_DOMAIN_DEBUG is not set
-CONFIG_IRQ_FORCED_THREADING=y
-CONFIG_SPARSE_IRQ=y
-CONFIG_ARCH_CLOCKSOURCE_DATA=y
-CONFIG_GENERIC_TIME_VSYSCALL=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_ARCH_HAS_TICK_BROADCAST=y
-CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
-
-#
-# Timers subsystem
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ_COMMON=y
-# CONFIG_HZ_PERIODIC is not set
-CONFIG_NO_HZ_IDLE=y
-# CONFIG_NO_HZ_FULL is not set
-# CONFIG_NO_HZ is not set
-CONFIG_HIGH_RES_TIMERS=y
-
-#
-# CPU/Task time and stats accounting
-#
-CONFIG_TICK_CPU_ACCOUNTING=y
-# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
-# CONFIG_IRQ_TIME_ACCOUNTING is not set
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_BSD_PROCESS_ACCT_V3=y
-CONFIG_TASKSTATS=y
-CONFIG_TASK_DELAY_ACCT=y
-CONFIG_TASK_XACCT=y
-CONFIG_TASK_IO_ACCOUNTING=y
-
-#
-# RCU Subsystem
-#
-CONFIG_PREEMPT_RCU=y
-# CONFIG_RCU_EXPERT is not set
-CONFIG_SRCU=y
-# CONFIG_TASKS_RCU is not set
-CONFIG_RCU_STALL_COMMON=y
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_RCU_EXPEDITE_BOOT is not set
-CONFIG_BUILD_BIN2C=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
-CONFIG_GENERIC_SCHED_CLOCK=y
-CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
-CONFIG_CGROUPS=y
-CONFIG_PAGE_COUNTER=y
-CONFIG_MEMCG=y
-CONFIG_MEMCG_SWAP=y
-CONFIG_MEMCG_SWAP_ENABLED=y
-# CONFIG_BLK_CGROUP is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_CFS_BANDWIDTH is not set
-# CONFIG_RT_GROUP_SCHED is not set
-# CONFIG_CGROUP_PIDS is not set
-# CONFIG_CGROUP_FREEZER is not set
-CONFIG_CGROUP_HUGETLB=y
-# CONFIG_CPUSETS is not set
-# CONFIG_CGROUP_DEVICE is not set
-# CONFIG_CGROUP_CPUACCT is not set
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-CONFIG_NAMESPACES=y
-# CONFIG_UTS_NS is not set
-# CONFIG_IPC_NS is not set
-# CONFIG_USER_NS is not set
-CONFIG_PID_NS=y
-# CONFIG_NET_NS is not set
-CONFIG_SCHED_AUTOGROUP=y
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_RELAY is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_RD_GZIP=y
-CONFIG_RD_BZIP2=y
-CONFIG_RD_LZMA=y
-CONFIG_RD_XZ=y
-CONFIG_RD_LZO=y
-CONFIG_RD_LZ4=y
-CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_HAVE_UID16=y
-CONFIG_SYSCTL_EXCEPTION_TRACE=y
-CONFIG_BPF=y
-# CONFIG_EXPERT is not set
-CONFIG_UID16=y
-CONFIG_MULTIUSER=y
-# CONFIG_SGETMASK_SYSCALL is not set
-CONFIG_SYSFS_SYSCALL=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_ALL=y
-# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
-CONFIG_KALLSYMS_BASE_RELATIVE=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-# CONFIG_BPF_SYSCALL is not set
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_ADVISE_SYSCALLS=y
-# CONFIG_USERFAULTFD is not set
-CONFIG_PCI_QUIRKS=y
-CONFIG_MEMBARRIER=y
-# CONFIG_EMBEDDED is not set
-CONFIG_HAVE_PERF_EVENTS=y
-
-#
-# Kernel Performance Events And Counters
-#
-# CONFIG_PERF_EVENTS is not set
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLUB_DEBUG=y
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_SLAB is not set
-CONFIG_SLUB=y
-# CONFIG_SLAB_FREELIST_RANDOM is not set
-CONFIG_SLUB_CPU_PARTIAL=y
-# CONFIG_SYSTEM_DATA_VERIFICATION is not set
-CONFIG_PROFILING=y
-# CONFIG_KPROBES is not set
-CONFIG_JUMP_LABEL=y
-# CONFIG_STATIC_KEYS_SELFTEST is not set
-# CONFIG_UPROBES is not set
-# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
-CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_GENERIC_IDLE_POLL_SETUP=y
-CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
-CONFIG_HAVE_PERF_REGS=y
-CONFIG_HAVE_PERF_USER_STACK_DUMP=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_HAVE_RCU_TABLE_FREE=y
-CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
-CONFIG_HAVE_CMPXCHG_LOCAL=y
-CONFIG_HAVE_CMPXCHG_DOUBLE=y
-CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_HAVE_GCC_PLUGINS=y
-# CONFIG_GCC_PLUGINS is not set
-CONFIG_HAVE_CC_STACKPROTECTOR=y
-# CONFIG_CC_STACKPROTECTOR is not set
-CONFIG_CC_STACKPROTECTOR_NONE=y
-# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
-# CONFIG_CC_STACKPROTECTOR_STRONG is not set
-CONFIG_HAVE_CONTEXT_TRACKING=y
-CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
-CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
-CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
-CONFIG_HAVE_ARCH_HUGE_VMAP=y
-CONFIG_MODULES_USE_ELF_RELA=y
-CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
-CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
-CONFIG_ARCH_MMAP_RND_BITS=18
-CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
-# CONFIG_HAVE_ARCH_HASH is not set
-# CONFIG_ISA_BUS_API is not set
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_OLD_SIGSUSPEND3=y
-CONFIG_COMPAT_OLD_SIGACTION=y
-# CONFIG_CPU_NO_EFFICIENT_FFS is not set
-# CONFIG_HAVE_ARCH_VMAP_STACK is not set
-
-#
-# GCOV-based kernel profiling
-#
-# CONFIG_GCOV_KERNEL is not set
-CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_MODULE_SIG is not set
-# CONFIG_MODULE_COMPRESS is not set
-# CONFIG_TRIM_UNUSED_KSYMS is not set
-CONFIG_BLOCK=y
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-# CONFIG_BLK_CMDLINE_PARSER is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_EFI_PARTITION=y
-CONFIG_BLOCK_COMPAT=y
-CONFIG_BLK_MQ_PCI=y
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_DEADLINE is not set
-CONFIG_IOSCHED_CFQ=y
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_PREEMPT_NOTIFIERS=y
-CONFIG_UNINLINE_SPIN_UNLOCK=y
-CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
-CONFIG_MUTEX_SPIN_ON_OWNER=y
-CONFIG_RWSEM_SPIN_ON_OWNER=y
-CONFIG_LOCK_SPIN_ON_OWNER=y
-# CONFIG_FREEZER is not set
-
-#
-# Platform selection
-#
-CONFIG_ARCH_SUNXI=y
-CONFIG_ARCH_ALPINE=y
-# CONFIG_ARCH_BCM2835 is not set
-CONFIG_ARCH_BCM_IPROC=y
-CONFIG_ARCH_BERLIN=y
-# CONFIG_ARCH_BRCMSTB is not set
-CONFIG_ARCH_EXYNOS=y
-CONFIG_ARCH_LAYERSCAPE=y
-CONFIG_ARCH_LG1K=y
-CONFIG_ARCH_HISI=y
-CONFIG_ARCH_MEDIATEK=y
-CONFIG_ARCH_MESON=y
-CONFIG_ARCH_MVEBU=y
-CONFIG_ARCH_QCOM=y
-CONFIG_ARCH_ROCKCHIP=y
-CONFIG_ARCH_SEATTLE=y
-CONFIG_ARCH_SHMOBILE=y
-CONFIG_ARCH_RENESAS=y
-CONFIG_ARCH_R8A7795=y
-# CONFIG_ARCH_R8A7796 is not set
-CONFIG_ARCH_STRATIX10=y
-CONFIG_ARCH_TEGRA=y
-CONFIG_ARCH_SPRD=y
-CONFIG_ARCH_THUNDER=y
-CONFIG_ARCH_UNIPHIER=y
-CONFIG_ARCH_VEXPRESS=y
-CONFIG_ARCH_VULCAN=y
-CONFIG_ARCH_XGENE=y
-# CONFIG_ARCH_ZX is not set
-CONFIG_ARCH_ZYNQMP=y
-
-#
-# Bus support
-#
-CONFIG_PCI=y
-CONFIG_PCI_DOMAINS=y
-CONFIG_PCI_DOMAINS_GENERIC=y
-CONFIG_PCI_SYSCALL=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCIEAER=y
-# CONFIG_PCIE_ECRC is not set
-# CONFIG_PCIEAER_INJECT is not set
-CONFIG_PCIEASPM=y
-# CONFIG_PCIEASPM_DEBUG is not set
-CONFIG_PCIEASPM_DEFAULT=y
-# CONFIG_PCIEASPM_POWERSAVE is not set
-# CONFIG_PCIEASPM_PERFORMANCE is not set
-CONFIG_PCIE_PME=y
-# CONFIG_PCIE_DPC is not set
-# CONFIG_PCIE_PTM is not set
-CONFIG_PCI_BUS_ADDR_T_64BIT=y
-CONFIG_PCI_MSI=y
-CONFIG_PCI_MSI_IRQ_DOMAIN=y
-# CONFIG_PCI_DEBUG is not set
-# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
-# CONFIG_PCI_STUB is not set
-CONFIG_PCI_ATS=y
-CONFIG_PCI_ECAM=y
-CONFIG_PCI_IOV=y
-# CONFIG_PCI_PRI is not set
-# CONFIG_PCI_PASID is not set
-CONFIG_PCI_LABEL=y
-# CONFIG_HOTPLUG_PCI is not set
-
-#
-# PCI host controller drivers
-#
-# CONFIG_PCI_AARDVARK is not set
-# CONFIG_PCIE_XILINX_NWL is not set
-# CONFIG_PCIE_DW_PLAT is not set
-CONFIG_PCIE_DW=y
-CONFIG_PCIE_RCAR=y
-CONFIG_PCI_HOST_COMMON=y
-CONFIG_PCI_HOST_GENERIC=y
-CONFIG_PCI_XGENE=y
-CONFIG_PCI_XGENE_MSI=y
-CONFIG_PCI_LAYERSCAPE=y
-CONFIG_PCIE_IPROC=y
-CONFIG_PCIE_IPROC_PLATFORM=y
-CONFIG_PCIE_IPROC_MSI=y
-CONFIG_PCI_HISI=y
-CONFIG_PCIE_QCOM=y
-# CONFIG_PCI_HOST_THUNDER_PEM is not set
-# CONFIG_PCI_HOST_THUNDER_ECAM is not set
-# CONFIG_PCIE_ARMADA_8K is not set
-# CONFIG_PCIE_ROCKCHIP is not set
-
-#
-# Kernel Features
-#
-
-#
-# ARM errata workarounds via the alternatives framework
-#
-CONFIG_ARM64_ERRATUM_826319=y
-CONFIG_ARM64_ERRATUM_827319=y
-CONFIG_ARM64_ERRATUM_824069=y
-CONFIG_ARM64_ERRATUM_819472=y
-CONFIG_ARM64_ERRATUM_832075=y
-CONFIG_ARM64_ERRATUM_834220=y
-CONFIG_ARM64_ERRATUM_845719=y
-CONFIG_ARM64_ERRATUM_843419=y
-CONFIG_CAVIUM_ERRATUM_22375=y
-CONFIG_CAVIUM_ERRATUM_23154=y
-CONFIG_CAVIUM_ERRATUM_27456=y
-CONFIG_ARM64_4K_PAGES=y
-# CONFIG_ARM64_16K_PAGES is not set
-# CONFIG_ARM64_64K_PAGES is not set
-CONFIG_ARM64_VA_BITS_39=y
-# CONFIG_ARM64_VA_BITS_48 is not set
-CONFIG_ARM64_VA_BITS=39
-# CONFIG_CPU_BIG_ENDIAN is not set
-CONFIG_SCHED_MC=y
-# CONFIG_SCHED_SMT is not set
-CONFIG_NR_CPUS=64
-CONFIG_HOTPLUG_CPU=y
-# CONFIG_NUMA is not set
-# CONFIG_PREEMPT_NONE is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREEMPT=y
-CONFIG_PREEMPT_COUNT=y
-# CONFIG_HZ_100 is not set
-CONFIG_HZ_250=y
-# CONFIG_HZ_300 is not set
-# CONFIG_HZ_1000 is not set
-CONFIG_HZ=250
-CONFIG_SCHED_HRTICK=y
-CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
-CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
-CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
-CONFIG_HAVE_ARCH_PFN_VALID=y
-CONFIG_SYS_SUPPORTS_HUGETLBFS=y
-CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
-CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_SPARSEMEM=y
-CONFIG_HAVE_MEMORY_PRESENT=y
-CONFIG_SPARSEMEM_EXTREME=y
-CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
-CONFIG_SPARSEMEM_VMEMMAP=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_NO_BOOTMEM=y
-CONFIG_MEMORY_ISOLATION=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-CONFIG_MEMORY_BALLOON=y
-CONFIG_BALLOON_COMPACTION=y
-CONFIG_COMPACTION=y
-CONFIG_MIGRATION=y
-CONFIG_PHYS_ADDR_T_64BIT=y
-CONFIG_BOUNCE=y
-CONFIG_MMU_NOTIFIER=y
-CONFIG_KSM=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_TRANSPARENT_HUGEPAGE=y
-CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y
-# CONFIG_TRANSPARENT_HUGEPAGE_MADVISE is not set
-CONFIG_TRANSPARENT_HUGE_PAGECACHE=y
-# CONFIG_CLEANCACHE is not set
-# CONFIG_FRONTSWAP is not set
-CONFIG_CMA=y
-# CONFIG_CMA_DEBUG is not set
-# CONFIG_CMA_DEBUGFS is not set
-CONFIG_CMA_AREAS=7
-# CONFIG_ZPOOL is not set
-# CONFIG_ZBUD is not set
-# CONFIG_ZSMALLOC is not set
-CONFIG_GENERIC_EARLY_IOREMAP=y
-# CONFIG_IDLE_PAGE_TRACKING is not set
-# CONFIG_SECCOMP is not set
-CONFIG_PARAVIRT=y
-# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
-CONFIG_XEN_DOM0=y
-CONFIG_XEN=y
-CONFIG_FORCE_MAX_ZONEORDER=11
-# CONFIG_ARMV8_DEPRECATED is not set
-
-#
-# ARMv8.1 architectural features
-#
-CONFIG_ARM64_HW_AFDBM=y
-CONFIG_ARM64_PAN=y
-# CONFIG_ARM64_LSE_ATOMICS is not set
-CONFIG_ARM64_VHE=y
-
-#
-# ARMv8.2 architectural features
-#
-CONFIG_ARM64_UAO=y
-CONFIG_ARM64_MODULE_CMODEL_LARGE=y
-# CONFIG_RANDOMIZE_BASE is not set
-
-#
-# Boot options
-#
-# CONFIG_ARM64_ACPI_PARKING_PROTOCOL is not set
-CONFIG_CMDLINE=""
-# CONFIG_CMDLINE_FORCE is not set
-CONFIG_EFI_STUB=y
-CONFIG_EFI=y
-CONFIG_DMI=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_COMPAT_BINFMT_ELF=y
-CONFIG_ELFCORE=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_BINFMT_SCRIPT=y
-# CONFIG_HAVE_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_COREDUMP=y
-CONFIG_COMPAT=y
-CONFIG_SYSVIPC_COMPAT=y
-
-#
-# Power management options
-#
-# CONFIG_SUSPEND is not set
-# CONFIG_HIBERNATION is not set
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_CLK=y
-CONFIG_PM_GENERIC_DOMAINS=y
-# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
-CONFIG_PM_GENERIC_DOMAINS_OF=y
-CONFIG_CPU_PM=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# CPU Power Management
-#
-
-#
-# CPU Idle
-#
-CONFIG_CPU_IDLE=y
-# CONFIG_CPU_IDLE_GOV_LADDER is not set
-CONFIG_CPU_IDLE_GOV_MENU=y
-
-#
-# ARM CPU Idle Drivers
-#
-# CONFIG_ARM_CPUIDLE is not set
-# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
-
-#
-# CPU Frequency scaling
-#
-# CONFIG_CPU_FREQ is not set
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-CONFIG_UNIX=y
-# CONFIG_UNIX_DIAG is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE_DEMUX is not set
-# CONFIG_NET_IP_TUNNEL is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_NET_IPVTI is not set
-# CONFIG_NET_UDP_TUNNEL is not set
-# CONFIG_NET_FOU is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_INET_DIAG_DESTROY is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETLABEL is not set
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NET_PTP_CLASSIFY=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_RDS is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_L2TP is not set
-# CONFIG_BRIDGE is not set
-CONFIG_HAVE_NET_DSA=y
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_PHONET is not set
-# CONFIG_IEEE802154 is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-CONFIG_DNS_RESOLVER=y
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_NETLINK_DIAG is not set
-# CONFIG_MPLS is not set
-# CONFIG_HSR is not set
-# CONFIG_NET_SWITCHDEV is not set
-# CONFIG_NET_L3_MASTER_DEV is not set
-# CONFIG_QRTR is not set
-# CONFIG_NET_NCSI is not set
-CONFIG_RPS=y
-CONFIG_RFS_ACCEL=y
-CONFIG_XPS=y
-# CONFIG_SOCK_CGROUP_DATA is not set
-# CONFIG_CGROUP_NET_PRIO is not set
-# CONFIG_CGROUP_NET_CLASSID is not set
-CONFIG_NET_RX_BUSY_POLL=y
-CONFIG_BQL=y
-CONFIG_BPF_JIT=y
-CONFIG_NET_FLOW_LIMIT=y
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_AF_KCM is not set
-# CONFIG_STREAM_PARSER is not set
-CONFIG_WIRELESS=y
-CONFIG_CFG80211=m
-# CONFIG_NL80211_TESTMODE is not set
-# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
-CONFIG_CFG80211_DEFAULT_PS=y
-# CONFIG_CFG80211_DEBUGFS is not set
-# CONFIG_CFG80211_INTERNAL_REGDB is not set
-CONFIG_CFG80211_CRDA_SUPPORT=y
-# CONFIG_CFG80211_WEXT is not set
-# CONFIG_LIB80211 is not set
-CONFIG_MAC80211=m
-CONFIG_MAC80211_HAS_RC=y
-CONFIG_MAC80211_RC_MINSTREL=y
-CONFIG_MAC80211_RC_MINSTREL_HT=y
-# CONFIG_MAC80211_RC_MINSTREL_VHT is not set
-CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
-CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
-# CONFIG_MAC80211_MESH is not set
-CONFIG_MAC80211_LEDS=y
-# CONFIG_MAC80211_DEBUGFS is not set
-# CONFIG_MAC80211_MESSAGE_TRACING is not set
-# CONFIG_MAC80211_DEBUG_MENU is not set
-CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=m
-CONFIG_RFKILL_LEDS=y
-CONFIG_RFKILL_INPUT=y
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_RFKILL_GPIO is not set
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
-# CONFIG_NET_9P_DEBUG is not set
-# CONFIG_CAIF is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_NFC is not set
-# CONFIG_LWTUNNEL is not set
-# CONFIG_DST_CACHE is not set
-# CONFIG_NET_DEVLINK is not set
-CONFIG_MAY_USE_DEVLINK=y
-CONFIG_HAVE_EBPF_JIT=y
-
-#
-# Device Drivers
-#
-CONFIG_ARM_AMBA=y
-CONFIG_TEGRA_AHB=y
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER=y
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-CONFIG_FIRMWARE_IN_KERNEL=y
-CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
-CONFIG_ALLOW_DEV_COREDUMP=y
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
-CONFIG_SYS_HYPERVISOR=y
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_GENERIC_CPU_AUTOPROBE=y
-CONFIG_REGMAP=y
-CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_SPI=y
-CONFIG_REGMAP_SPMI=y
-CONFIG_REGMAP_MMIO=y
-CONFIG_REGMAP_IRQ=y
-# CONFIG_DMA_SHARED_BUFFER is not set
-CONFIG_DMA_CMA=y
-
-#
-# Default contiguous memory area size:
-#
-CONFIG_CMA_SIZE_MBYTES=16
-CONFIG_CMA_SIZE_SEL_MBYTES=y
-# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
-# CONFIG_CMA_SIZE_SEL_MIN is not set
-# CONFIG_CMA_SIZE_SEL_MAX is not set
-CONFIG_CMA_ALIGNMENT=8
-
-#
-# Bus devices
-#
-# CONFIG_QCOM_EBI2 is not set
-# CONFIG_SIMPLE_PM_BUS is not set
-# CONFIG_SUNXI_RSB is not set
-# CONFIG_TEGRA_ACONNECT is not set
-CONFIG_UNIPHIER_SYSTEM_BUS=y
-CONFIG_VEXPRESS_CONFIG=y
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
-# CONFIG_MTD_AFS_PARTS is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-# CONFIG_MTD_BLOCK is not set
-# CONFIG_MTD_BLOCK_RO is not set
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_SWAP is not set
-# CONFIG_MTD_PARTITIONED_MASTER is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_INTEL_VR_NOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_PMC551 is not set
-# CONFIG_MTD_DATAFLASH is not set
-CONFIG_MTD_M25P80=y
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOCG3 is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR & LPDDR2 PCM memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-CONFIG_MTD_SPI_NOR=y
-# CONFIG_MTD_MT81xx_NOR is not set
-CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
-# CONFIG_SPI_FSL_QUADSPI is not set
-# CONFIG_SPI_HISI_SFC is not set
-# CONFIG_MTD_UBI is not set
-CONFIG_DTC=y
-CONFIG_OF=y
-# CONFIG_OF_UNITTEST is not set
-CONFIG_OF_FLATTREE=y
-CONFIG_OF_EARLY_FLATTREE=y
-CONFIG_OF_ADDRESS=y
-CONFIG_OF_ADDRESS_PCI=y
-CONFIG_OF_IRQ=y
-CONFIG_OF_NET=y
-CONFIG_OF_MDIO=y
-CONFIG_OF_PCI=y
-CONFIG_OF_PCI_IRQ=y
-CONFIG_OF_RESERVED_MEM=y
-# CONFIG_OF_OVERLAY is not set
-# CONFIG_PARPORT is not set
-CONFIG_PNP=y
-CONFIG_PNP_DEBUG_MESSAGES=y
-
-#
-# Protocols
-#
-CONFIG_PNPACPI=y
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_NULL_BLK is not set
-# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_SKD is not set
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-CONFIG_XEN_BLKDEV_FRONTEND=y
-# CONFIG_XEN_BLKDEV_BACKEND is not set
-CONFIG_VIRTIO_BLK=y
-# CONFIG_BLK_DEV_RBD is not set
-# CONFIG_BLK_DEV_RSXX is not set
-# CONFIG_BLK_DEV_NVME is not set
-# CONFIG_NVME_TARGET is not set
-
-#
-# Misc devices
-#
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_PHANTOM is not set
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_TIFM_CORE is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_HP_ILO is not set
-# CONFIG_QCOM_COINCELL is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_DS1682 is not set
-# CONFIG_TI_DAC7512 is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-# CONFIG_SRAM is not set
-CONFIG_VEXPRESS_SYSCFG=y
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-# CONFIG_CB710_CORE is not set
-
-#
-# Texas Instruments shared transport line discipline
-#
-# CONFIG_TI_ST is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-
-#
-# Altera FPGA firmware download module
-#
-# CONFIG_ALTERA_STAPL is not set
-
-#
-# Intel MIC Bus Driver
-#
-
-#
-# SCIF Bus Driver
-#
-
-#
-# VOP Bus Driver
-#
-
-#
-# Intel MIC Host Driver
-#
-
-#
-# Intel MIC Card Driver
-#
-
-#
-# SCIF Driver
-#
-
-#
-# Intel MIC Coprocessor State Management (COSM) Drivers
-#
-
-#
-# VOP Driver
-#
-# CONFIG_GENWQE is not set
-# CONFIG_ECHO is not set
-# CONFIG_CXL_BASE is not set
-# CONFIG_CXL_AFU_DRIVER_OPS is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI_MOD=y
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_SCSI_MQ_DEFAULT is not set
-# CONFIG_SCSI_PROC_FS is not set
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-
-#
-# SCSI Transports
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_LOWLEVEL is not set
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_DH is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-CONFIG_HAVE_PATA_PLATFORM=y
-CONFIG_ATA=y
-# CONFIG_ATA_NONSTANDARD is not set
-CONFIG_ATA_VERBOSE_ERROR=y
-CONFIG_ATA_ACPI=y
-# CONFIG_SATA_ZPODD is not set
-CONFIG_SATA_PMP=y
-
-#
-# Controllers with non-SFF native interface
-#
-CONFIG_SATA_AHCI=y
-CONFIG_SATA_AHCI_PLATFORM=y
-CONFIG_AHCI_CEVA=y
-CONFIG_AHCI_MVEBU=y
-# CONFIG_AHCI_SUNXI is not set
-# CONFIG_AHCI_TEGRA is not set
-CONFIG_AHCI_XGENE=y
-CONFIG_AHCI_QORIQ=y
-# CONFIG_SATA_AHCI_SEATTLE is not set
-# CONFIG_SATA_INIC162X is not set
-# CONFIG_SATA_ACARD_AHCI is not set
-CONFIG_SATA_SIL24=y
-CONFIG_ATA_SFF=y
-
-#
-# SFF controllers with custom DMA interface
-#
-# CONFIG_PDC_ADMA is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_SX4 is not set
-CONFIG_ATA_BMDMA=y
-
-#
-# SATA SFF controllers with BMDMA
-#
-# CONFIG_ATA_PIIX is not set
-# CONFIG_SATA_DWC is not set
-# CONFIG_SATA_MV is not set
-# CONFIG_SATA_NV is not set
-# CONFIG_SATA_PROMISE is not set
-CONFIG_SATA_RCAR=y
-# CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_SVW is not set
-# CONFIG_SATA_ULI is not set
-# CONFIG_SATA_VIA is not set
-# CONFIG_SATA_VITESSE is not set
-
-#
-# PATA SFF controllers with BMDMA
-#
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_ATP867X is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NINJA32 is not set
-# CONFIG_PATA_NS87415 is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RDC is not set
-# CONFIG_PATA_SCH is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_TOSHIBA is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
-
-#
-# PIO-only SFF controllers
-#
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_OPTI is not set
-CONFIG_PATA_PLATFORM=y
-CONFIG_PATA_OF_PLATFORM=y
-# CONFIG_PATA_RZ1000 is not set
-
-#
-# Generic fallback / legacy drivers
-#
-# CONFIG_PATA_ACPI is not set
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_PATA_LEGACY is not set
-# CONFIG_MD is not set
-# CONFIG_TARGET_CORE is not set
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_FIREWIRE is not set
-# CONFIG_FIREWIRE_NOSY is not set
-CONFIG_NETDEVICES=y
-CONFIG_MII=y
-CONFIG_NET_CORE=y
-# CONFIG_BONDING is not set
-# CONFIG_DUMMY is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_NET_FC is not set
-# CONFIG_NET_TEAM is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_VXLAN is not set
-# CONFIG_MACSEC is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-CONFIG_TUN=y
-# CONFIG_TUN_VNET_CROSS_LE is not set
-# CONFIG_VETH is not set
-CONFIG_VIRTIO_NET=y
-# CONFIG_NLMON is not set
-# CONFIG_ARCNET is not set
-
-#
-# CAIF transport drivers
-#
-
-#
-# Distributed Switch Architecture drivers
-#
-CONFIG_ETHERNET=y
-CONFIG_NET_VENDOR_3COM=y
-# CONFIG_VORTEX is not set
-# CONFIG_TYPHOON is not set
-CONFIG_NET_VENDOR_ADAPTEC=y
-# CONFIG_ADAPTEC_STARFIRE is not set
-CONFIG_NET_VENDOR_AGERE=y
-# CONFIG_ET131X is not set
-CONFIG_NET_VENDOR_ALLWINNER=y
-# CONFIG_SUN4I_EMAC is not set
-CONFIG_NET_VENDOR_ALTEON=y
-# CONFIG_ACENIC is not set
-# CONFIG_ALTERA_TSE is not set
-CONFIG_NET_VENDOR_AMAZON=y
-CONFIG_NET_VENDOR_AMD=y
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_PCNET32 is not set
-CONFIG_AMD_XGBE=y
-CONFIG_NET_XGENE=y
-CONFIG_NET_VENDOR_ARC=y
-# CONFIG_ARC_EMAC is not set
-# CONFIG_EMAC_ROCKCHIP is not set
-CONFIG_NET_VENDOR_ATHEROS=y
-# CONFIG_ATL2 is not set
-# CONFIG_ATL1 is not set
-# CONFIG_ATL1E is not set
-# CONFIG_ATL1C is not set
-# CONFIG_ALX is not set
-# CONFIG_NET_VENDOR_AURORA is not set
-CONFIG_NET_CADENCE=y
-# CONFIG_MACB is not set
-CONFIG_NET_VENDOR_BROADCOM=y
-# CONFIG_B44 is not set
-# CONFIG_BCMGENET is not set
-# CONFIG_BNX2 is not set
-# CONFIG_CNIC is not set
-# CONFIG_TIGON3 is not set
-# CONFIG_BNX2X is not set
-CONFIG_BGMAC=y
-CONFIG_BGMAC_PLATFORM=y
-# CONFIG_SYSTEMPORT is not set
-# CONFIG_BNXT is not set
-CONFIG_NET_VENDOR_BROCADE=y
-# CONFIG_BNA is not set
-CONFIG_NET_VENDOR_CAVIUM=y
-# CONFIG_THUNDER_NIC_PF is not set
-# CONFIG_THUNDER_NIC_VF is not set
-# CONFIG_THUNDER_NIC_BGX is not set
-# CONFIG_THUNDER_NIC_RGX is not set
-# CONFIG_LIQUIDIO is not set
-CONFIG_NET_VENDOR_CHELSIO=y
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_CHELSIO_T3 is not set
-# CONFIG_CHELSIO_T4 is not set
-# CONFIG_CHELSIO_T4VF is not set
-CONFIG_NET_VENDOR_CISCO=y
-# CONFIG_ENIC is not set
-# CONFIG_DNET is not set
-CONFIG_NET_VENDOR_DEC=y
-# CONFIG_NET_TULIP is not set
-CONFIG_NET_VENDOR_DLINK=y
-# CONFIG_DL2K is not set
-# CONFIG_SUNDANCE is not set
-CONFIG_NET_VENDOR_EMULEX=y
-# CONFIG_BE2NET is not set
-CONFIG_NET_VENDOR_EZCHIP=y
-# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
-CONFIG_NET_VENDOR_EXAR=y
-# CONFIG_S2IO is not set
-# CONFIG_VXGE is not set
-CONFIG_NET_VENDOR_FREESCALE=y
-# CONFIG_FSL_PQ_MDIO is not set
-# CONFIG_FSL_XGMAC_MDIO is not set
-# CONFIG_GIANFAR is not set
-CONFIG_NET_VENDOR_HISILICON=y
-# CONFIG_HIX5HD2_GMAC is not set
-# CONFIG_HISI_FEMAC is not set
-# CONFIG_HIP04_ETH is not set
-# CONFIG_HNS is not set
-# CONFIG_HNS_DSAF is not set
-# CONFIG_HNS_ENET is not set
-CONFIG_NET_VENDOR_HP=y
-# CONFIG_HP100 is not set
-CONFIG_NET_VENDOR_INTEL=y
-# CONFIG_E100 is not set
-# CONFIG_E1000 is not set
-CONFIG_E1000E=y
-CONFIG_IGB=y
-CONFIG_IGB_HWMON=y
-CONFIG_IGBVF=y
-# CONFIG_IXGB is not set
-# CONFIG_IXGBE is not set
-# CONFIG_IXGBEVF is not set
-# CONFIG_I40E is not set
-# CONFIG_I40EVF is not set
-# CONFIG_FM10K is not set
-CONFIG_NET_VENDOR_I825XX=y
-# CONFIG_JME is not set
-CONFIG_NET_VENDOR_MARVELL=y
-# CONFIG_MVMDIO is not set
-# CONFIG_MVNETA_BM is not set
-# CONFIG_PXA168_ETH is not set
-# CONFIG_SKGE is not set
-CONFIG_SKY2=y
-# CONFIG_SKY2_DEBUG is not set
-# CONFIG_NET_VENDOR_MEDIATEK is not set
-CONFIG_NET_VENDOR_MELLANOX=y
-# CONFIG_MLX4_EN is not set
-# CONFIG_MLX4_CORE is not set
-# CONFIG_MLX5_CORE is not set
-# CONFIG_MLXSW_CORE is not set
-CONFIG_NET_VENDOR_MICREL=y
-# CONFIG_KS8842 is not set
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-# CONFIG_KSZ884X_PCI is not set
-CONFIG_NET_VENDOR_MICROCHIP=y
-# CONFIG_ENC28J60 is not set
-# CONFIG_ENCX24J600 is not set
-CONFIG_NET_VENDOR_MYRI=y
-# CONFIG_MYRI10GE is not set
-# CONFIG_FEALNX is not set
-CONFIG_NET_VENDOR_NATSEMI=y
-# CONFIG_NATSEMI is not set
-# CONFIG_NS83820 is not set
-CONFIG_NET_VENDOR_NETRONOME=y
-# CONFIG_NFP_NETVF is not set
-CONFIG_NET_VENDOR_8390=y
-# CONFIG_NE2K_PCI is not set
-CONFIG_NET_VENDOR_NVIDIA=y
-# CONFIG_FORCEDETH is not set
-CONFIG_NET_VENDOR_OKI=y
-# CONFIG_ETHOC is not set
-CONFIG_NET_PACKET_ENGINE=y
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-CONFIG_NET_VENDOR_QLOGIC=y
-# CONFIG_QLA3XXX is not set
-# CONFIG_QLCNIC is not set
-# CONFIG_QLGE is not set
-# CONFIG_NETXEN_NIC is not set
-# CONFIG_QED is not set
-CONFIG_NET_VENDOR_QUALCOMM=y
-# CONFIG_QCA7000 is not set
-# CONFIG_QCOM_EMAC is not set
-CONFIG_NET_VENDOR_REALTEK=y
-# CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
-# CONFIG_R8169 is not set
-CONFIG_NET_VENDOR_RENESAS=y
-# CONFIG_SH_ETH is not set
-CONFIG_RAVB=y
-CONFIG_NET_VENDOR_RDC=y
-# CONFIG_R6040 is not set
-CONFIG_NET_VENDOR_ROCKER=y
-CONFIG_NET_VENDOR_SAMSUNG=y
-# CONFIG_SXGBE_ETH is not set
-CONFIG_NET_VENDOR_SEEQ=y
-CONFIG_NET_VENDOR_SILAN=y
-# CONFIG_SC92031 is not set
-CONFIG_NET_VENDOR_SIS=y
-# CONFIG_SIS900 is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SFC is not set
-CONFIG_NET_VENDOR_SMSC=y
-CONFIG_SMC91X=y
-# CONFIG_EPIC100 is not set
-CONFIG_SMSC911X=y
-# CONFIG_SMSC911X_ARCH_HOOKS is not set
-# CONFIG_SMSC9420 is not set
-CONFIG_NET_VENDOR_STMICRO=y
-# CONFIG_STMMAC_ETH is not set
-CONFIG_NET_VENDOR_SUN=y
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_CASSINI is not set
-# CONFIG_NIU is not set
-CONFIG_NET_VENDOR_SYNOPSYS=y
-# CONFIG_SYNOPSYS_DWC_ETH_QOS is not set
-CONFIG_NET_VENDOR_TEHUTI=y
-# CONFIG_TEHUTI is not set
-CONFIG_NET_VENDOR_TI=y
-# CONFIG_TI_CPSW_ALE is not set
-# CONFIG_TLAN is not set
-CONFIG_NET_VENDOR_VIA=y
-# CONFIG_VIA_RHINE is not set
-# CONFIG_VIA_VELOCITY is not set
-CONFIG_NET_VENDOR_WIZNET=y
-# CONFIG_WIZNET_W5100 is not set
-# CONFIG_WIZNET_W5300 is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_NET_SB1000 is not set
-CONFIG_PHYLIB=y
-CONFIG_SWPHY=y
-
-#
-# MDIO bus device drivers
-#
-# CONFIG_MDIO_BCM_IPROC is not set
-# CONFIG_MDIO_BCM_UNIMAC is not set
-CONFIG_MDIO_BITBANG=y
-CONFIG_MDIO_BUS_MUX=y
-CONFIG_MDIO_BUS_MUX_BCM_IPROC=y
-# CONFIG_MDIO_BUS_MUX_GPIO is not set
-# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
-# CONFIG_MDIO_GPIO is not set
-# CONFIG_MDIO_HISI_FEMAC is not set
-# CONFIG_MDIO_OCTEON is not set
-# CONFIG_MDIO_SUN4I is not set
-# CONFIG_MDIO_THUNDER is not set
-CONFIG_MDIO_XGENE=y
-
-#
-# MII PHY device drivers
-#
-# CONFIG_AMD_PHY is not set
-# CONFIG_AQUANTIA_PHY is not set
-# CONFIG_AT803X_PHY is not set
-# CONFIG_BCM7XXX_PHY is not set
-# CONFIG_BCM87XX_PHY is not set
-# CONFIG_BROADCOM_PHY is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_DP83848_PHY is not set
-# CONFIG_DP83867_PHY is not set
-CONFIG_FIXED_PHY=y
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_INTEL_XWAY_PHY is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_MARVELL_PHY is not set
-CONFIG_MICREL_PHY=y
-# CONFIG_MICROCHIP_PHY is not set
-# CONFIG_MICROSEMI_PHY is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_STE10XP is not set
-# CONFIG_TERANETICS_PHY is not set
-# CONFIG_VITESSE_PHY is not set
-# CONFIG_XILINX_GMII2RGMII is not set
-# CONFIG_MICREL_KS8995MA is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-CONFIG_USB_NET_DRIVERS=y
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-CONFIG_USB_PEGASUS=m
-CONFIG_USB_RTL8150=m
-CONFIG_USB_RTL8152=m
-# CONFIG_USB_LAN78XX is not set
-CONFIG_USB_USBNET=m
-CONFIG_USB_NET_AX8817X=m
-CONFIG_USB_NET_AX88179_178A=m
-CONFIG_USB_NET_CDCETHER=m
-# CONFIG_USB_NET_CDC_EEM is not set
-CONFIG_USB_NET_CDC_NCM=m
-# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
-# CONFIG_USB_NET_CDC_MBIM is not set
-CONFIG_USB_NET_DM9601=m
-# CONFIG_USB_NET_SR9700 is not set
-CONFIG_USB_NET_SR9800=m
-CONFIG_USB_NET_SMSC75XX=m
-CONFIG_USB_NET_SMSC95XX=m
-# CONFIG_USB_NET_GL620A is not set
-CONFIG_USB_NET_NET1080=m
-CONFIG_USB_NET_PLUSB=m
-CONFIG_USB_NET_MCS7830=m
-# CONFIG_USB_NET_RNDIS_HOST is not set
-CONFIG_USB_NET_CDC_SUBSET_ENABLE=m
-CONFIG_USB_NET_CDC_SUBSET=m
-# CONFIG_USB_ALI_M5632 is not set
-# CONFIG_USB_AN2720 is not set
-CONFIG_USB_BELKIN=y
-CONFIG_USB_ARMLINUX=y
-# CONFIG_USB_EPSON2888 is not set
-# CONFIG_USB_KC2190 is not set
-CONFIG_USB_NET_ZAURUS=m
-# CONFIG_USB_NET_CX82310_ETH is not set
-# CONFIG_USB_NET_KALMIA is not set
-# CONFIG_USB_NET_QMI_WWAN is not set
-# CONFIG_USB_HSO is not set
-# CONFIG_USB_NET_INT51X1 is not set
-# CONFIG_USB_IPHETH is not set
-# CONFIG_USB_SIERRA_NET is not set
-# CONFIG_USB_VL600 is not set
-# CONFIG_USB_NET_CH9200 is not set
-CONFIG_WLAN=y
-CONFIG_WLAN_VENDOR_ADMTEK=y
-# CONFIG_ADM8211 is not set
-CONFIG_WLAN_VENDOR_ATH=y
-# CONFIG_ATH_DEBUG is not set
-# CONFIG_ATH5K is not set
-# CONFIG_ATH5K_PCI is not set
-# CONFIG_ATH9K is not set
-# CONFIG_ATH9K_HTC is not set
-# CONFIG_CARL9170 is not set
-# CONFIG_ATH6KL is not set
-# CONFIG_AR5523 is not set
-# CONFIG_WIL6210 is not set
-# CONFIG_ATH10K is not set
-# CONFIG_WCN36XX is not set
-CONFIG_WLAN_VENDOR_ATMEL=y
-# CONFIG_ATMEL is not set
-# CONFIG_AT76C50X_USB is not set
-CONFIG_WLAN_VENDOR_BROADCOM=y
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-# CONFIG_BRCMSMAC is not set
-# CONFIG_BRCMFMAC is not set
-CONFIG_WLAN_VENDOR_CISCO=y
-CONFIG_WLAN_VENDOR_INTEL=y
-# CONFIG_IPW2100 is not set
-# CONFIG_IPW2200 is not set
-# CONFIG_IWL4965 is not set
-# CONFIG_IWL3945 is not set
-# CONFIG_IWLWIFI is not set
-CONFIG_WLAN_VENDOR_INTERSIL=y
-# CONFIG_HOSTAP is not set
-# CONFIG_HERMES is not set
-# CONFIG_P54_COMMON is not set
-# CONFIG_PRISM54 is not set
-CONFIG_WLAN_VENDOR_MARVELL=y
-# CONFIG_LIBERTAS is not set
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_MWIFIEX is not set
-# CONFIG_MWL8K is not set
-CONFIG_WLAN_VENDOR_MEDIATEK=y
-# CONFIG_MT7601U is not set
-CONFIG_WLAN_VENDOR_RALINK=y
-# CONFIG_RT2X00 is not set
-CONFIG_WLAN_VENDOR_REALTEK=y
-# CONFIG_RTL8180 is not set
-# CONFIG_RTL8187 is not set
-CONFIG_RTL_CARDS=m
-# CONFIG_RTL8192CE is not set
-# CONFIG_RTL8192SE is not set
-# CONFIG_RTL8192DE is not set
-# CONFIG_RTL8723AE is not set
-# CONFIG_RTL8723BE is not set
-# CONFIG_RTL8188EE is not set
-# CONFIG_RTL8192EE is not set
-# CONFIG_RTL8821AE is not set
-# CONFIG_RTL8192CU is not set
-# CONFIG_RTL8XXXU is not set
-CONFIG_WLAN_VENDOR_RSI=y
-# CONFIG_RSI_91X is not set
-CONFIG_WLAN_VENDOR_ST=y
-# CONFIG_CW1200 is not set
-CONFIG_WLAN_VENDOR_TI=y
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX is not set
-CONFIG_WL18XX=m
-CONFIG_WLCORE=m
-# CONFIG_WLCORE_SPI is not set
-CONFIG_WLCORE_SDIO=m
-CONFIG_WILINK_PLATFORM_DATA=y
-CONFIG_WLAN_VENDOR_ZYDAS=y
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_ZD1211RW is not set
-# CONFIG_MAC80211_HWSIM is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-CONFIG_XEN_NETDEV_FRONTEND=y
-# CONFIG_XEN_NETDEV_BACKEND is not set
-# CONFIG_VMXNET3 is not set
-# CONFIG_FUJITSU_ES is not set
-# CONFIG_ISDN is not set
-# CONFIG_NVM is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-CONFIG_INPUT_LEDS=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-
-#
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-CONFIG_INPUT_KEYBOARD=y
-# CONFIG_KEYBOARD_ADP5588 is not set
-# CONFIG_KEYBOARD_ADP5589 is not set
-CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_KEYBOARD_QT1070 is not set
-# CONFIG_KEYBOARD_QT2160 is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-CONFIG_KEYBOARD_GPIO=y
-# CONFIG_KEYBOARD_GPIO_POLLED is not set
-# CONFIG_KEYBOARD_TCA6416 is not set
-# CONFIG_KEYBOARD_TCA8418 is not set
-# CONFIG_KEYBOARD_MATRIX is not set
-# CONFIG_KEYBOARD_LM8323 is not set
-# CONFIG_KEYBOARD_LM8333 is not set
-# CONFIG_KEYBOARD_MAX7359 is not set
-# CONFIG_KEYBOARD_MCS is not set
-# CONFIG_KEYBOARD_MPR121 is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_TEGRA is not set
-# CONFIG_KEYBOARD_OPENCORES is not set
-# CONFIG_KEYBOARD_SAMSUNG is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_SH_KEYSC is not set
-# CONFIG_KEYBOARD_SUN4I_LRADC is not set
-# CONFIG_KEYBOARD_OMAP4 is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_CAP11XX is not set
-# CONFIG_KEYBOARD_BCM is not set
-CONFIG_INPUT_MOUSE=y
-CONFIG_MOUSE_PS2=y
-CONFIG_MOUSE_PS2_ALPS=y
-CONFIG_MOUSE_PS2_BYD=y
-CONFIG_MOUSE_PS2_LOGIPS2PP=y
-CONFIG_MOUSE_PS2_SYNAPTICS=y
-CONFIG_MOUSE_PS2_CYPRESS=y
-CONFIG_MOUSE_PS2_TRACKPOINT=y
-# CONFIG_MOUSE_PS2_ELANTECH is not set
-# CONFIG_MOUSE_PS2_SENTELIC is not set
-# CONFIG_MOUSE_PS2_TOUCHKIT is not set
-CONFIG_MOUSE_PS2_FOCALTECH=y
-# CONFIG_MOUSE_SERIAL is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
-# CONFIG_MOUSE_BCM5974 is not set
-# CONFIG_MOUSE_CYAPA is not set
-# CONFIG_MOUSE_ELAN_I2C is not set
-# CONFIG_MOUSE_VSXXXAA is not set
-# CONFIG_MOUSE_GPIO is not set
-# CONFIG_MOUSE_SYNAPTICS_I2C is not set
-# CONFIG_MOUSE_SYNAPTICS_USB is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-# CONFIG_RMI4_CORE is not set
-
-#
-# Hardware I/O ports
-#
-CONFIG_SERIO=y
-# CONFIG_SERIO_SERPORT is not set
-CONFIG_SERIO_AMBAKMI=y
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_RAW is not set
-# CONFIG_SERIO_ALTERA_PS2 is not set
-# CONFIG_SERIO_PS2MULT is not set
-# CONFIG_SERIO_ARC_PS2 is not set
-# CONFIG_SERIO_APBPS2 is not set
-# CONFIG_SERIO_SUN4I_PS2 is not set
-# CONFIG_USERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_TTY=y
-CONFIG_VT=y
-CONFIG_CONSOLE_TRANSLATIONS=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=16
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_NOZOMI is not set
-# CONFIG_N_GSM is not set
-# CONFIG_TRACE_SINK is not set
-CONFIG_DEVMEM=y
-CONFIG_DEVKMEM=y
-
-#
-# Serial drivers
-#
-CONFIG_SERIAL_EARLYCON=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
-CONFIG_SERIAL_8250_PNP=y
-# CONFIG_SERIAL_8250_FINTEK is not set
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_DMA=y
-CONFIG_SERIAL_8250_PCI=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
-CONFIG_SERIAL_8250_FSL=y
-CONFIG_SERIAL_8250_DW=y
-# CONFIG_SERIAL_8250_RT288X is not set
-CONFIG_SERIAL_8250_MT6577=y
-CONFIG_SERIAL_8250_UNIPHIER=y
-# CONFIG_SERIAL_8250_MOXA is not set
-CONFIG_SERIAL_OF_PLATFORM=y
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_AMBA_PL010 is not set
-CONFIG_SERIAL_AMBA_PL011=y
-CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
-# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
-CONFIG_SERIAL_MESON=y
-CONFIG_SERIAL_MESON_CONSOLE=y
-CONFIG_SERIAL_SAMSUNG=y
-CONFIG_SERIAL_SAMSUNG_UARTS_4=y
-CONFIG_SERIAL_SAMSUNG_UARTS=4
-CONFIG_SERIAL_SAMSUNG_CONSOLE=y
-CONFIG_SERIAL_TEGRA=y
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-# CONFIG_SERIAL_UARTLITE is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=11
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_SERIAL_SH_SCI_EARLYCON is not set
-# CONFIG_SERIAL_SH_SCI_DMA is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_SERIAL_JSM is not set
-CONFIG_SERIAL_MSM=y
-CONFIG_SERIAL_MSM_CONSOLE=y
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_SC16IS7XX is not set
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-CONFIG_SERIAL_XILINX_PS_UART=y
-CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_SERIAL_RP2 is not set
-# CONFIG_SERIAL_FSL_LPUART is not set
-# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
-# CONFIG_SERIAL_SPRD is not set
-CONFIG_SERIAL_MVEBU_UART=y
-CONFIG_SERIAL_MVEBU_CONSOLE=y
-CONFIG_SERIAL_MCTRL_GPIO=y
-CONFIG_HVC_DRIVER=y
-CONFIG_HVC_IRQ=y
-CONFIG_HVC_XEN=y
-CONFIG_HVC_XEN_FRONTEND=y
-# CONFIG_HVC_DCC is not set
-CONFIG_VIRTIO_CONSOLE=y
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
-
-#
-# PCMCIA character devices
-#
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_HPET is not set
-# CONFIG_TCG_TPM is not set
-CONFIG_DEVPORT=y
-# CONFIG_XILLYBUS is not set
-
-#
-# I2C support
-#
-CONFIG_I2C=y
-CONFIG_ACPI_I2C_OPREGION=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_COMPAT=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_MUX=y
-
-#
-# Multiplexer I2C Chip support
-#
-# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
-# CONFIG_I2C_MUX_GPIO is not set
-# CONFIG_I2C_MUX_PCA9541 is not set
-CONFIG_I2C_MUX_PCA954x=y
-# CONFIG_I2C_MUX_PINCTRL is not set
-# CONFIG_I2C_MUX_REG is not set
-# CONFIG_I2C_DEMUX_PINCTRL is not set
-CONFIG_I2C_HELPER_AUTO=y
-CONFIG_I2C_ALGOBIT=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# PC SMBus host controller drivers
-#
-# CONFIG_I2C_ALI1535 is not set
-# CONFIG_I2C_ALI1563 is not set
-# CONFIG_I2C_ALI15X3 is not set
-# CONFIG_I2C_AMD756 is not set
-# CONFIG_I2C_AMD8111 is not set
-# CONFIG_I2C_HIX5HD2 is not set
-# CONFIG_I2C_I801 is not set
-# CONFIG_I2C_ISCH is not set
-# CONFIG_I2C_PIIX4 is not set
-# CONFIG_I2C_NFORCE2 is not set
-# CONFIG_I2C_SIS5595 is not set
-# CONFIG_I2C_SIS630 is not set
-# CONFIG_I2C_SIS96X is not set
-# CONFIG_I2C_VIA is not set
-# CONFIG_I2C_VIAPRO is not set
-
-#
-# ACPI drivers
-#
-# CONFIG_I2C_SCMI is not set
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-CONFIG_I2C_BCM_IPROC=y
-# CONFIG_I2C_CADENCE is not set
-# CONFIG_I2C_CBUS_GPIO is not set
-CONFIG_I2C_DESIGNWARE_CORE=y
-CONFIG_I2C_DESIGNWARE_PLATFORM=y
-# CONFIG_I2C_DESIGNWARE_PCI is not set
-# CONFIG_I2C_EMEV2 is not set
-CONFIG_I2C_EXYNOS5=y
-# CONFIG_I2C_GPIO is not set
-CONFIG_I2C_IMX=y
-# CONFIG_I2C_MESON is not set
-# CONFIG_I2C_MT65XX is not set
-CONFIG_I2C_MV64XXX=y
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PXA_PCI is not set
-CONFIG_I2C_QUP=y
-# CONFIG_I2C_RIIC is not set
-# CONFIG_I2C_RK3X is not set
-# CONFIG_I2C_SH_MOBILE is not set
-# CONFIG_I2C_SIMTEC is not set
-CONFIG_I2C_TEGRA=y
-# CONFIG_I2C_UNIPHIER is not set
-CONFIG_I2C_UNIPHIER_F=y
-# CONFIG_I2C_VERSATILE is not set
-# CONFIG_I2C_THUNDERX is not set
-# CONFIG_I2C_XILINX is not set
-# CONFIG_I2C_XLP9XX is not set
-CONFIG_I2C_RCAR=y
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_XGENE_SLIMPRO is not set
-# CONFIG_I2C_STUB is not set
-CONFIG_I2C_SLAVE=y
-# CONFIG_I2C_SLAVE_EEPROM is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_AXI_SPI_ENGINE is not set
-CONFIG_SPI_BCM_QSPI=y
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_CADENCE is not set
-# CONFIG_SPI_DESIGNWARE is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_FSL_DSPI is not set
-# CONFIG_SPI_MESON_SPIFC is not set
-# CONFIG_SPI_MT65XX is not set
-# CONFIG_SPI_OC_TINY is not set
-CONFIG_SPI_ORION=y
-CONFIG_SPI_PL022=y
-# CONFIG_SPI_PXA2XX is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_ROCKCHIP is not set
-# CONFIG_SPI_RSPI is not set
-CONFIG_SPI_QUP=y
-# CONFIG_SPI_S3C64XX is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_SH_MSIOF is not set
-# CONFIG_SPI_SH_HSPI is not set
-# CONFIG_SPI_SUN4I is not set
-# CONFIG_SPI_SUN6I is not set
-# CONFIG_SPI_TEGRA114 is not set
-# CONFIG_SPI_TEGRA20_SFLASH is not set
-# CONFIG_SPI_TEGRA20_SLINK is not set
-# CONFIG_SPI_THUNDERX is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_XLP is not set
-# CONFIG_SPI_ZYNQMP_GQSPI is not set
-
-#
-# SPI Protocol Masters
-#
-CONFIG_SPI_SPIDEV=m
-# CONFIG_SPI_LOOPBACK_TEST is not set
-# CONFIG_SPI_TLE62X0 is not set
-CONFIG_SPMI=y
-CONFIG_SPMI_MSM_PMIC_ARB=y
-# CONFIG_HSI is not set
-
-#
-# PPS support
-#
-CONFIG_PPS=y
-# CONFIG_PPS_DEBUG is not set
-
-#
-# PPS clients support
-#
-# CONFIG_PPS_CLIENT_KTIMER is not set
-# CONFIG_PPS_CLIENT_LDISC is not set
-# CONFIG_PPS_CLIENT_GPIO is not set
-
-#
-# PPS generators support
-#
-
-#
-# PTP clock support
-#
-CONFIG_PTP_1588_CLOCK=y
-
-#
-# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
-#
-CONFIG_PINCTRL=y
-
-#
-# Pin controllers
-#
-CONFIG_PINMUX=y
-CONFIG_PINCONF=y
-CONFIG_GENERIC_PINCONF=y
-# CONFIG_DEBUG_PINCTRL is not set
-# CONFIG_PINCTRL_AMD is not set
-CONFIG_PINCTRL_MESON=y
-CONFIG_PINCTRL_ROCKCHIP=y
-CONFIG_PINCTRL_SINGLE=y
-CONFIG_PINCTRL_IPROC_GPIO=y
-CONFIG_PINCTRL_NS2_MUX=y
-# CONFIG_PINCTRL_BERLIN_BG2 is not set
-# CONFIG_PINCTRL_BERLIN_BG2CD is not set
-# CONFIG_PINCTRL_BERLIN_BG2Q is not set
-# CONFIG_PINCTRL_BERLIN_BG4CT is not set
-# CONFIG_PINCTRL_BAYTRAIL is not set
-# CONFIG_PINCTRL_CHERRYVIEW is not set
-# CONFIG_PINCTRL_BROXTON is not set
-# CONFIG_PINCTRL_SUNRISEPOINT is not set
-CONFIG_PINCTRL_MSM=y
-# CONFIG_PINCTRL_APQ8064 is not set
-# CONFIG_PINCTRL_APQ8084 is not set
-# CONFIG_PINCTRL_IPQ4019 is not set
-# CONFIG_PINCTRL_IPQ8064 is not set
-# CONFIG_PINCTRL_MSM8660 is not set
-# CONFIG_PINCTRL_MSM8960 is not set
-# CONFIG_PINCTRL_MDM9615 is not set
-# CONFIG_PINCTRL_MSM8X74 is not set
-CONFIG_PINCTRL_MSM8916=y
-# CONFIG_PINCTRL_MSM8996 is not set
-# CONFIG_PINCTRL_QDF2XXX is not set
-CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
-# CONFIG_PINCTRL_QCOM_SSBI_PMIC is not set
-CONFIG_PINCTRL_SAMSUNG=y
-CONFIG_PINCTRL_EXYNOS=y
-CONFIG_PINCTRL_SH_PFC=y
-CONFIG_PINCTRL_PFC_R8A7795=y
-CONFIG_PINCTRL_SUNXI=y
-# CONFIG_PINCTRL_SUN4I_A10 is not set
-# CONFIG_PINCTRL_SUN5I_A10S is not set
-# CONFIG_PINCTRL_SUN5I_A13 is not set
-# CONFIG_PINCTRL_GR8 is not set
-# CONFIG_PINCTRL_SUN6I_A31 is not set
-# CONFIG_PINCTRL_SUN6I_A31S is not set
-# CONFIG_PINCTRL_SUN6I_A31_R is not set
-# CONFIG_PINCTRL_SUN7I_A20 is not set
-# CONFIG_PINCTRL_SUN8I_A23 is not set
-# CONFIG_PINCTRL_SUN8I_A33 is not set
-# CONFIG_PINCTRL_SUN8I_A83T is not set
-# CONFIG_PINCTRL_SUN8I_A23_R is not set
-# CONFIG_PINCTRL_SUN8I_H3 is not set
-# CONFIG_PINCTRL_SUN8I_H3_R is not set
-# CONFIG_PINCTRL_SUN9I_A80 is not set
-# CONFIG_PINCTRL_SUN9I_A80_R is not set
-CONFIG_PINCTRL_SUN50I_A64=y
-CONFIG_PINCTRL_TEGRA=y
-CONFIG_PINCTRL_TEGRA124=y
-CONFIG_PINCTRL_TEGRA210=y
-CONFIG_PINCTRL_TEGRA_XUSB=y
-CONFIG_PINCTRL_UNIPHIER=y
-CONFIG_PINCTRL_UNIPHIER_LD4=y
-CONFIG_PINCTRL_UNIPHIER_PRO4=y
-CONFIG_PINCTRL_UNIPHIER_SLD8=y
-CONFIG_PINCTRL_UNIPHIER_PRO5=y
-CONFIG_PINCTRL_UNIPHIER_PXS2=y
-CONFIG_PINCTRL_UNIPHIER_LD6B=y
-CONFIG_PINCTRL_UNIPHIER_LD11=y
-CONFIG_PINCTRL_UNIPHIER_LD20=y
-CONFIG_PINCTRL_MTK=y
-# CONFIG_PINCTRL_MT2701 is not set
-# CONFIG_PINCTRL_MT7623 is not set
-# CONFIG_PINCTRL_MT8135 is not set
-# CONFIG_PINCTRL_MT8127 is not set
-CONFIG_PINCTRL_MT8173=y
-# CONFIG_PINCTRL_MT6397 is not set
-CONFIG_GPIOLIB=y
-CONFIG_OF_GPIO=y
-CONFIG_GPIO_ACPI=y
-CONFIG_GPIOLIB_IRQCHIP=y
-# CONFIG_DEBUG_GPIO is not set
-CONFIG_GPIO_SYSFS=y
-CONFIG_GPIO_GENERIC=y
-
-#
-# Memory mapped GPIO drivers
-#
-# CONFIG_GPIO_74XX_MMIO is not set
-# CONFIG_GPIO_ALTERA is not set
-# CONFIG_GPIO_AMDPT is not set
-CONFIG_GPIO_DWAPB=y
-CONFIG_GPIO_GENERIC_PLATFORM=y
-# CONFIG_GPIO_GRGPIO is not set
-# CONFIG_GPIO_MOCKUP is not set
-# CONFIG_GPIO_MPC8XXX is not set
-CONFIG_GPIO_PL061=y
-CONFIG_GPIO_RCAR=y
-# CONFIG_GPIO_SYSCON is not set
-CONFIG_GPIO_TEGRA=y
-# CONFIG_GPIO_VX855 is not set
-CONFIG_GPIO_XGENE=y
-# CONFIG_GPIO_XGENE_SB is not set
-# CONFIG_GPIO_XILINX is not set
-# CONFIG_GPIO_XLP is not set
-# CONFIG_GPIO_ZYNQ is not set
-# CONFIG_GPIO_ZX is not set
-
-#
-# I2C GPIO expanders
-#
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_ADNP is not set
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_TPIC2810 is not set
-# CONFIG_GPIO_TS4900 is not set
-
-#
-# MFD GPIO expanders
-#
-
-#
-# PCI GPIO expanders
-#
-# CONFIG_GPIO_AMD8111 is not set
-# CONFIG_GPIO_BT8XX is not set
-# CONFIG_GPIO_ML_IOH is not set
-# CONFIG_GPIO_RDC321X is not set
-
-#
-# SPI GPIO expanders
-#
-# CONFIG_GPIO_74X164 is not set
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_PISOSR is not set
-
-#
-# SPI or I2C GPIO expanders
-#
-# CONFIG_GPIO_MCP23S08 is not set
-
-#
-# USB GPIO expanders
-#
-# CONFIG_W1 is not set
-# CONFIG_POWER_AVS is not set
-CONFIG_POWER_RESET=y
-# CONFIG_POWER_RESET_GPIO is not set
-# CONFIG_POWER_RESET_GPIO_RESTART is not set
-# CONFIG_POWER_RESET_HISI is not set
-CONFIG_POWER_RESET_MSM=y
-# CONFIG_POWER_RESET_LTC2952 is not set
-# CONFIG_POWER_RESET_RESTART is not set
-CONFIG_POWER_RESET_VEXPRESS=y
-CONFIG_POWER_RESET_XGENE=y
-CONFIG_POWER_RESET_SYSCON=y
-# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
-# CONFIG_SYSCON_REBOOT_MODE is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BATTERY_BQ27XXX is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_QCOM_SMBB is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_BQ24190 is not set
-# CONFIG_CHARGER_BQ24257 is not set
-# CONFIG_CHARGER_BQ24735 is not set
-# CONFIG_CHARGER_BQ25890 is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_BATTERY_GAUGE_LTC2941 is not set
-# CONFIG_CHARGER_RT9455 is not set
-CONFIG_HWMON=y
-# CONFIG_HWMON_VID is not set
-# CONFIG_HWMON_DEBUG_CHIP is not set
-
-#
-# Native drivers
-#
-# CONFIG_SENSORS_AD7314 is not set
-# CONFIG_SENSORS_AD7414 is not set
-# CONFIG_SENSORS_AD7418 is not set
-# CONFIG_SENSORS_ADM1021 is not set
-# CONFIG_SENSORS_ADM1025 is not set
-# CONFIG_SENSORS_ADM1026 is not set
-# CONFIG_SENSORS_ADM1029 is not set
-# CONFIG_SENSORS_ADM1031 is not set
-# CONFIG_SENSORS_ADM9240 is not set
-# CONFIG_SENSORS_ADT7310 is not set
-# CONFIG_SENSORS_ADT7410 is not set
-# CONFIG_SENSORS_ADT7411 is not set
-# CONFIG_SENSORS_ADT7462 is not set
-# CONFIG_SENSORS_ADT7470 is not set
-# CONFIG_SENSORS_ADT7475 is not set
-# CONFIG_SENSORS_ASC7621 is not set
-# CONFIG_SENSORS_ARM_SCPI is not set
-# CONFIG_SENSORS_ATXP1 is not set
-# CONFIG_SENSORS_DS620 is not set
-# CONFIG_SENSORS_DS1621 is not set
-# CONFIG_SENSORS_I5K_AMB is not set
-# CONFIG_SENSORS_F71805F is not set
-# CONFIG_SENSORS_F71882FG is not set
-# CONFIG_SENSORS_F75375S is not set
-# CONFIG_SENSORS_FTSTEUTATES is not set
-# CONFIG_SENSORS_GL518SM is not set
-# CONFIG_SENSORS_GL520SM is not set
-# CONFIG_SENSORS_G760A is not set
-# CONFIG_SENSORS_G762 is not set
-# CONFIG_SENSORS_GPIO_FAN is not set
-# CONFIG_SENSORS_HIH6130 is not set
-# CONFIG_SENSORS_IT87 is not set
-# CONFIG_SENSORS_JC42 is not set
-# CONFIG_SENSORS_POWR1220 is not set
-# CONFIG_SENSORS_LINEAGE is not set
-# CONFIG_SENSORS_LTC2945 is not set
-# CONFIG_SENSORS_LTC2990 is not set
-# CONFIG_SENSORS_LTC4151 is not set
-# CONFIG_SENSORS_LTC4215 is not set
-# CONFIG_SENSORS_LTC4222 is not set
-# CONFIG_SENSORS_LTC4245 is not set
-# CONFIG_SENSORS_LTC4260 is not set
-# CONFIG_SENSORS_LTC4261 is not set
-# CONFIG_SENSORS_MAX1111 is not set
-# CONFIG_SENSORS_MAX16065 is not set
-# CONFIG_SENSORS_MAX1619 is not set
-# CONFIG_SENSORS_MAX1668 is not set
-# CONFIG_SENSORS_MAX197 is not set
-# CONFIG_SENSORS_MAX31722 is not set
-# CONFIG_SENSORS_MAX6639 is not set
-# CONFIG_SENSORS_MAX6642 is not set
-# CONFIG_SENSORS_MAX6650 is not set
-# CONFIG_SENSORS_MAX6697 is not set
-# CONFIG_SENSORS_MAX31790 is not set
-# CONFIG_SENSORS_MCP3021 is not set
-# CONFIG_SENSORS_ADCXX is not set
-# CONFIG_SENSORS_LM63 is not set
-# CONFIG_SENSORS_LM70 is not set
-# CONFIG_SENSORS_LM73 is not set
-# CONFIG_SENSORS_LM75 is not set
-# CONFIG_SENSORS_LM77 is not set
-# CONFIG_SENSORS_LM78 is not set
-# CONFIG_SENSORS_LM80 is not set
-# CONFIG_SENSORS_LM83 is not set
-# CONFIG_SENSORS_LM85 is not set
-# CONFIG_SENSORS_LM87 is not set
-CONFIG_SENSORS_LM90=m
-# CONFIG_SENSORS_LM92 is not set
-# CONFIG_SENSORS_LM93 is not set
-# CONFIG_SENSORS_LM95234 is not set
-# CONFIG_SENSORS_LM95241 is not set
-# CONFIG_SENSORS_LM95245 is not set
-# CONFIG_SENSORS_PC87360 is not set
-# CONFIG_SENSORS_PC87427 is not set
-# CONFIG_SENSORS_NTC_THERMISTOR is not set
-# CONFIG_SENSORS_NCT6683 is not set
-# CONFIG_SENSORS_NCT6775 is not set
-# CONFIG_SENSORS_NCT7802 is not set
-# CONFIG_SENSORS_NCT7904 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_PMBUS is not set
-# CONFIG_SENSORS_SHT15 is not set
-# CONFIG_SENSORS_SHT21 is not set
-# CONFIG_SENSORS_SHT3x is not set
-# CONFIG_SENSORS_SHTC1 is not set
-# CONFIG_SENSORS_SIS5595 is not set
-# CONFIG_SENSORS_DME1737 is not set
-# CONFIG_SENSORS_EMC1403 is not set
-# CONFIG_SENSORS_EMC2103 is not set
-# CONFIG_SENSORS_EMC6W201 is not set
-# CONFIG_SENSORS_SMSC47M1 is not set
-# CONFIG_SENSORS_SMSC47M192 is not set
-# CONFIG_SENSORS_SMSC47B397 is not set
-# CONFIG_SENSORS_SCH56XX_COMMON is not set
-# CONFIG_SENSORS_SCH5627 is not set
-# CONFIG_SENSORS_SCH5636 is not set
-# CONFIG_SENSORS_SMM665 is not set
-# CONFIG_SENSORS_ADC128D818 is not set
-# CONFIG_SENSORS_ADS1015 is not set
-# CONFIG_SENSORS_ADS7828 is not set
-# CONFIG_SENSORS_ADS7871 is not set
-# CONFIG_SENSORS_AMC6821 is not set
-# CONFIG_SENSORS_INA209 is not set
-CONFIG_SENSORS_INA2XX=m
-# CONFIG_SENSORS_INA3221 is not set
-# CONFIG_SENSORS_TC74 is not set
-# CONFIG_SENSORS_THMC50 is not set
-# CONFIG_SENSORS_TMP102 is not set
-# CONFIG_SENSORS_TMP103 is not set
-# CONFIG_SENSORS_TMP401 is not set
-# CONFIG_SENSORS_TMP421 is not set
-# CONFIG_SENSORS_VEXPRESS is not set
-# CONFIG_SENSORS_VIA686A is not set
-# CONFIG_SENSORS_VT1211 is not set
-# CONFIG_SENSORS_VT8231 is not set
-# CONFIG_SENSORS_W83781D is not set
-# CONFIG_SENSORS_W83791D is not set
-# CONFIG_SENSORS_W83792D is not set
-# CONFIG_SENSORS_W83793 is not set
-# CONFIG_SENSORS_W83795 is not set
-# CONFIG_SENSORS_W83L785TS is not set
-# CONFIG_SENSORS_W83L786NG is not set
-# CONFIG_SENSORS_W83627HF is not set
-# CONFIG_SENSORS_W83627EHF is not set
-
-#
-# ACPI drivers
-#
-# CONFIG_SENSORS_ACPI_POWER is not set
-CONFIG_THERMAL=y
-CONFIG_THERMAL_HWMON=y
-CONFIG_THERMAL_OF=y
-# CONFIG_THERMAL_WRITABLE_TRIPS is not set
-CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-CONFIG_THERMAL_GOV_STEP_WISE=y
-# CONFIG_THERMAL_GOV_BANG_BANG is not set
-# CONFIG_THERMAL_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
-CONFIG_THERMAL_EMULATION=y
-# CONFIG_QORIQ_THERMAL is not set
-# CONFIG_ROCKCHIP_THERMAL is not set
-# CONFIG_RCAR_THERMAL is not set
-# CONFIG_ARMADA_THERMAL is not set
-
-#
-# ACPI INT340X thermal drivers
-#
-CONFIG_MTK_THERMAL=y
-
-#
-# Samsung thermal drivers
-#
-CONFIG_EXYNOS_THERMAL=y
-
-#
-# NVIDIA Tegra thermal drivers
-#
-# CONFIG_TEGRA_SOCTHERM is not set
-
-#
-# Qualcomm thermal drivers
-#
-CONFIG_WATCHDOG=y
-CONFIG_WATCHDOG_CORE=y
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-# CONFIG_WATCHDOG_SYSFS is not set
-
-#
-# Watchdog Device Drivers
-#
-# CONFIG_SOFT_WATCHDOG is not set
-# CONFIG_GPIO_WATCHDOG is not set
-# CONFIG_WDAT_WDT is not set
-# CONFIG_XILINX_WATCHDOG is not set
-# CONFIG_ZIIRAVE_WATCHDOG is not set
-# CONFIG_ARM_SP805_WATCHDOG is not set
-# CONFIG_ARM_SBSA_WATCHDOG is not set
-# CONFIG_CADENCE_WATCHDOG is not set
-CONFIG_HAVE_S3C2410_WATCHDOG=y
-# CONFIG_S3C2410_WATCHDOG is not set
-# CONFIG_DW_WATCHDOG is not set
-# CONFIG_SUNXI_WATCHDOG is not set
-# CONFIG_MAX63XX_WATCHDOG is not set
-# CONFIG_IMX2_WDT is not set
-# CONFIG_TEGRA_WATCHDOG is not set
-# CONFIG_QCOM_WDT is not set
-# CONFIG_MESON_GXBB_WATCHDOG is not set
-# CONFIG_MESON_WATCHDOG is not set
-# CONFIG_MEDIATEK_WATCHDOG is not set
-CONFIG_RENESAS_WDT=y
-# CONFIG_ALIM7101_WDT is not set
-# CONFIG_I6300ESB_WDT is not set
-# CONFIG_MEN_A21_WDT is not set
-# CONFIG_XEN_WDT is not set
-
-#
-# PCI-based Watchdog Cards
-#
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_WDTPCI is not set
-
-#
-# USB-based Watchdog Cards
-#
-# CONFIG_USBPCWATCHDOG is not set
-
-#
-# Watchdog Pretimeout Governors
-#
-# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-CONFIG_BCMA_POSSIBLE=y
-
-#
-# Broadcom specific AMBA
-#
-# CONFIG_BCMA is not set
-
-#
-# Multifunction device drivers
-#
-CONFIG_MFD_CORE=y
-# CONFIG_MFD_ACT8945A is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_MFD_AS3722 is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_ATMEL_FLEXCOM is not set
-# CONFIG_MFD_ATMEL_HLCDC is not set
-# CONFIG_MFD_BCM590XX is not set
-# CONFIG_MFD_AXP20X_I2C is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_DA9062 is not set
-# CONFIG_MFD_DA9063 is not set
-# CONFIG_MFD_DA9150 is not set
-# CONFIG_MFD_DLN2 is not set
-# CONFIG_MFD_EXYNOS_LPASS is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_MFD_HI6421_PMIC is not set
-CONFIG_MFD_HI655X_PMIC=y
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_LPC_ICH is not set
-# CONFIG_LPC_SCH is not set
-# CONFIG_INTEL_SOC_PMIC is not set
-# CONFIG_MFD_JANZ_CMODIO is not set
-# CONFIG_MFD_KEMPLD is not set
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_MAX14577 is not set
-# CONFIG_MFD_MAX77620 is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX77843 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_MFD_MT6397 is not set
-# CONFIG_MFD_MENF21BMC is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_QCOM_RPM is not set
-CONFIG_MFD_SPMI_PMIC=y
-# CONFIG_MFD_RDC321X is not set
-# CONFIG_MFD_RTSX_PCI is not set
-# CONFIG_MFD_RT5033 is not set
-# CONFIG_MFD_RTSX_USB is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_RK808 is not set
-# CONFIG_MFD_RN5T618 is not set
-CONFIG_MFD_SEC_CORE=y
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SKY81452 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SUN6I_PRCM is not set
-CONFIG_MFD_SYSCON=y
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_LP3943 is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_MFD_TPS65086 is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TI_LP873X is not set
-# CONFIG_MFD_TPS65218 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_VX855 is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8994 is not set
-CONFIG_MFD_VEXPRESS_SYSREG=y
-CONFIG_REGULATOR=y
-# CONFIG_REGULATOR_DEBUG is not set
-CONFIG_REGULATOR_FIXED_VOLTAGE=y
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_ACT8865 is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_ANATOP is not set
-# CONFIG_REGULATOR_DA9210 is not set
-# CONFIG_REGULATOR_DA9211 is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_GPIO is not set
-CONFIG_REGULATOR_HI655X=y
-# CONFIG_REGULATOR_ISL9305 is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_LTC3589 is not set
-# CONFIG_REGULATOR_LTC3676 is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_MT6311 is not set
-# CONFIG_REGULATOR_PFUZE100 is not set
-# CONFIG_REGULATOR_PV88060 is not set
-# CONFIG_REGULATOR_PV88080 is not set
-# CONFIG_REGULATOR_PV88090 is not set
-CONFIG_REGULATOR_QCOM_SMD_RPM=y
-CONFIG_REGULATOR_QCOM_SPMI=y
-# CONFIG_REGULATOR_S2MPA01 is not set
-CONFIG_REGULATOR_S2MPS11=y
-# CONFIG_REGULATOR_S5M8767 is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_REGULATOR_VEXPRESS is not set
-# CONFIG_MEDIA_SUPPORT is not set
-
-#
-# Graphics support
-#
-CONFIG_VGA_ARB=y
-CONFIG_VGA_ARB_MAX_GPUS=16
-# CONFIG_TEGRA_HOST1X is not set
-# CONFIG_DRM is not set
-
-#
-# ACP (Audio CoProcessor) Configuration
-#
-
-#
-# Frame buffer Devices
-#
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-CONFIG_FB_CMDLINE=y
-CONFIG_FB_NOTIFY=y
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-CONFIG_FB_SYS_FILLRECT=y
-CONFIG_FB_SYS_COPYAREA=y
-CONFIG_FB_SYS_IMAGEBLIT=y
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-CONFIG_FB_SYS_FOPS=y
-CONFIG_FB_DEFERRED_IO=y
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-CONFIG_FB_MODE_HELPERS=y
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_CIRRUS is not set
-# CONFIG_FB_PM2 is not set
-CONFIG_FB_ARMCLCD=y
-# CONFIG_FB_CYBER2000 is not set
-# CONFIG_FB_ASILIANT is not set
-# CONFIG_FB_IMSTT is not set
-# CONFIG_FB_EFI is not set
-# CONFIG_FB_OPENCORES is not set
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_NVIDIA is not set
-# CONFIG_FB_RIVA is not set
-# CONFIG_FB_I740 is not set
-# CONFIG_FB_MATROX is not set
-# CONFIG_FB_RADEON is not set
-# CONFIG_FB_ATY128 is not set
-# CONFIG_FB_ATY is not set
-# CONFIG_FB_S3 is not set
-# CONFIG_FB_SAVAGE is not set
-# CONFIG_FB_SIS is not set
-# CONFIG_FB_NEOMAGIC is not set
-# CONFIG_FB_KYRO is not set
-# CONFIG_FB_3DFX is not set
-# CONFIG_FB_VOODOO1 is not set
-# CONFIG_FB_VT8623 is not set
-# CONFIG_FB_TRIDENT is not set
-# CONFIG_FB_ARK is not set
-# CONFIG_FB_PM3 is not set
-# CONFIG_FB_CARMINE is not set
-# CONFIG_FB_SH_MOBILE_LCDC is not set
-# CONFIG_FB_S3C is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_IBM_GXT4500 is not set
-# CONFIG_FB_VIRTUAL is not set
-CONFIG_XEN_FBDEV_FRONTEND=y
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MB862XX is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_FB_SH_MOBILE_MERAM is not set
-# CONFIG_FB_SSD1307 is not set
-# CONFIG_FB_SM712 is not set
-CONFIG_BACKLIGHT_LCD_SUPPORT=y
-CONFIG_LCD_CLASS_DEVICE=m
-# CONFIG_LCD_L4F00242T03 is not set
-# CONFIG_LCD_LMS283GF05 is not set
-# CONFIG_LCD_LTV350QV is not set
-# CONFIG_LCD_ILI922X is not set
-# CONFIG_LCD_ILI9320 is not set
-# CONFIG_LCD_TDO24M is not set
-# CONFIG_LCD_VGG2432A4 is not set
-# CONFIG_LCD_PLATFORM is not set
-# CONFIG_LCD_S6E63M0 is not set
-# CONFIG_LCD_LD9040 is not set
-# CONFIG_LCD_AMS369FG06 is not set
-# CONFIG_LCD_LMS501KF03 is not set
-# CONFIG_LCD_HX8357 is not set
-CONFIG_BACKLIGHT_CLASS_DEVICE=y
-CONFIG_BACKLIGHT_GENERIC=y
-# CONFIG_BACKLIGHT_PM8941_WLED is not set
-# CONFIG_BACKLIGHT_ADP8860 is not set
-# CONFIG_BACKLIGHT_ADP8870 is not set
-# CONFIG_BACKLIGHT_LM3639 is not set
-# CONFIG_BACKLIGHT_GPIO is not set
-# CONFIG_BACKLIGHT_LV5207LP is not set
-# CONFIG_BACKLIGHT_BD6107 is not set
-# CONFIG_VGASTATE is not set
-CONFIG_VIDEOMODE_HELPERS=y
-
-#
-# Console display driver support
-#
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_DUMMY_CONSOLE_COLUMNS=80
-CONFIG_DUMMY_CONSOLE_ROWS=25
-CONFIG_FRAMEBUFFER_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
-# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_LOGO_LINUX_CLUT224=y
-CONFIG_SOUND=y
-# CONFIG_SOUND_OSS_CORE is not set
-CONFIG_SND=y
-CONFIG_SND_TIMER=y
-CONFIG_SND_PCM=y
-CONFIG_SND_JACK=y
-CONFIG_SND_JACK_INPUT_DEV=y
-# CONFIG_SND_SEQUENCER is not set
-# CONFIG_SND_MIXER_OSS is not set
-# CONFIG_SND_PCM_OSS is not set
-CONFIG_SND_PCM_TIMER=y
-# CONFIG_SND_HRTIMER is not set
-# CONFIG_SND_DYNAMIC_MINORS is not set
-CONFIG_SND_SUPPORT_OLD_API=y
-CONFIG_SND_PROC_FS=y
-CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VERBOSE_PRINTK is not set
-# CONFIG_SND_DEBUG is not set
-# CONFIG_SND_RAWMIDI_SEQ is not set
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
-CONFIG_SND_PCI=y
-# CONFIG_SND_AD1889 is not set
-# CONFIG_SND_ALS300 is not set
-# CONFIG_SND_ALI5451 is not set
-# CONFIG_SND_ATIIXP is not set
-# CONFIG_SND_ATIIXP_MODEM is not set
-# CONFIG_SND_AU8810 is not set
-# CONFIG_SND_AU8820 is not set
-# CONFIG_SND_AU8830 is not set
-# CONFIG_SND_AW2 is not set
-# CONFIG_SND_AZT3328 is not set
-# CONFIG_SND_BT87X is not set
-# CONFIG_SND_CA0106 is not set
-# CONFIG_SND_CMIPCI is not set
-# CONFIG_SND_OXYGEN is not set
-# CONFIG_SND_CS4281 is not set
-# CONFIG_SND_CS46XX is not set
-# CONFIG_SND_CTXFI is not set
-# CONFIG_SND_DARLA20 is not set
-# CONFIG_SND_GINA20 is not set
-# CONFIG_SND_LAYLA20 is not set
-# CONFIG_SND_DARLA24 is not set
-# CONFIG_SND_GINA24 is not set
-# CONFIG_SND_LAYLA24 is not set
-# CONFIG_SND_MONA is not set
-# CONFIG_SND_MIA is not set
-# CONFIG_SND_ECHO3G is not set
-# CONFIG_SND_INDIGO is not set
-# CONFIG_SND_INDIGOIO is not set
-# CONFIG_SND_INDIGODJ is not set
-# CONFIG_SND_INDIGOIOX is not set
-# CONFIG_SND_INDIGODJX is not set
-# CONFIG_SND_EMU10K1 is not set
-# CONFIG_SND_EMU10K1X is not set
-# CONFIG_SND_ENS1370 is not set
-# CONFIG_SND_ENS1371 is not set
-# CONFIG_SND_ES1938 is not set
-# CONFIG_SND_ES1968 is not set
-# CONFIG_SND_FM801 is not set
-# CONFIG_SND_HDSP is not set
-# CONFIG_SND_HDSPM is not set
-# CONFIG_SND_ICE1712 is not set
-# CONFIG_SND_ICE1724 is not set
-# CONFIG_SND_INTEL8X0 is not set
-# CONFIG_SND_INTEL8X0M is not set
-# CONFIG_SND_KORG1212 is not set
-# CONFIG_SND_LOLA is not set
-# CONFIG_SND_LX6464ES is not set
-# CONFIG_SND_MAESTRO3 is not set
-# CONFIG_SND_MIXART is not set
-# CONFIG_SND_NM256 is not set
-# CONFIG_SND_PCXHR is not set
-# CONFIG_SND_RIPTIDE is not set
-# CONFIG_SND_RME32 is not set
-# CONFIG_SND_RME96 is not set
-# CONFIG_SND_RME9652 is not set
-# CONFIG_SND_SE6X is not set
-# CONFIG_SND_SONICVIBES is not set
-# CONFIG_SND_TRIDENT is not set
-# CONFIG_SND_VIA82XX is not set
-# CONFIG_SND_VIA82XX_MODEM is not set
-# CONFIG_SND_VIRTUOSO is not set
-# CONFIG_SND_VX222 is not set
-# CONFIG_SND_YMFPCI is not set
-
-#
-# HD-Audio
-#
-# CONFIG_SND_HDA_INTEL is not set
-# CONFIG_SND_HDA_TEGRA is not set
-CONFIG_SND_HDA_PREALLOC_SIZE=64
-CONFIG_SND_SPI=y
-CONFIG_SND_USB=y
-# CONFIG_SND_USB_AUDIO is not set
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_6FIRE is not set
-# CONFIG_SND_USB_HIFACE is not set
-# CONFIG_SND_BCD2000 is not set
-# CONFIG_SND_USB_POD is not set
-# CONFIG_SND_USB_PODHD is not set
-# CONFIG_SND_USB_TONEPORT is not set
-# CONFIG_SND_USB_VARIAX is not set
-CONFIG_SND_SOC=y
-# CONFIG_SND_SOC_AMD_ACP is not set
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-
-#
-# SoC Audio for Freescale CPUs
-#
-
-#
-# Common SoC Audio options for Freescale CPUs:
-#
-# CONFIG_SND_SOC_FSL_ASRC is not set
-# CONFIG_SND_SOC_FSL_SAI is not set
-# CONFIG_SND_SOC_FSL_SSI is not set
-# CONFIG_SND_SOC_FSL_SPDIF is not set
-# CONFIG_SND_SOC_FSL_ESAI is not set
-# CONFIG_SND_SOC_IMX_AUDMUX is not set
-# CONFIG_SND_KIRKWOOD_SOC is not set
-# CONFIG_SND_SOC_IMG is not set
-# CONFIG_SND_SOC_MT2701 is not set
-# CONFIG_SND_SOC_MT8173 is not set
-# CONFIG_SND_SOC_QCOM is not set
-# CONFIG_SND_SOC_ROCKCHIP is not set
-# CONFIG_SND_SOC_SAMSUNG is not set
-
-#
-# SoC Audio support for SuperH
-#
-# CONFIG_SND_SOC_SH4_FSI is not set
-CONFIG_SND_SOC_RCAR=y
-
-#
-# Allwinner SoC Audio support
-#
-# CONFIG_SND_SUN4I_CODEC is not set
-# CONFIG_SND_SUN4I_I2S is not set
-# CONFIG_SND_SUN4I_SPDIF is not set
-# CONFIG_SND_SOC_TEGRA is not set
-# CONFIG_SND_SOC_XTFPGA_I2S is not set
-CONFIG_SND_SOC_I2C_AND_SPI=y
-
-#
-# CODEC drivers
-#
-# CONFIG_SND_SOC_AC97_CODEC is not set
-# CONFIG_SND_SOC_ADAU1701 is not set
-# CONFIG_SND_SOC_ADAU7002 is not set
-# CONFIG_SND_SOC_AK4104 is not set
-# CONFIG_SND_SOC_AK4554 is not set
-CONFIG_SND_SOC_AK4613=y
-# CONFIG_SND_SOC_AK4642 is not set
-# CONFIG_SND_SOC_AK5386 is not set
-# CONFIG_SND_SOC_ALC5623 is not set
-# CONFIG_SND_SOC_BT_SCO is not set
-# CONFIG_SND_SOC_CS35L32 is not set
-# CONFIG_SND_SOC_CS35L33 is not set
-# CONFIG_SND_SOC_CS42L51_I2C is not set
-# CONFIG_SND_SOC_CS42L52 is not set
-# CONFIG_SND_SOC_CS42L56 is not set
-# CONFIG_SND_SOC_CS42L73 is not set
-# CONFIG_SND_SOC_CS4265 is not set
-# CONFIG_SND_SOC_CS4270 is not set
-# CONFIG_SND_SOC_CS4271_I2C is not set
-# CONFIG_SND_SOC_CS4271_SPI is not set
-# CONFIG_SND_SOC_CS42XX8_I2C is not set
-# CONFIG_SND_SOC_CS4349 is not set
-# CONFIG_SND_SOC_CS53L30 is not set
-# CONFIG_SND_SOC_ES8328 is not set
-# CONFIG_SND_SOC_GTM601 is not set
-# CONFIG_SND_SOC_INNO_RK3036 is not set
-# CONFIG_SND_SOC_MAX98504 is not set
-# CONFIG_SND_SOC_MAX9860 is not set
-# CONFIG_SND_SOC_PCM1681 is not set
-# CONFIG_SND_SOC_PCM179X_I2C is not set
-# CONFIG_SND_SOC_PCM179X_SPI is not set
-# CONFIG_SND_SOC_PCM3168A_I2C is not set
-# CONFIG_SND_SOC_PCM3168A_SPI is not set
-# CONFIG_SND_SOC_PCM512x_I2C is not set
-# CONFIG_SND_SOC_PCM512x_SPI is not set
-# CONFIG_SND_SOC_RT5616 is not set
-# CONFIG_SND_SOC_RT5631 is not set
-# CONFIG_SND_SOC_RT5677_SPI is not set
-# CONFIG_SND_SOC_SGTL5000 is not set
-# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
-# CONFIG_SND_SOC_SPDIF is not set
-# CONFIG_SND_SOC_SSM2602_SPI is not set
-# CONFIG_SND_SOC_SSM2602_I2C is not set
-# CONFIG_SND_SOC_SSM4567 is not set
-# CONFIG_SND_SOC_STA32X is not set
-# CONFIG_SND_SOC_STA350 is not set
-# CONFIG_SND_SOC_STI_SAS is not set
-# CONFIG_SND_SOC_TAS2552 is not set
-# CONFIG_SND_SOC_TAS5086 is not set
-# CONFIG_SND_SOC_TAS571X is not set
-# CONFIG_SND_SOC_TAS5720 is not set
-# CONFIG_SND_SOC_TFA9879 is not set
-# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
-# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
-# CONFIG_SND_SOC_TLV320AIC31XX is not set
-# CONFIG_SND_SOC_TLV320AIC3X is not set
-# CONFIG_SND_SOC_TS3A227E is not set
-# CONFIG_SND_SOC_WM8510 is not set
-# CONFIG_SND_SOC_WM8523 is not set
-# CONFIG_SND_SOC_WM8580 is not set
-# CONFIG_SND_SOC_WM8711 is not set
-# CONFIG_SND_SOC_WM8728 is not set
-# CONFIG_SND_SOC_WM8731 is not set
-# CONFIG_SND_SOC_WM8737 is not set
-# CONFIG_SND_SOC_WM8741 is not set
-# CONFIG_SND_SOC_WM8750 is not set
-# CONFIG_SND_SOC_WM8753 is not set
-# CONFIG_SND_SOC_WM8770 is not set
-# CONFIG_SND_SOC_WM8776 is not set
-# CONFIG_SND_SOC_WM8804_I2C is not set
-# CONFIG_SND_SOC_WM8804_SPI is not set
-# CONFIG_SND_SOC_WM8903 is not set
-# CONFIG_SND_SOC_WM8960 is not set
-# CONFIG_SND_SOC_WM8962 is not set
-# CONFIG_SND_SOC_WM8974 is not set
-# CONFIG_SND_SOC_WM8978 is not set
-# CONFIG_SND_SOC_WM8985 is not set
-# CONFIG_SND_SOC_NAU8810 is not set
-# CONFIG_SND_SOC_TPA6130A2 is not set
-CONFIG_SND_SIMPLE_CARD_UTILS=y
-CONFIG_SND_SIMPLE_CARD=y
-# CONFIG_SND_SIMPLE_SCU_CARD is not set
-# CONFIG_SOUND_PRIME is not set
-
-#
-# HID support
-#
-CONFIG_HID=y
-# CONFIG_HID_BATTERY_STRENGTH is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_UHID is not set
-CONFIG_HID_GENERIC=y
-
-#
-# Special HID drivers
-#
-CONFIG_HID_A4TECH=y
-# CONFIG_HID_ACRUX is not set
-CONFIG_HID_APPLE=y
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_AUREAL is not set
-CONFIG_HID_BELKIN=y
-# CONFIG_HID_BETOP_FF is not set
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-# CONFIG_HID_CORSAIR is not set
-# CONFIG_HID_PRODIKEYS is not set
-# CONFIG_HID_CMEDIA is not set
-# CONFIG_HID_CP2112 is not set
-CONFIG_HID_CYPRESS=y
-# CONFIG_HID_DRAGONRISE is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_ELECOM is not set
-# CONFIG_HID_ELO is not set
-CONFIG_HID_EZKEY=y
-# CONFIG_HID_GEMBIRD is not set
-# CONFIG_HID_GFRM is not set
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_GT683R is not set
-# CONFIG_HID_KEYTOUCH is not set
-# CONFIG_HID_KYE is not set
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_WALTOP is not set
-# CONFIG_HID_GYRATION is not set
-# CONFIG_HID_ICADE is not set
-# CONFIG_HID_TWINHAN is not set
-CONFIG_HID_KENSINGTON=y
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LED is not set
-# CONFIG_HID_LENOVO is not set
-CONFIG_HID_LOGITECH=y
-# CONFIG_HID_LOGITECH_HIDPP is not set
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-# CONFIG_HID_MAGICMOUSE is not set
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-# CONFIG_HID_PANTHERLORD is not set
-# CONFIG_HID_PENMOUNT is not set
-# CONFIG_HID_PETALYNX is not set
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PLANTRONICS is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_SAITEK is not set
-# CONFIG_HID_SAMSUNG is not set
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEELSERIES is not set
-# CONFIG_HID_SUNPLUS is not set
-# CONFIG_HID_RMI is not set
-# CONFIG_HID_GREENASIA is not set
-# CONFIG_HID_SMARTJOYPLUS is not set
-# CONFIG_HID_TIVO is not set
-# CONFIG_HID_TOPSEED is not set
-# CONFIG_HID_THINGM is not set
-# CONFIG_HID_THRUSTMASTER is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WIIMOTE is not set
-# CONFIG_HID_XINMO is not set
-# CONFIG_HID_ZEROPLUS is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HID_SENSOR_HUB is not set
-# CONFIG_HID_ALPS is not set
-
-#
-# USB HID support
-#
-CONFIG_USB_HID=y
-# CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
-
-#
-# I2C HID support
-#
-# CONFIG_I2C_HID is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_COMMON=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB=y
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-
-#
-# Miscellaneous USB options
-#
-CONFIG_USB_DEFAULT_PERSIST=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-CONFIG_USB_OTG=y
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_OTG_FSM is not set
-# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_WUSB_CBAF is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_PCI=y
-# CONFIG_USB_XHCI_PLATFORM is not set
-# CONFIG_USB_XHCI_MTK is not set
-# CONFIG_USB_XHCI_MVEBU is not set
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_EHCI_TT_NEWSCHED=y
-CONFIG_USB_EHCI_PCI=y
-CONFIG_USB_EHCI_MSM=y
-# CONFIG_USB_EHCI_TEGRA is not set
-# CONFIG_USB_EHCI_EXYNOS is not set
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_FOTG210_HCD is not set
-# CONFIG_USB_MAX3421_HCD is not set
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_HCD_PCI=y
-# CONFIG_USB_OHCI_EXYNOS is not set
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-# CONFIG_USB_UHCI_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_HCD_TEST_MODE is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_TMC is not set
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
-#
-
-#
-# also be needed; see USB_STORAGE Help for more info
-#
-CONFIG_USB_STORAGE=y
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_UAS is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USBIP_CORE is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_DWC3 is not set
-CONFIG_USB_DWC2=y
-# CONFIG_USB_DWC2_HOST is not set
-
-#
-# Gadget/Dual-role mode requires USB Gadget support to be enabled
-#
-# CONFIG_USB_DWC2_PERIPHERAL is not set
-CONFIG_USB_DWC2_DUAL_ROLE=y
-# CONFIG_USB_DWC2_PCI is not set
-# CONFIG_USB_DWC2_DEBUG is not set
-# CONFIG_USB_DWC2_TRACK_MISSED_SOFS is not set
-CONFIG_USB_CHIPIDEA=y
-CONFIG_USB_CHIPIDEA_OF=y
-CONFIG_USB_CHIPIDEA_UDC=y
-CONFIG_USB_CHIPIDEA_HOST=y
-CONFIG_USB_ISP1760=y
-CONFIG_USB_ISP1760_HCD=y
-CONFIG_USB_ISP1761_UDC=y
-# CONFIG_USB_ISP1760_HOST_ROLE is not set
-# CONFIG_USB_ISP1760_GADGET_ROLE is not set
-CONFIG_USB_ISP1760_DUAL_ROLE=y
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_EHSET_TEST_FIXTURE is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-CONFIG_USB_HSIC_USB3503=y
-# CONFIG_USB_HSIC_USB4604 is not set
-# CONFIG_USB_LINK_LAYER_TEST is not set
-# CONFIG_UCSI is not set
-
-#
-# USB Physical Layer drivers
-#
-CONFIG_USB_PHY=y
-# CONFIG_NOP_USB_XCEIV is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_ISP1301 is not set
-CONFIG_USB_MSM_OTG=y
-# CONFIG_USB_QCOM_8X16_PHY is not set
-CONFIG_USB_ULPI=y
-CONFIG_USB_ULPI_VIEWPORT=y
-CONFIG_USB_GADGET=y
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_VBUS_DRAW=2
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-
-#
-# USB Peripheral Controller
-#
-# CONFIG_USB_FOTG210_UDC is not set
-# CONFIG_USB_GR_UDC is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_RENESAS_USB3 is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_BDC_UDC is not set
-# CONFIG_USB_AMD5536UDC is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_NET2280 is not set
-# CONFIG_USB_GOKU is not set
-# CONFIG_USB_EG20T is not set
-# CONFIG_USB_GADGET_XILINX is not set
-# CONFIG_USB_DUMMY_HCD is not set
-# CONFIG_USB_CONFIGFS is not set
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_AUDIO is not set
-# CONFIG_USB_ETH is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_G_PRINTER is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_DBGP is not set
-# CONFIG_USB_LED_TRIG is not set
-# CONFIG_USB_ULPI_BUS is not set
-# CONFIG_UWB is not set
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_PWRSEQ_EMMC=y
-CONFIG_PWRSEQ_SIMPLE=y
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_BLOCK_BOUNCE=y
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-CONFIG_MMC_ARMMMCI=y
-CONFIG_MMC_QCOM_DML=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_IO_ACCESSORS=y
-# CONFIG_MMC_SDHCI_PCI is not set
-# CONFIG_MMC_SDHCI_ACPI is not set
-CONFIG_MMC_SDHCI_PLTFM=y
-# CONFIG_MMC_SDHCI_OF_ARASAN is not set
-# CONFIG_MMC_SDHCI_OF_AT91 is not set
-CONFIG_MMC_SDHCI_OF_ESDHC=y
-CONFIG_MMC_SDHCI_TEGRA=y
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDHCI_F_SDH30 is not set
-CONFIG_MMC_SDHCI_IPROC=y
-CONFIG_MMC_SDHCI_MSM=y
-# CONFIG_MMC_TIFM_SD is not set
-CONFIG_MMC_SPI=y
-# CONFIG_MMC_SDHI is not set
-# CONFIG_MMC_CB710 is not set
-# CONFIG_MMC_VIA_SDMMC is not set
-CONFIG_MMC_DW=y
-CONFIG_MMC_DW_PLTFM=y
-CONFIG_MMC_DW_EXYNOS=y
-CONFIG_MMC_DW_K3=y
-# CONFIG_MMC_DW_PCI is not set
-# CONFIG_MMC_DW_ROCKCHIP is not set
-# CONFIG_MMC_SH_MMCIF is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MMC_USDHI6ROL0 is not set
-CONFIG_MMC_SUNXI=y
-# CONFIG_MMC_TOSHIBA_PCI is not set
-# CONFIG_MMC_MTK is not set
-# CONFIG_MEMSTICK is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-# CONFIG_LEDS_CLASS_FLASH is not set
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_BCM6328 is not set
-# CONFIG_LEDS_BCM6358 is not set
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_PCA9532 is not set
-CONFIG_LEDS_GPIO=y
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP3952 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_LP8501 is not set
-# CONFIG_LEDS_LP8860 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA963X is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_REGULATOR is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_TLC591XX is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_IS31FL319X is not set
-# CONFIG_LEDS_IS31FL32XX is not set
-
-#
-# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
-#
-# CONFIG_LEDS_BLINKM is not set
-CONFIG_LEDS_SYSCON=y
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-# CONFIG_LEDS_TRIGGER_TIMER is not set
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-# CONFIG_LEDS_TRIGGER_DISK is not set
-# CONFIG_LEDS_TRIGGER_MTD is not set
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-CONFIG_LEDS_TRIGGER_CPU=y
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-
-#
-# iptables trigger is under Netfilter config (LED target)
-#
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-# CONFIG_LEDS_TRIGGER_PANIC is not set
-# CONFIG_ACCESSIBILITY is not set
-# CONFIG_INFINIBAND is not set
-CONFIG_EDAC_SUPPORT=y
-# CONFIG_EDAC is not set
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-CONFIG_RTC_SYSTOHC=y
-CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_ABB5ZES3 is not set
-# CONFIG_RTC_DRV_ABX80X is not set
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_HYM8563 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF85063 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8010 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_RV8803 is not set
-CONFIG_RTC_DRV_S5M=y
-
-#
-# SPI RTC drivers
-#
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_DS1302 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1343 is not set
-# CONFIG_RTC_DRV_DS1347 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_MAX6916 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-# CONFIG_RTC_DRV_RX6110 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_MCP795 is not set
-CONFIG_RTC_I2C_AND_SPI=y
-
-#
-# SPI and I2C RTC drivers
-#
-CONFIG_RTC_DRV_DS3232=y
-# CONFIG_RTC_DRV_PCF2127 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1685_FAMILY is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-CONFIG_RTC_DRV_EFI=y
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_ZYNQMP is not set
-
-#
-# on-CPU RTC drivers
-#
-CONFIG_HAVE_S3C_RTC=y
-# CONFIG_RTC_DRV_S3C is not set
-# CONFIG_RTC_DRV_PL030 is not set
-CONFIG_RTC_DRV_PL031=y
-CONFIG_RTC_DRV_SUN6I=y
-# CONFIG_RTC_DRV_MV is not set
-# CONFIG_RTC_DRV_ARMADA38X is not set
-# CONFIG_RTC_DRV_PM8XXX is not set
-# CONFIG_RTC_DRV_TEGRA is not set
-# CONFIG_RTC_DRV_SNVS is not set
-CONFIG_RTC_DRV_XGENE=y
-
-#
-# HID Sensor RTC drivers
-#
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-CONFIG_DMADEVICES=y
-# CONFIG_DMADEVICES_DEBUG is not set
-
-#
-# DMA Devices
-#
-CONFIG_DMA_ENGINE=y
-CONFIG_DMA_VIRTUAL_CHANNELS=y
-CONFIG_DMA_ACPI=y
-CONFIG_DMA_OF=y
-# CONFIG_AMBA_PL08X is not set
-# CONFIG_FSL_EDMA is not set
-# CONFIG_INTEL_IDMA64 is not set
-# CONFIG_K3_DMA is not set
-# CONFIG_MV_XOR is not set
-# CONFIG_MV_XOR_V2 is not set
-CONFIG_PL330_DMA=y
-CONFIG_TEGRA20_APB_DMA=y
-# CONFIG_TEGRA210_ADMA is not set
-# CONFIG_XGENE_DMA is not set
-# CONFIG_XILINX_DMA is not set
-# CONFIG_XILINX_ZYNQMP_DMA is not set
-CONFIG_QCOM_BAM_DMA=y
-# CONFIG_QCOM_HIDMA_MGMT is not set
-# CONFIG_QCOM_HIDMA is not set
-# CONFIG_DW_DMAC is not set
-# CONFIG_DW_DMAC_PCI is not set
-CONFIG_RENESAS_DMA=y
-CONFIG_SH_DMAE_BASE=y
-# CONFIG_SH_DMAE is not set
-CONFIG_RCAR_DMAC=y
-# CONFIG_RENESAS_USB_DMAC is not set
-# CONFIG_SUDMAC is not set
-
-#
-# DMA Clients
-#
-# CONFIG_ASYNC_TX_DMA is not set
-# CONFIG_DMATEST is not set
-
-#
-# DMABUF options
-#
-# CONFIG_SYNC_FILE is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_UIO is not set
-CONFIG_VFIO_IOMMU_TYPE1=y
-CONFIG_VFIO_VIRQFD=y
-CONFIG_VFIO=y
-# CONFIG_VFIO_NOIOMMU is not set
-CONFIG_VFIO_PCI=y
-CONFIG_VFIO_PCI_MMAP=y
-CONFIG_VFIO_PCI_INTX=y
-# CONFIG_VFIO_PLATFORM is not set
-CONFIG_IRQ_BYPASS_MANAGER=y
-# CONFIG_VIRT_DRIVERS is not set
-CONFIG_VIRTIO=y
-
-#
-# Virtio drivers
-#
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_PCI_LEGACY=y
-CONFIG_VIRTIO_BALLOON=y
-# CONFIG_VIRTIO_INPUT is not set
-CONFIG_VIRTIO_MMIO=y
-# CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES is not set
-
-#
-# Microsoft Hyper-V guest support
-#
-
-#
-# Xen driver support
-#
-CONFIG_XEN_BALLOON=y
-CONFIG_XEN_SCRUB_PAGES=y
-CONFIG_XEN_DEV_EVTCHN=y
-CONFIG_XEN_BACKEND=y
-CONFIG_XENFS=y
-CONFIG_XEN_COMPAT_XENFS=y
-CONFIG_XEN_SYS_HYPERVISOR=y
-CONFIG_XEN_XENBUS_FRONTEND=y
-CONFIG_XEN_GNTDEV=y
-CONFIG_XEN_GRANT_DEV_ALLOC=y
-CONFIG_SWIOTLB_XEN=y
-CONFIG_XEN_PRIVCMD=y
-CONFIG_XEN_EFI=y
-CONFIG_XEN_AUTO_XLATE=y
-# CONFIG_STAGING is not set
-# CONFIG_GOLDFISH is not set
-# CONFIG_CHROME_PLATFORMS is not set
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_HAVE_CLK_PREPARE=y
-CONFIG_COMMON_CLK=y
-
-#
-# Common Clock Framework
-#
-CONFIG_COMMON_CLK_VERSATILE=y
-CONFIG_CLK_SP810=y
-CONFIG_CLK_VEXPRESS_OSC=y
-CONFIG_COMMON_CLK_SCPI=y
-# CONFIG_COMMON_CLK_SI5351 is not set
-# CONFIG_COMMON_CLK_SI514 is not set
-# CONFIG_COMMON_CLK_SI570 is not set
-# CONFIG_COMMON_CLK_CDCE706 is not set
-# CONFIG_COMMON_CLK_CDCE925 is not set
-CONFIG_COMMON_CLK_CS2000_CP=y
-# CONFIG_COMMON_CLK_S2MPS11 is not set
-CONFIG_CLK_QORIQ=y
-CONFIG_COMMON_CLK_XGENE=y
-# CONFIG_COMMON_CLK_NXP is not set
-# CONFIG_COMMON_CLK_PXA is not set
-# CONFIG_COMMON_CLK_PIC32 is not set
-CONFIG_COMMON_CLK_IPROC=y
-CONFIG_CLK_BCM_NS2=y
-CONFIG_COMMON_CLK_HI3519=y
-CONFIG_COMMON_CLK_HI6220=y
-CONFIG_RESET_HISI=y
-# CONFIG_STUB_CLK_HI6220 is not set
-CONFIG_COMMON_CLK_MEDIATEK=y
-CONFIG_COMMON_CLK_MT8135=y
-CONFIG_COMMON_CLK_MT8173=y
-CONFIG_COMMON_CLK_AMLOGIC=y
-CONFIG_COMMON_CLK_GXBB=y
-CONFIG_ARMADA_37XX_CLK=y
-CONFIG_ARMADA_AP806_SYSCON=y
-CONFIG_ARMADA_CP110_SYSCON=y
-CONFIG_QCOM_GDSC=y
-CONFIG_COMMON_CLK_QCOM=y
-# CONFIG_APQ_GCC_8084 is not set
-# CONFIG_APQ_MMCC_8084 is not set
-# CONFIG_IPQ_GCC_4019 is not set
-# CONFIG_IPQ_GCC_806X is not set
-# CONFIG_IPQ_LCC_806X is not set
-# CONFIG_MSM_GCC_8660 is not set
-CONFIG_MSM_GCC_8916=y
-# CONFIG_MSM_GCC_8960 is not set
-# CONFIG_MSM_LCC_8960 is not set
-# CONFIG_MDM_GCC_9615 is not set
-# CONFIG_MDM_LCC_9615 is not set
-# CONFIG_MSM_MMCC_8960 is not set
-# CONFIG_MSM_GCC_8974 is not set
-# CONFIG_MSM_MMCC_8974 is not set
-# CONFIG_MSM_GCC_8996 is not set
-# CONFIG_MSM_MMCC_8996 is not set
-CONFIG_CLK_RENESAS_CPG_MSSR=y
-CONFIG_COMMON_CLK_SAMSUNG=y
-CONFIG_EXYNOS_ARM64_COMMON_CLK=y
-CONFIG_EXYNOS_AUDSS_CLK_CON=y
-CONFIG_SUNXI_CCU=y
-# CONFIG_SUN6I_A31_CCU is not set
-# CONFIG_SUN8I_A23_CCU is not set
-# CONFIG_SUN8I_A33_CCU is not set
-# CONFIG_SUN8I_H3_CCU is not set
-CONFIG_CLK_UNIPHIER=y
-CONFIG_HWSPINLOCK=y
-
-#
-# Hardware Spinlock drivers
-#
-CONFIG_HWSPINLOCK_QCOM=y
-
-#
-# Clock Source drivers
-#
-CONFIG_CLKSRC_OF=y
-CONFIG_CLKSRC_ACPI=y
-CONFIG_CLKSRC_PROBE=y
-CONFIG_CLKSRC_MMIO=y
-CONFIG_ROCKCHIP_TIMER=y
-CONFIG_ARM_ARCH_TIMER=y
-CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
-CONFIG_FSL_ERRATUM_A008585=y
-CONFIG_ARM_TIMER_SP804=y
-# CONFIG_ATMEL_PIT is not set
-CONFIG_MTK_TIMER=y
-# CONFIG_SH_TIMER_CMT is not set
-# CONFIG_SH_TIMER_MTU2 is not set
-# CONFIG_SH_TIMER_TMU is not set
-# CONFIG_EM_TIMER_STI is not set
-CONFIG_CLKSRC_VERSATILE=y
-CONFIG_MAILBOX=y
-CONFIG_ARM_MHU=y
-# CONFIG_PLATFORM_MHU is not set
-# CONFIG_PL320_MBOX is not set
-# CONFIG_ROCKCHIP_MBOX is not set
-# CONFIG_PCC is not set
-# CONFIG_ALTERA_MBOX is not set
-CONFIG_HI6220_MBOX=y
-# CONFIG_MAILBOX_TEST is not set
-# CONFIG_XGENE_SLIMPRO_MBOX is not set
-CONFIG_BCM_PDC_MBOX=y
-CONFIG_IOMMU_API=y
-CONFIG_IOMMU_SUPPORT=y
-
-#
-# Generic IOMMU Pagetable Support
-#
-CONFIG_IOMMU_IO_PGTABLE=y
-CONFIG_IOMMU_IO_PGTABLE_LPAE=y
-# CONFIG_IOMMU_IO_PGTABLE_LPAE_SELFTEST is not set
-# CONFIG_IOMMU_IO_PGTABLE_ARMV7S is not set
-CONFIG_IOMMU_IOVA=y
-CONFIG_OF_IOMMU=y
-CONFIG_IOMMU_DMA=y
-# CONFIG_EXYNOS_IOMMU is not set
-CONFIG_ARM_SMMU=y
-# CONFIG_ARM_SMMU_V3 is not set
-# CONFIG_MTK_IOMMU is not set
-
-#
-# Remoteproc drivers
-#
-# CONFIG_STE_MODEM_RPROC is not set
-# CONFIG_QCOM_Q6V5_PIL is not set
-# CONFIG_QCOM_WCNSS_PIL is not set
-
-#
-# Rpmsg drivers
-#
-
-#
-# SOC (System On Chip) specific Drivers
-#
-
-#
-# Broadcom SoC drivers
-#
-CONFIG_MTK_INFRACFG=y
-# CONFIG_MTK_PMIC_WRAP is not set
-CONFIG_MTK_SCPSYS=y
-# CONFIG_QCOM_GSBI is not set
-CONFIG_QCOM_SMEM=y
-CONFIG_QCOM_SMD=y
-CONFIG_QCOM_SMD_RPM=y
-# CONFIG_QCOM_SMP2P is not set
-# CONFIG_QCOM_SMSM is not set
-# CONFIG_QCOM_WCNSS_CTRL is not set
-# CONFIG_ROCKCHIP_PM_DOMAINS is not set
-CONFIG_SOC_SAMSUNG=y
-CONFIG_SUNXI_SRAM=y
-CONFIG_ARCH_TEGRA_132_SOC=y
-CONFIG_ARCH_TEGRA_210_SOC=y
-# CONFIG_SOC_TI is not set
-# CONFIG_PM_DEVFREQ is not set
-CONFIG_EXTCON=y
-
-#
-# Extcon Device Drivers
-#
-# CONFIG_EXTCON_GPIO is not set
-# CONFIG_EXTCON_MAX3355 is not set
-# CONFIG_EXTCON_QCOM_SPMI_MISC is not set
-# CONFIG_EXTCON_RT8973A is not set
-# CONFIG_EXTCON_SM5502 is not set
-CONFIG_EXTCON_USB_GPIO=y
-# CONFIG_MEMORY is not set
-# CONFIG_IIO is not set
-# CONFIG_NTB is not set
-# CONFIG_VME_BUS is not set
-# CONFIG_PWM is not set
-CONFIG_IRQCHIP=y
-CONFIG_ARM_GIC=y
-CONFIG_ARM_GIC_MAX_NR=1
-CONFIG_ARM_GIC_V2M=y
-CONFIG_ARM_GIC_V3=y
-CONFIG_ARM_GIC_V3_ITS=y
-CONFIG_ALPINE_MSI=y
-CONFIG_DW_APB_ICTL=y
-CONFIG_HISILICON_IRQ_MBIGEN=y
-CONFIG_RENESAS_IRQC=y
-CONFIG_MVEBU_ODMI=y
-CONFIG_MVEBU_PIC=y
-CONFIG_LS_SCFG_MSI=y
-CONFIG_PARTITION_PERCPU=y
-# CONFIG_IPACK_BUS is not set
-CONFIG_ARCH_HAS_RESET_CONTROLLER=y
-CONFIG_RESET_CONTROLLER=y
-# CONFIG_RESET_ATH79 is not set
-CONFIG_RESET_BERLIN=y
-# CONFIG_RESET_LPC18XX is not set
-CONFIG_RESET_MESON=y
-# CONFIG_RESET_PISTACHIO is not set
-# CONFIG_RESET_SOCFPGA is not set
-# CONFIG_RESET_STM32 is not set
-CONFIG_RESET_SUNXI=y
-# CONFIG_TI_SYSCON_RESET is not set
-CONFIG_RESET_UNIPHIER=y
-# CONFIG_RESET_ZYNQ is not set
-CONFIG_COMMON_RESET_HI6220=y
-# CONFIG_FMC is not set
-
-#
-# PHY Subsystem
-#
-CONFIG_GENERIC_PHY=y
-# CONFIG_PHY_BCM_NS_USB2 is not set
-# CONFIG_PHY_BCM_NS_USB3 is not set
-# CONFIG_PHY_BERLIN_USB is not set
-# CONFIG_PHY_BERLIN_SATA is not set
-CONFIG_PHY_EXYNOS_MIPI_VIDEO=y
-# CONFIG_PHY_PXA_28NM_HSIC is not set
-# CONFIG_PHY_PXA_28NM_USB2 is not set
-# CONFIG_PHY_RCAR_GEN2 is not set
-CONFIG_PHY_RCAR_GEN3_USB2=y
-CONFIG_PHY_EXYNOS_DP_VIDEO=y
-# CONFIG_BCM_KONA_USB2_PHY is not set
-# CONFIG_PHY_MT65XX_USB3 is not set
-CONFIG_PHY_HI6220_USB=y
-# CONFIG_PHY_SUN4I_USB is not set
-# CONFIG_PHY_SUN9I_USB is not set
-CONFIG_PHY_SAMSUNG_USB2=y
-# CONFIG_PHY_EXYNOS4210_USB2 is not set
-# CONFIG_PHY_EXYNOS4X12_USB2 is not set
-# CONFIG_PHY_EXYNOS5250_USB2 is not set
-# CONFIG_PHY_QCOM_APQ8064_SATA is not set
-# CONFIG_PHY_QCOM_IPQ806X_SATA is not set
-# CONFIG_PHY_ROCKCHIP_USB is not set
-# CONFIG_PHY_ROCKCHIP_INNO_USB2 is not set
-# CONFIG_PHY_ROCKCHIP_EMMC is not set
-# CONFIG_PHY_ROCKCHIP_DP is not set
-# CONFIG_PHY_ROCKCHIP_PCIE is not set
-# CONFIG_PHY_ROCKCHIP_TYPEC is not set
-CONFIG_PHY_XGENE=y
-# CONFIG_PHY_QCOM_UFS is not set
-CONFIG_PHY_BRCM_SATA=y
-# CONFIG_PHY_TEGRA_XUSB is not set
-CONFIG_PHY_NS2_PCIE=y
-# CONFIG_POWERCAP is not set
-# CONFIG_MCB is not set
-
-#
-# Performance monitor support
-#
-CONFIG_RAS=y
-# CONFIG_THUNDERBOLT is not set
-
-#
-# Android
-#
-# CONFIG_ANDROID is not set
-# CONFIG_LIBNVDIMM is not set
-# CONFIG_DEV_DAX is not set
-# CONFIG_NVMEM is not set
-# CONFIG_STM is not set
-# CONFIG_INTEL_TH is not set
-
-#
-# FPGA Configuration Support
-#
-# CONFIG_FPGA is not set
-
-#
-# Firmware Drivers
-#
-CONFIG_ARM_PSCI_FW=y
-CONFIG_ARM_SCPI_PROTOCOL=y
-CONFIG_ARM_SCPI_POWER_DOMAIN=y
-# CONFIG_FIRMWARE_MEMMAP is not set
-CONFIG_DMIID=y
-# CONFIG_DMI_SYSFS is not set
-# CONFIG_FW_CFG_SYSFS is not set
-CONFIG_HAVE_ARM_SMCCC=y
-
-#
-# EFI (Extensible Firmware Interface) Support
-#
-# CONFIG_EFI_VARS is not set
-CONFIG_EFI_ESRT=y
-CONFIG_EFI_PARAMS_FROM_FDT=y
-CONFIG_EFI_RUNTIME_WRAPPERS=y
-CONFIG_EFI_ARMSTUB=y
-# CONFIG_EFI_CAPSULE_LOADER is not set
-# CONFIG_EFI_TEST is not set
-CONFIG_MESON_SM=y
-CONFIG_ACPI=y
-CONFIG_ACPI_GENERIC_GSI=y
-CONFIG_ACPI_CCA_REQUIRED=y
-# CONFIG_ACPI_DEBUGGER is not set
-CONFIG_ACPI_SPCR_TABLE=y
-# CONFIG_ACPI_EC_DEBUGFS is not set
-CONFIG_ACPI_BUTTON=y
-CONFIG_ACPI_FAN=y
-# CONFIG_ACPI_DOCK is not set
-CONFIG_ACPI_PROCESSOR_IDLE=y
-CONFIG_ACPI_MCFG=y
-CONFIG_ACPI_PROCESSOR=y
-CONFIG_ACPI_HOTPLUG_CPU=y
-CONFIG_ACPI_THERMAL=y
-# CONFIG_ACPI_CUSTOM_DSDT is not set
-CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE=y
-CONFIG_ACPI_TABLE_UPGRADE=y
-# CONFIG_ACPI_DEBUG is not set
-# CONFIG_ACPI_PCI_SLOT is not set
-CONFIG_ACPI_CONTAINER=y
-# CONFIG_ACPI_HED is not set
-# CONFIG_ACPI_CUSTOM_METHOD is not set
-CONFIG_ACPI_REDUCED_HARDWARE_ONLY=y
-# CONFIG_PMIC_OPREGION is not set
-# CONFIG_ACPI_CONFIGFS is not set
-CONFIG_ACPI_IORT=y
-
-#
-# File systems
-#
-CONFIG_DCACHE_WORD_ACCESS=y
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_FS_POSIX_ACL is not set
-# CONFIG_EXT3_FS_SECURITY is not set
-CONFIG_EXT4_FS=y
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-# CONFIG_EXT4_FS_SECURITY is not set
-# CONFIG_EXT4_ENCRYPTION is not set
-# CONFIG_EXT4_DEBUG is not set
-CONFIG_JBD2=y
-# CONFIG_JBD2_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_NILFS2_FS is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_FS_DAX is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_EXPORTFS=y
-# CONFIG_EXPORTFS_BLOCK_OPS is not set
-CONFIG_FILE_LOCKING=y
-CONFIG_MANDATORY_FILE_LOCKING=y
-# CONFIG_FS_ENCRYPTION is not set
-CONFIG_FSNOTIFY=y
-CONFIG_DNOTIFY=y
-CONFIG_INOTIFY_USER=y
-CONFIG_FANOTIFY=y
-CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
-CONFIG_QUOTA=y
-# CONFIG_QUOTA_NETLINK_INTERFACE is not set
-CONFIG_PRINT_QUOTA_WARNING=y
-# CONFIG_QUOTA_DEBUG is not set
-# CONFIG_QFMT_V1 is not set
-# CONFIG_QFMT_V2 is not set
-CONFIG_QUOTACTL=y
-CONFIG_AUTOFS4_FS=y
-CONFIG_FUSE_FS=y
-CONFIG_CUSE=y
-# CONFIG_OVERLAY_FS is not set
-
-#
-# Caches
-#
-# CONFIG_FSCACHE is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_FAT_DEFAULT_UTF8 is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-# CONFIG_PROC_CHILDREN is not set
-CONFIG_KERNFS=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_TMPFS_XATTR is not set
-CONFIG_HUGETLBFS=y
-CONFIG_HUGETLB_PAGE=y
-CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
-CONFIG_CONFIGFS_FS=y
-CONFIG_EFIVAR_FS=y
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ORANGEFS_FS is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_ECRYPT_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
-CONFIG_SQUASHFS=y
-CONFIG_SQUASHFS_FILE_CACHE=y
-# CONFIG_SQUASHFS_FILE_DIRECT is not set
-CONFIG_SQUASHFS_DECOMP_SINGLE=y
-# CONFIG_SQUASHFS_DECOMP_MULTI is not set
-# CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU is not set
-# CONFIG_SQUASHFS_XATTR is not set
-CONFIG_SQUASHFS_ZLIB=y
-# CONFIG_SQUASHFS_LZ4 is not set
-# CONFIG_SQUASHFS_LZO is not set
-# CONFIG_SQUASHFS_XZ is not set
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
-# CONFIG_SQUASHFS_EMBEDDED is not set
-CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_PSTORE is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V2=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-CONFIG_NFS_V4=y
-# CONFIG_NFS_SWAP is not set
-# CONFIG_NFS_V4_1 is not set
-CONFIG_ROOT_NFS=y
-# CONFIG_NFS_USE_LEGACY_DNS is not set
-CONFIG_NFS_USE_KERNEL_DNS=y
-# CONFIG_NFSD is not set
-CONFIG_GRACE_PERIOD=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-CONFIG_SUNRPC_GSS=y
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_9P_FS is not set
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-CONFIG_HAVE_KVM_IRQCHIP=y
-CONFIG_HAVE_KVM_IRQFD=y
-CONFIG_HAVE_KVM_IRQ_ROUTING=y
-CONFIG_HAVE_KVM_EVENTFD=y
-CONFIG_KVM_MMIO=y
-CONFIG_HAVE_KVM_MSI=y
-CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
-CONFIG_KVM_VFIO=y
-CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL=y
-CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
-CONFIG_KVM_COMPAT=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_KVM_ARM_VGIC_V3_ITS=y
-CONFIG_KVM=y
-CONFIG_KVM_ARM_HOST=y
-# CONFIG_VHOST_NET is not set
-# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
-
-#
-# Kernel hacking
-#
-
-#
-# printk and dmesg options
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_DYNAMIC_DEBUG is not set
-
-#
-# Compile-time checks and compiler options
-#
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_INFO_REDUCED is not set
-# CONFIG_DEBUG_INFO_SPLIT is not set
-# CONFIG_DEBUG_INFO_DWARF4 is not set
-# CONFIG_GDB_SCRIPTS is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=2048
-# CONFIG_STRIP_ASM_SYMS is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_PAGE_OWNER is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-CONFIG_SECTION_MISMATCH_WARN_ONLY=y
-CONFIG_ARCH_WANT_FRAME_POINTERS=y
-CONFIG_FRAME_POINTER=y
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
-CONFIG_DEBUG_KERNEL=y
-
-#
-# Memory Debugging
-#
-# CONFIG_PAGE_EXTENSION is not set
-# CONFIG_DEBUG_PAGEALLOC is not set
-# CONFIG_PAGE_POISONING is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_SLUB_DEBUG_ON is not set
-# CONFIG_SLUB_STATS is not set
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_VM is not set
-CONFIG_DEBUG_MEMORY_INIT=y
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-CONFIG_HAVE_ARCH_KASAN=y
-# CONFIG_KASAN is not set
-CONFIG_ARCH_HAS_KCOV=y
-# CONFIG_KCOV is not set
-# CONFIG_DEBUG_SHIRQ is not set
-
-#
-# Debug Lockups and Hangs
-#
-CONFIG_LOCKUP_DETECTOR=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
-# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
-CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
-# CONFIG_WQ_WATCHDOG is not set
-# CONFIG_PANIC_ON_OOPS is not set
-CONFIG_PANIC_ON_OOPS_VALUE=0
-CONFIG_PANIC_TIMEOUT=0
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_SCHED_INFO=y
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_SCHED_STACK_END_CHECK is not set
-# CONFIG_DEBUG_TIMEKEEPING is not set
-# CONFIG_TIMER_STATS is not set
-# CONFIG_DEBUG_PREEMPT is not set
-
-#
-# Lock Debugging (spinlocks, mutexes, etc...)
-#
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_LOCK_TORTURE_TEST is not set
-# CONFIG_STACKTRACE is not set
-# CONFIG_DEBUG_KOBJECT is not set
-CONFIG_HAVE_DEBUG_BUGVERBOSE=y
-CONFIG_DEBUG_BUGVERBOSE=y
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_PI_LIST is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-
-#
-# RCU Debugging
-#
-# CONFIG_PROVE_RCU is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_TORTURE_TEST is not set
-# CONFIG_RCU_PERF_TEST is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=21
-# CONFIG_RCU_TRACE is not set
-# CONFIG_RCU_EQS_DEBUG is not set
-# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_TRACING_SUPPORT=y
-# CONFIG_FTRACE is not set
-
-#
-# Runtime Testing
-#
-# CONFIG_LKDTM is not set
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_RBTREE_TEST is not set
-# CONFIG_INTERVAL_TREE_TEST is not set
-# CONFIG_PERCPU_TEST is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_TEST_HEXDUMP is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_KSTRTOX is not set
-# CONFIG_TEST_PRINTF is not set
-# CONFIG_TEST_BITMAP is not set
-# CONFIG_TEST_UUID is not set
-# CONFIG_TEST_RHASHTABLE is not set
-# CONFIG_TEST_HASH is not set
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_TEST_LKM is not set
-# CONFIG_TEST_USER_COPY is not set
-# CONFIG_TEST_BPF is not set
-# CONFIG_TEST_FIRMWARE is not set
-# CONFIG_TEST_UDELAY is not set
-CONFIG_MEMTEST=y
-# CONFIG_TEST_STATIC_KEYS is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
-# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
-# CONFIG_UBSAN is not set
-CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
-# CONFIG_STRICT_DEVMEM is not set
-# CONFIG_ARM64_PTDUMP is not set
-# CONFIG_PID_IN_CONTEXTIDR is not set
-# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
-CONFIG_DEBUG_SET_MODULE_RONX=y
-# CONFIG_DEBUG_ALIGN_RODATA is not set
-# CONFIG_CORESIGHT is not set
-
-#
-# Security options
-#
-CONFIG_KEYS=y
-# CONFIG_PERSISTENT_KEYRINGS is not set
-# CONFIG_BIG_KEYS is not set
-# CONFIG_ENCRYPTED_KEYS is not set
-# CONFIG_KEY_DH_OPERATIONS is not set
-# CONFIG_SECURITY_DMESG_RESTRICT is not set
-CONFIG_SECURITY=y
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_NETWORK is not set
-# CONFIG_SECURITY_PATH is not set
-CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
-CONFIG_HAVE_ARCH_HARDENED_USERCOPY=y
-# CONFIG_HARDENED_USERCOPY is not set
-# CONFIG_SECURITY_SMACK is not set
-# CONFIG_SECURITY_TOMOYO is not set
-# CONFIG_SECURITY_APPARMOR is not set
-# CONFIG_SECURITY_LOADPIN is not set
-# CONFIG_SECURITY_YAMA is not set
-CONFIG_INTEGRITY=y
-# CONFIG_INTEGRITY_SIGNATURE is not set
-CONFIG_INTEGRITY_AUDIT=y
-# CONFIG_IMA is not set
-# CONFIG_EVM is not set
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_SECURITY=""
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_RNG_DEFAULT=y
-CONFIG_CRYPTO_AKCIPHER2=y
-CONFIG_CRYPTO_KPP2=y
-# CONFIG_CRYPTO_RSA is not set
-# CONFIG_CRYPTO_DH is not set
-# CONFIG_CRYPTO_ECDH is not set
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_USER is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-CONFIG_CRYPTO_GF128MUL=m
-CONFIG_CRYPTO_NULL=y
-CONFIG_CRYPTO_NULL2=y
-# CONFIG_CRYPTO_PCRYPT is not set
-CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_CRYPTO_CRYPTD=y
-# CONFIG_CRYPTO_MCRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-CONFIG_CRYPTO_ABLK_HELPER=y
-
-#
-# Authenticated Encryption with Associated Data
-#
-CONFIG_CRYPTO_CCM=m
-CONFIG_CRYPTO_GCM=m
-# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
-CONFIG_CRYPTO_SEQIV=m
-CONFIG_CRYPTO_ECHAINIV=y
-
-#
-# Block modes
-#
-# CONFIG_CRYPTO_CBC is not set
-CONFIG_CRYPTO_CTR=m
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-# CONFIG_CRYPTO_KEYWRAP is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_CMAC is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_VMAC is not set
-
-#
-# Digest
-#
-CONFIG_CRYPTO_CRC32C=y
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
-CONFIG_CRYPTO_GHASH=m
-# CONFIG_CRYPTO_POLY1305 is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-CONFIG_CRYPTO_SHA256=y
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_SHA3 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=m
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_CHACHA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_842 is not set
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
-
-#
-# Random Number Generation
-#
-CONFIG_CRYPTO_ANSI_CPRNG=y
-CONFIG_CRYPTO_DRBG_MENU=y
-CONFIG_CRYPTO_DRBG_HMAC=y
-# CONFIG_CRYPTO_DRBG_HASH is not set
-# CONFIG_CRYPTO_DRBG_CTR is not set
-CONFIG_CRYPTO_DRBG=y
-CONFIG_CRYPTO_JITTERENTROPY=y
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_USER_API_RNG is not set
-# CONFIG_CRYPTO_USER_API_AEAD is not set
-CONFIG_CRYPTO_HW=y
-# CONFIG_CRYPTO_DEV_MARVELL_CESA is not set
-# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
-# CONFIG_CRYPTO_DEV_S5P is not set
-# CONFIG_CRYPTO_DEV_CCP is not set
-# CONFIG_CRYPTO_DEV_QCE is not set
-# CONFIG_CRYPTO_DEV_ROCKCHIP is not set
-# CONFIG_ASYMMETRIC_KEY_TYPE is not set
-
-#
-# Certificates for signature checking
-#
-CONFIG_ARM64_CRYPTO=y
-CONFIG_CRYPTO_SHA1_ARM64_CE=y
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-CONFIG_CRYPTO_GHASH_ARM64_CE=y
-CONFIG_CRYPTO_AES_ARM64_CE=y
-CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
-CONFIG_CRYPTO_CRC32_ARM64=y
-# CONFIG_BINARY_PRINTF is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_HAVE_ARCH_BITREVERSE=y
-CONFIG_RATIONAL=y
-CONFIG_GENERIC_STRNCPY_FROM_USER=y
-CONFIG_GENERIC_STRNLEN_USER=y
-CONFIG_GENERIC_NET_UTILS=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_IO=y
-CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
-# CONFIG_CRC_CCITT is not set
-CONFIG_CRC16=y
-# CONFIG_CRC_T10DIF is not set
-CONFIG_CRC_ITU_T=y
-CONFIG_CRC32=y
-# CONFIG_CRC32_SELFTEST is not set
-CONFIG_CRC32_SLICEBY8=y
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SARWATE is not set
-# CONFIG_CRC32_BIT is not set
-CONFIG_CRC7=y
-# CONFIG_LIBCRC32C is not set
-# CONFIG_CRC8 is not set
-CONFIG_AUDIT_GENERIC=y
-CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
-CONFIG_AUDIT_COMPAT_GENERIC=y
-# CONFIG_RANDOM32_SELFTEST is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-CONFIG_LZ4_DECOMPRESS=y
-CONFIG_XZ_DEC=y
-CONFIG_XZ_DEC_X86=y
-CONFIG_XZ_DEC_POWERPC=y
-CONFIG_XZ_DEC_IA64=y
-CONFIG_XZ_DEC_ARM=y
-CONFIG_XZ_DEC_ARMTHUMB=y
-CONFIG_XZ_DEC_SPARC=y
-CONFIG_XZ_DEC_BCJ=y
-# CONFIG_XZ_DEC_TEST is not set
-CONFIG_DECOMPRESS_GZIP=y
-CONFIG_DECOMPRESS_BZIP2=y
-CONFIG_DECOMPRESS_LZMA=y
-CONFIG_DECOMPRESS_XZ=y
-CONFIG_DECOMPRESS_LZO=y
-CONFIG_DECOMPRESS_LZ4=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_RADIX_TREE_MULTIORDER=y
-CONFIG_ASSOCIATIVE_ARRAY=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT_MAP=y
-CONFIG_HAS_DMA=y
-CONFIG_CPU_RMAP=y
-CONFIG_DQL=y
-CONFIG_GLOB=y
-# CONFIG_GLOB_SELFTEST is not set
-CONFIG_NLATTR=y
-# CONFIG_CORDIC is not set
-# CONFIG_DDR is not set
-# CONFIG_IRQ_POLL is not set
-CONFIG_LIBFDT=y
-CONFIG_OID_REGISTRY=y
-CONFIG_UCS2_STRING=y
-CONFIG_FONT_SUPPORT=y
-# CONFIG_FONTS is not set
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-# CONFIG_SG_SPLIT is not set
-CONFIG_SG_POOL=y
-CONFIG_ARCH_HAS_SG_CHAIN=y
-CONFIG_SBITMAP=y
diff --git a/arch/arm64/include/asm/esr.h b/arch/arm64/include/asm/esr.h
index ce70c3ff..294b2cc1 100644
--- a/arch/arm64/include/asm/esr.h
+++ b/arch/arm64/include/asm/esr.h
@@ -133,6 +133,7 @@
 #define ESR_ELx_CM_SHIFT	(8)
 #define ESR_ELx_CM 		(UL(1) << ESR_ELx_CM_SHIFT)
 
+
 /* ISS field definitions for exceptions taken in to Hyp */
 #define ESR_ELx_CV		(UL(1) << 24)
 #define ESR_ELx_COND_SHIFT	(20)
diff --git a/arch/arm64/include/asm/hypsec_boot.h b/arch/arm64/include/asm/hypsec_boot.h
index 60e57bd1..7592020d 100644
--- a/arch/arm64/include/asm/hypsec_boot.h
+++ b/arch/arm64/include/asm/hypsec_boot.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_STAGE2_BOOT__
 #define __ARM_STAGE2_BOOT__
 
@@ -9,6 +8,11 @@
 //Hostvisor:0 + 32 VMIDs + 1 COREVISOR
 #define EL2_VM_INFO_SIZE	EL2_MAX_VMID + 1
 
+#ifdef CONFIG_KERNEL_INT
+#define EL2_MAX_MODID		15
+#define EL2_MOD_INFO_SIZE	EL2_MAX_VMID + 1
+#endif 
+
 #define HYPSEC_MAX_VCPUS	4
 #define HYPSEC_MAX_CPUS		16	
 #define HYPSEC_MAX_LOAD_IMG	5
diff --git a/arch/arm64/include/asm/hypsec_constant.h b/arch/arm64/include/asm/hypsec_constant.h
index c62d3a61..b247b574 100644
--- a/arch/arm64/include/asm/hypsec_constant.h
+++ b/arch/arm64/include/asm/hypsec_constant.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef HYPSEC_CONSTANTS_H
 #define HYPSEC_CONSTANTS_H
 
@@ -8,9 +7,12 @@
 
 #define PT_POOL_START 0x10000
 #define PT_POOL_PER_VM STAGE2_VM_POOL_SIZE
-#define MAX_VM_NUM 56 
+#define MAX_VM_NUM 64 
 #define MAX_CTXT_NUM 1024
 #define MAX_LOAD_INFO_NUM 5
+
+#define MAX_MOD_NUM		16
+
 /*
 #define KVM_PHYS_SIZE 4096UL
 #define PAGE_SIZE 4096UL
@@ -49,6 +51,24 @@
 #define HOSTVISOR 0
 #define MAX_SHARE_COUNT 100
 #define UNUSED 0
+
+#ifdef CONFIG_KERNEL_INT
+#define NONE 0
+#define EL1_PGD 1
+#define EL1_PUD 2
+#define EL1_PMD 3
+#define EL1_PTE 4
+#define EL1_INIT 6
+#define EL1_KCODE 7
+#define EL1_DATA 8
+#define EL1_RODATA 9
+#define EL0_PGD 10
+#define EL1_AUTH 11
+#define EL1_MOD_txt 12
+#define EL1_MOD_ro 13
+#endif 
+
+
 //#define READY 1
 //#define VERIFIED 2
 //#define ACTIVE 3
@@ -102,6 +122,17 @@
 #define PSTATE_FAULT_BITS_64 11UL
 
 // Micros
+#define HUGE_PMD_SHIFT      21
+#define HUGE_PMD_SIZE		(_AC(1, UL) << HUGE_PMD_SHIFT)
+#define HUGE_PMD_MASK		(~(HUGE_PMD_SIZE-1))
+#define HUGE_PUD_SHIFT      30
+#define HUGE_PUD_SIZE		(_AC(1, UL) << HUGE_PUD_SHIFT)
+#define HUGE_PUD_MASK		(~(HUGE_PUD_SIZE-1))
+#define PGD_SHIFT           39
+#define PUD_SHIFT           30
+#define PMD_SHIFT           21
+#define PTE_SHIFT           12
+
 
 #define PT_POOL_SIZE (STAGE2_PAGES_SIZE)
 #define phys_page(addr) ((addr) & PHYS_MASK & PAGE_MASK)
@@ -110,7 +141,10 @@
 #define pmd_idx(addr)	pmd_index(addr)
 #define pte_idx(addr)	pte_index(addr)
 #define v_pmd_table(pmd)	(pmd & PMD_TYPE_MASK)
+#define v_pud_table(pud)	(pud & PUD_TYPE_MASK)
 #define writable(pte) (((pte) >> 2UL) & 1UL)
+#define phys_pmd_huge(addr) ((addr) & PHYS_MASK & HUGE_PMD_MASK)
+#define phys_pud_huge(addr) ((addr) & PHYS_MASK & HUGE_PUD_MASK)
 
 #define SMMU_HOST_OFFSET 1000000000UL
 #define PMD_PAGE_NUM	512
diff --git a/arch/arm64/include/asm/hypsec_host.h b/arch/arm64/include/asm/hypsec_host.h
index 59b05796..5c53daaa 100644
--- a/arch/arm64/include/asm/hypsec_host.h
+++ b/arch/arm64/include/asm/hypsec_host.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_STAGE2_H__
 #define __ARM_STAGE2_H__
 #include <linux/memblock.h>
@@ -11,6 +10,10 @@
 #include <asm/kvm_mmu.h>
 #include <asm/hypsec_constant.h>
 
+#ifdef CONFIG_KERNEL_INT
+#include <asm/module.h>
+#endif
+
 /* Handler for ACTLR_EL1 is not defined */
 #define SHADOW_SYS_REGS_SIZE		(DISR_EL1)
 #define SHADOW_32BIT_REGS_SIZE		3
@@ -83,6 +86,41 @@ struct el2_vm_info {
 	unsigned long used_pages;
 };
 
+struct el2_mod_sec
+{
+	/* core */
+	u64 text_base;
+	u64 text_size; 
+	u64	ro_base; 
+	u64 ro_size; 
+	/* init */
+	u64 init_text_base;
+	u64 init_text_size;
+};
+
+struct el2_mod_tabs
+{
+	u64 syms;
+	u32 num_syms;
+	u64 gpl_syms;
+	u32 num_gpl_syms;
+};
+
+struct el2_mod
+{
+	struct el2_mod_sec mod_sec;
+	struct el2_mod_tabs mod_tabs;
+	bool in_use;
+};
+
+struct ksym_tab
+{
+	unsigned long start_ksymtab;
+	unsigned long stop_ksymtab;
+	unsigned long start_ksymtab_gpl;
+	unsigned long stop_ksymtab_gpl;
+};
+
 struct el2_data {
 	struct memblock_region regions[32];
 	struct s2_memblock_info s2_memblock_info[32];
@@ -104,6 +142,10 @@ struct el2_data {
 	arch_spinlock_t smmu_lock;
 	arch_spinlock_t spt_lock;
 
+#ifdef CONFIG_KERNEL_INT
+	arch_spinlock_t host_kpt_lock; 
+#endif
+
 	kvm_pfn_t ram_start_pfn;
 	struct s2_page s2_pages[S2_PFN_SIZE];
 
@@ -140,6 +182,44 @@ struct el2_data {
 
 	u64 phys_mem_start;
 	u64 phys_mem_size;
+
+	u64 host_ttbr1;
+	u64 host_tcr_flag;
+
+	/* host reserved empty 4KB page */
+	u64 host_zero_page;
+
+	u64 host_s1_mem_base;
+	u64 host_s1_mem_size;
+
+	u64 host_s1_pgtable_mem_base;
+	u64 host_s1_pgtable_mem_size;
+
+	u64 host_s1_module_ro_base;
+	u64 host_s1_module_ro_size;
+
+	u64 host_s1_module_text_base;
+	u64 host_s1_module_text_size;
+
+#ifdef CONFIG_KERNEL_INT
+
+	struct el2_mod mod_info[EL2_MOD_INFO_SIZE];
+	unsigned long next_modid; 
+	unsigned long text;
+	unsigned long etext;
+	unsigned long rodata;
+	unsigned long erodata;
+	unsigned long vdso_start;
+	unsigned long vdso_end;
+	unsigned long init_text_begin; 
+	unsigned long init_text_end; 
+	unsigned long data;
+	unsigned long edata;
+	unsigned long kimage_voff; 
+
+	struct ksym_tab kernel_symtab; 
+#endif
+
 };
 
 void init_el2_data_page(void);
@@ -203,6 +283,13 @@ extern phys_addr_t el2_arm_lpae_iova_to_phys(u64 iova, u32 cbndx, u32 num);
 extern void el2_smmu_clear(u64 iova, u32 cbndx, u32 num);
 extern void hypsec_phys_addr_ioremap(u32 vmid, u64 gpa, u64 pa, u64 size);
 
+extern u32 el2_mod_checksum(u64 p_hdr, u64 mod_percpu, u64 mod_arch, u64 checklists, u32 entsize);
+extern u32 hyp_free_module(u32 mod_id);
+extern u32 hyp_unload_init_mod(u32 mod_id);
+extern void hyp_alloc_el0_pgd(u64 addr);
+extern void hyp_free_el0_pgd(u64 addr);
+
+
 extern void el2_boot_from_inc_exe(u32 vmid);
 extern bool el2_use_inc_exe(u32 vmid);
 
@@ -371,7 +458,9 @@ void init_hacl_hash(struct el2_data *el2_data);
 uint64_t get_hacl_hash_sha2_constant_k384_512(int i);
 uint32_t get_hacl_hash_sha2_constant_k224_256(int i);
 
-static u64 inline get_pt_vttbr(u32 vmid)
+static u64 inline 
+
+get_pt_vttbr(u32 vmid)
 {
 	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
 	if (vmid < COREVISOR) {
@@ -385,4 +474,6 @@ static void inline set_pt_vttbr(u32 vmid, u64 vttbr) {
 	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
 	el2_data->vm_info[vmid].vttbr = vttbr;
 };
+
+
 #endif /* __ARM_STAGE2_H__ */
diff --git a/arch/arm64/include/asm/hypsec_missing.h b/arch/arm64/include/asm/hypsec_missing.h
index e338f89b..0041a54e 100644
--- a/arch/arm64/include/asm/hypsec_missing.h
+++ b/arch/arm64/include/asm/hypsec_missing.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 struct kvm* __hyp_text hypsec_vmid_to_kvm(u32 vmid);
 struct kvm_vcpu* __hyp_text hypsec_vcpu_id_to_vcpu(u32 vmid, int vcpu_id);
 struct shadow_vcpu_context* __hyp_text hypsec_vcpu_id_to_shadow_ctxt(u32 vmid, int vcpu_id);
diff --git a/arch/arm64/include/asm/hypsec_mmio.h b/arch/arm64/include/asm/hypsec_mmio.h
index 006025f2..48189d85 100644
--- a/arch/arm64/include/asm/hypsec_mmio.h
+++ b/arch/arm64/include/asm/hypsec_mmio.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_STAGE2_MMIO__
 #define __ARM_STAGE2_MMIO__
 
diff --git a/arch/arm64/include/asm/hypsec_mmu.h b/arch/arm64/include/asm/hypsec_mmu.h
index 1aa6d2d1..07146c86 100644
--- a/arch/arm64/include/asm/hypsec_mmu.h
+++ b/arch/arm64/include/asm/hypsec_mmu.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_STAGE2_MMU__
 #define __ARM_STAGE2_MMU__
 
@@ -32,6 +31,13 @@ struct s2_page {
 	int count;
 	u32 vmid;
 	u64 gfn;
+#ifdef CONFIG_KERNEL_INT
+	u32 subid;
+	u32 subcount;
+	u32 dynamic; 	
+	u64 kpt_index; 
+	u64 el1_va; 
+#endif
 };
 
 struct s2_memblock_info {
diff --git a/arch/arm64/include/asm/hypsec_vcpu.h b/arch/arm64/include/asm/hypsec_vcpu.h
index 52412f24..77a3d72f 100644
--- a/arch/arm64/include/asm/hypsec_vcpu.h
+++ b/arch/arm64/include/asm/hypsec_vcpu.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_STAGE2_VCPU__
 #define __ARM_STAGE2_VCPU__
 
diff --git a/arch/arm64/include/asm/kernel-pgtable.h b/arch/arm64/include/asm/kernel-pgtable.h
index 5ae0dbc1..9362b21b 100644
--- a/arch/arm64/include/asm/kernel-pgtable.h
+++ b/arch/arm64/include/asm/kernel-pgtable.h
@@ -112,8 +112,17 @@
 #define STAGE2_CORE_PAGES_SIZE 	SZ_2M * 128
 #define STAGE2_PAGES_SIZE      	STAGE2_CORE_PAGES_SIZE + STAGE2_HOST_POOL_SIZE + STAGE2_NORM_PAGES_SIZE
 #define SMMU_PAGES_SIZE  	SZ_2M * 24
+#ifndef CONFIG_KERNEL_INT
 #define STAGE2_TMP_PAGES_SIZE  	0
+#else 
+#define STAGE2_TMP_PAGES_SIZE  SZ_2M * 16
+#endif
+
+#ifdef CONFIG_KERNEL_INT
+#define CORE_DATA_SIZE		PAGE_SIZE * (PAGE_SIZE * 49)
+#else 
 #define CORE_DATA_SIZE		PAGE_SIZE * (PAGE_SIZE * 24)
+#endif
 
 #define STAGE2_NUM_CORE_PAGES  	(STAGE2_CORE_PAGES_SIZE / PAGE_SIZE)
 #define STAGE2_NUM_TMP_PAGES   	(STAGE2_TMP_PAGES_SIZE / PAGE_SIZE)
diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h
index eb30d0eb..ca5559c5 100644
--- a/arch/arm64/include/asm/kvm_arm.h
+++ b/arch/arm64/include/asm/kvm_arm.h
@@ -88,7 +88,11 @@
 #define HCR_VIRT_EXCP_MASK (HCR_VSE | HCR_VI | HCR_VF)
 #define HCR_HOST_VHE_FLAGS (HCR_RW | HCR_TGE | HCR_E2H)
 #ifdef CONFIG_VERIFIED_KVM
+#ifdef CONFIG_KERNEL_INT
+#define HCR_HOST_NVHE_FLAGS (HCR_RW | HCR_AMO | HCR_VM | HCR_TVM)
+#else
 #define HCR_HOST_NVHE_FLAGS (HCR_RW | HCR_AMO | HCR_VM)
+#endif
 #define HCR_HYPSEC_VM_FLAGS (HCR_TSC | HCR_TSW | HCR_TWE | HCR_TWI | HCR_VM | \
 			     HCR_BSU_IS | HCR_FB | HCR_TAC | \
 			     HCR_AMO | HCR_SWIO | HCR_TIDCP | HCR_RW | HCR_TLOR | \
diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h
index 6c6a522a..0db8b18a 100644
--- a/arch/arm64/include/asm/kvm_asm.h
+++ b/arch/arm64/include/asm/kvm_asm.h
@@ -53,6 +53,7 @@ extern char __kvm_hyp_init[];
 extern char __kvm_hyp_init_end[];
 
 extern char __kvm_hyp_vector[];
+extern char __kvm_vm_vector[];
 
 extern void __kvm_flush_vm_context(void);
 extern void __kvm_tlb_flush_vmid_ipa(struct kvm *kvm, phys_addr_t ipa);
diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h
index a46fd040..6ba971d3 100644
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@ -580,4 +580,12 @@ void kvm_vcpu_put_sysregs(struct kvm_vcpu *vcpu);
 struct kvm *kvm_arch_alloc_vm(void);
 void kvm_arch_free_vm(struct kvm *kvm);
 
+#ifdef CONFIG_VERIFIED_KVM
+void __init early_sekvm_hyp_reserve(void);
+void __init sekvm_divide_reserve_mem(void);
+#else
+static inline void early_sekvm_hyp_reserve(void) { }
+static inline void sekvm_divide_reserve_mem(void) { }
+#endif
+
 #endif /* __ARM64_KVM_HOST_H__ */
diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h
index 6fa70d0e..a6b6041a 100644
--- a/arch/arm64/include/asm/kvm_mmu.h
+++ b/arch/arm64/include/asm/kvm_mmu.h
@@ -471,6 +471,12 @@ static inline int kvm_map_vectors(void)
 
 	return 0;
 }
+
+static inline void *kvm_get_vm_vector(void)
+{
+	return kern_hyp_va(kvm_ksym_ref(__kvm_vm_vector));
+}
+
 #else
 static inline void *kvm_get_hyp_vector(void)
 {
diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h
index 49d99214..6fc1b662 100644
--- a/arch/arm64/include/asm/memory.h
+++ b/arch/arm64/include/asm/memory.h
@@ -56,7 +56,7 @@
  * VA_BITS - the maximum number of bits for virtual addresses.
  * VA_START - the first kernel virtual address.
  */
-#define VA_BITS			(CONFIG_ARM64_VA_BITS)
+#define VA_BITS			(CONFIG_ARM64_VA_BITS) // 48 
 #define VA_START		(UL(0xffffffffffffffff) - \
 	(UL(1) << VA_BITS) + 1)
 #define PAGE_OFFSET		(UL(0xffffffffffffffff) - \
diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index 39ec0b8a..c570f569 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -55,9 +55,17 @@ static inline void cpu_set_reserved_ttbr0(void)
 	isb();
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+extern bool sekvm_installed;
+u32 hyp_do_switch_mm(pgd_t *pgd, struct mm_struct *mm);
+#endif
 static inline void cpu_switch_mm(pgd_t *pgd, struct mm_struct *mm)
 {
 	BUG_ON(pgd == swapper_pg_dir);
+#ifdef CONFIG_VERIFIED_KVM
+	if (sekvm_installed && hyp_do_switch_mm(pgd, mm))
+		return;
+#endif
 	cpu_set_reserved_ttbr0();
 	cpu_do_switch_mm(virt_to_phys(pgd),mm);
 }
diff --git a/arch/arm64/include/asm/module.h b/arch/arm64/include/asm/module.h
index 97d0ef12..ecaceeba 100644
--- a/arch/arm64/include/asm/module.h
+++ b/arch/arm64/include/asm/module.h
@@ -33,6 +33,9 @@ struct mod_arch_specific {
 
 	/* for CONFIG_DYNAMIC_FTRACE */
 	struct plt_entry 	*ftrace_trampoline;
+#ifdef CONFIG_KERNEL_INT
+	u32 kint_modid;
+#endif
 };
 #endif
 
diff --git a/arch/arm64/include/asm/pgalloc.h b/arch/arm64/include/asm/pgalloc.h
index 2e05bcd9..fa1617df 100644
--- a/arch/arm64/include/asm/pgalloc.h
+++ b/arch/arm64/include/asm/pgalloc.h
@@ -29,16 +29,29 @@
 #define PGALLOC_GFP	(GFP_KERNEL | __GFP_ZERO)
 #define PGD_SIZE	(PTRS_PER_PGD * sizeof(pgd_t))
 
+extern void *host_alloc_pt_pages(unsigned short order);
+extern void host_free_pt_pages(unsigned long addr);
+
 #if CONFIG_PGTABLE_LEVELS > 2
 
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
+#ifdef CONFIG_VERIFIED_KVM
+	if (addr >= TASK_SIZE)
+		return (pmd_t *)host_alloc_pt_pages(0);
+#endif
 	return (pmd_t *)__get_free_page(PGALLOC_GFP);
 }
 
 static inline void pmd_free(struct mm_struct *mm, pmd_t *pmdp)
 {
 	BUG_ON((unsigned long)pmdp & (PAGE_SIZE-1));
+#ifdef CONFIG_VERIFIED_KVM
+	if (mm == &init_mm) {
+			host_free_pt_pages((unsigned long)pmdp);
+			return;
+	}
+#endif
 	free_page((unsigned long)pmdp);
 }
 
@@ -62,12 +75,22 @@ static inline void __pud_populate(pud_t *pudp, phys_addr_t pmdp, pudval_t prot)
 
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
+#ifdef CONFIG_VERIFIED_KVM
+	if (addr >= TASK_SIZE)
+		return (pud_t *)host_alloc_pt_pages(0);
+#endif
 	return (pud_t *)__get_free_page(PGALLOC_GFP);
 }
 
 static inline void pud_free(struct mm_struct *mm, pud_t *pudp)
 {
 	BUG_ON((unsigned long)pudp & (PAGE_SIZE-1));
+#ifdef CONFIG_VERIFIED_KVM
+	if (mm == &init_mm) {
+			host_free_pt_pages((unsigned long)pudp);
+			return;
+	}
+#endif
 	free_page((unsigned long)pudp);
 }
 
@@ -93,7 +116,12 @@ extern void pgd_free(struct mm_struct *mm, pgd_t *pgdp);
 static inline pte_t *
 pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr)
 {
+
+#ifdef CONFIG_VERIFIED_KVM
+	return (pte_t *)host_alloc_pt_pages(0);
+#else
 	return (pte_t *)__get_free_page(PGALLOC_GFP);
+#endif
 }
 
 static inline pgtable_t
@@ -117,7 +145,11 @@ pte_alloc_one(struct mm_struct *mm, unsigned long addr)
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *ptep)
 {
 	if (ptep)
+#ifdef CONFIG_VERIFIED_KVM
+		host_free_pt_pages((unsigned long)ptep);
+#else
 		free_page((unsigned long)ptep);
+#endif
 }
 
 static inline void pte_free(struct mm_struct *mm, pgtable_t pte)
diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h
index 4f2fe99c..1aee6f58 100644
--- a/arch/arm64/include/asm/pgtable-hwdef.h
+++ b/arch/arm64/include/asm/pgtable-hwdef.h
@@ -121,6 +121,7 @@
 #define PUD_TABLE_BIT		(_AT(pudval_t, 1) << 1)
 #define PUD_TYPE_MASK		(_AT(pudval_t, 3) << 0)
 #define PUD_TYPE_SECT		(_AT(pudval_t, 1) << 0)
+#define PUD_MARK			(_AT(pudval_t, 1) << 58)
 
 /*
  * Level 2 descriptor (PMD).
@@ -195,6 +196,11 @@
 #define PMD_S2_RDWR		(_AT(pmdval_t, 3) << 6)   /* HAP[2:1] */
 #define PMD_S2_XN		(_AT(pmdval_t, 2) << 53)  /* XN[1:0] */
 
+#ifdef CONFIG_KERNEL_INT
+#define PTE_S2_EL1_XN   (_AT(pteval_t, 1) << 53)
+#define PTE_S2_EL0_XN   (_AT(pteval_t, 0) << 53)
+#endif
+
 #ifdef CONFIG_VERIFIED_KVM
 #define PTE_S2_GUEST		(_AT(pteval_t, 1) << 57)
 #endif
@@ -226,6 +232,7 @@
 #define TCR_TxSZ(x)		(TCR_T0SZ(x) | TCR_T1SZ(x))
 #define TCR_TxSZ_WIDTH		6
 #define TCR_T0SZ_MASK		(((UL(1) << TCR_TxSZ_WIDTH) - 1) << TCR_T0SZ_OFFSET)
+#define TCR_T1SZ_MASK		(((UL(1) << TCR_TxSZ_WIDTH) - 1) << TCR_T1SZ_OFFSET)
 
 #define TCR_IRGN0_SHIFT		8
 #define TCR_IRGN0_MASK		(UL(3) << TCR_IRGN0_SHIFT)
diff --git a/arch/arm64/include/asm/pgtable-prot.h b/arch/arm64/include/asm/pgtable-prot.h
index 5d221620..7e86261b 100644
--- a/arch/arm64/include/asm/pgtable-prot.h
+++ b/arch/arm64/include/asm/pgtable-prot.h
@@ -68,8 +68,14 @@
 #define PAGE_HYP_DEVICE		__pgprot(PROT_DEVICE_nGnRE | PTE_HYP)
 
 #ifdef CONFIG_VERIFIED_KVM
-#define PAGE_S2			__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY)
-#define PAGE_S2_KERNEL		__pgprot(PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDWR)
+#define PAGE_S2			__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY | PTE_S2_XN)
+#define SECT_S2			__pgprot(_PROT_SECT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY | PTE_S2_XN)
+#define PAGE_S2P			__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDWR | PTE_S2_XN)
+#define SECT_S2P			__pgprot(_PROT_SECT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDWR | PTE_S2_XN)
+#define PAGE_S2_KERNEL		__pgprot(PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDWR | PTE_S2_EL1_XN)
+#define SECT_S2_KERNEL		__pgprot(PROT_SECT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDWR | PTE_S2_EL1_XN)
+#define PAGE_S2_KCODE   __pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY | PTE_S2_EL0_XN )
+#define SECT_S2_KCODE   __pgprot(_PROT_SECT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY | PTE_S2_EL0_XN )
 #else
 #define PAGE_S2			__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY | PTE_S2_XN)
 #endif
diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h
index 1bdeca89..2be3ecda 100644
--- a/arch/arm64/include/asm/pgtable.h
+++ b/arch/arm64/include/asm/pgtable.h
@@ -217,7 +217,7 @@ static inline pmd_t pmd_mkcont(pmd_t pmd)
 }
 
 static inline void set_pte(pte_t *ptep, pte_t pte)
-{
+{	
 	WRITE_ONCE(*ptep, pte);
 
 	/*
diff --git a/arch/arm64/include/asm/virt.h b/arch/arm64/include/asm/virt.h
index 4421c7c1..7bc93e1a 100644
--- a/arch/arm64/include/asm/virt.h
+++ b/arch/arm64/include/asm/virt.h
@@ -76,6 +76,17 @@
 #define HVC_SMMU_LPAE_IOVA_TO_PHYS 26
 #define HVC_SMMU_CLEAR 27
 #define	HVC_PHYS_ADDR_IOREMAP 28
+
+#ifdef CONFIG_KERNEL_INT
+/* Instruction */
+#define HVC_MLOAD 30
+#define HVC_MFREE 31
+#define HVC_MOD_INIT_FREE 32
+#define HVC_ALLOC_EL0_PGD 33
+#define HVC_FREE_EL0_PGD 34
+#endif
+#define HVC_DO_SWITCH_MM 35
+
 #endif
 
 /* Error returned when an invalid stub number is passed into x0 */
@@ -110,7 +121,7 @@ void enable_stage2_translation(phys_addr_t vttbr_base);
 #endif
 
 /* Reports the availability of HYP mode */
-static inline bool is_hyp_mode_available(void)
+static inline bool is_hyp_mode_available(void) 
 {
 	return (__boot_cpu_mode[0] == BOOT_CPU_MODE_EL2 &&
 		__boot_cpu_mode[1] == BOOT_CPU_MODE_EL2);
diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
index 28ad8799..ca70c33b 100644
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -363,7 +363,15 @@ alternative_else_nop_endif
 alternative_insn eret, nop, ARM64_UNMAP_KERNEL_AT_EL0
 #ifdef CONFIG_UNMAP_KERNEL_AT_EL0
 	bne	4f
-	msr	far_el1, x30
+#ifdef CONFIG_VERIFIED_KVM
+	/*
+	 * We use tpidrro_el0 instead of far_el1
+	 * as scratch register since TVM bit is enabled.
+	 */
+	msr	tpidrro_el0, x30
+#else
+	msr far_el1, x30
+#endif
 	tramp_alias	x30, tramp_exit_native
 	br	x30
 4:
@@ -1097,7 +1105,12 @@ alternative_insn isb, nop, ARM64_WORKAROUND_QCOM_FALKOR_E1003
 	msr	vbar_el1, x30
 	tramp_unmap_kernel	x30
 	.if	\regsize == 64
+#ifdef CONFIG_VERIFIED_KVM
+	mrs x30, tpidrro_el0
+	msr tpidrro_el0, xzr
+#else
 	mrs	x30, far_el1
+#endif
 	.endif
 	eret
 	.endm
diff --git a/arch/arm64/kernel/insn.c b/arch/arm64/kernel/insn.c
index 816d03c4..740711ac 100644
--- a/arch/arm64/kernel/insn.c
+++ b/arch/arm64/kernel/insn.c
@@ -397,7 +397,6 @@ u32 __kprobes aarch64_insn_encode_immediate(enum aarch64_insn_imm_type type,
 
 	if (insn == AARCH64_BREAK_FAULT)
 		return AARCH64_BREAK_FAULT;
-
 	switch (type) {
 	case AARCH64_INSN_IMM_ADR:
 		shift = 0;
diff --git a/arch/arm64/kernel/module.c b/arch/arm64/kernel/module.c
index f0f27aee..9dbe3b6e 100644
--- a/arch/arm64/kernel/module.c
+++ b/arch/arm64/kernel/module.c
@@ -68,6 +68,27 @@ void *module_alloc(unsigned long size)
 	return p;
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+void *sekvm_module_alloc(unsigned long flag, unsigned long size)
+{
+	gfp_t gfp_mask = GFP_KERNEL;
+	void *p;
+
+
+	if (flag & VM_SEKVM_TMP)
+		p = __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,
+				gfp_mask | __GFP_NOWARN, PAGE_KERNEL, flag,
+				NUMA_NO_NODE, __builtin_return_address(0));
+	else
+		p = __vmalloc_node_range(size, MODULE_ALIGN, module_alloc_base,
+				module_alloc_base + MODULES_VSIZE,
+				gfp_mask, PAGE_KERNEL_EXEC, flag,
+				NUMA_NO_NODE, __builtin_return_address(0));
+
+	return p;
+}
+#endif
+
 enum aarch64_reloc_op {
 	RELOC_OP_NONE,
 	RELOC_OP_ABS,
@@ -205,9 +226,10 @@ static int reloc_insn_adrp(struct module *mod, __le32 *place, u64 val)
 	if (!IS_ENABLED(CONFIG_ARM64_ERRATUM_843419) ||
 	    !cpus_have_const_cap(ARM64_WORKAROUND_843419) ||
 	    ((u64)place & 0xfff) < 0xff8)
-		return reloc_insn_imm(RELOC_OP_PAGE, place, val, 12, 21,
+			return reloc_insn_imm(RELOC_OP_PAGE, place, val, 12, 21,
 				      AARCH64_INSN_IMM_ADR);
 
+
 	/* patch ADRP to ADR if it is in range */
 	if (!reloc_insn_imm(RELOC_OP_PREL, place, val & ~0xfff, 0, 21,
 			    AARCH64_INSN_IMM_ADR)) {
@@ -431,7 +453,7 @@ int apply_relocate_add(Elf64_Shdr *sechdrs,
 			goto overflow;
 
 	}
-
+	
 	return 0;
 
 overflow:
diff --git a/arch/arm64/kernel/vdso/vdso.S b/arch/arm64/kernel/vdso/vdso.S
index 82379a70..87d58c4b 100644
--- a/arch/arm64/kernel/vdso/vdso.S
+++ b/arch/arm64/kernel/vdso/vdso.S
@@ -22,7 +22,7 @@
 #include <asm/page.h>
 
 	.globl vdso_start, vdso_end
-	.section .rodata
+	.section .data..ro_after_init
 	.balign PAGE_SIZE
 vdso_start:
 	.incbin "arch/arm64/kernel/vdso/vdso.so"
diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
index 01eea5a2..058a558a 100644
--- a/arch/arm64/kernel/vmlinux.lds.S
+++ b/arch/arm64/kernel/vmlinux.lds.S
@@ -68,6 +68,7 @@ jiffies = jiffies_64;
 #define TRAMP_TEXT
 #endif
 
+
 /*
  * The size of the PE/COFF section that covers the kernel image, which
  * runs from stext to _edata, must be a round multiple of the PE/COFF
@@ -130,15 +131,22 @@ SECTIONS
 		. = ALIGN(16);
 		*(.got)			/* Global offset table		*/
 	}
-
+#ifndef CONFIG_VERIFIED_KVM
 	. = ALIGN(SEGMENT_ALIGN);
+#else
+	. = ALIGN(SZ_2M);
+#endif
 	_etext = .;			/* End of text section */
 
 	RO_DATA(PAGE_SIZE)		/* everything from this point to     */
 	EXCEPTION_TABLE(8)		/* __init_begin will be marked RO NX */
 	NOTES
 
+#ifndef CONFIG_VERIFIED_KVM
 	. = ALIGN(SEGMENT_ALIGN);
+#else
+	. = ALIGN(SZ_2M);
+#endif
 	__init_begin = .;
 	__inittext_begin = .;
 
@@ -187,6 +195,7 @@ SECTIONS
 	__initdata_end = .;
 	__init_end = .;
 
+	. = ALIGN(SZ_2M);
 	_data = .;
 	_sdata = .;
 	RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)
@@ -213,12 +222,20 @@ SECTIONS
 	__pecoff_data_rawsize = ABSOLUTE(. - __initdata_begin);
 	_edata = .;
 
+#ifdef CONFIG_VERIFIED_KVM
+	/* Reserved region for Device Tree loaded in m400 machine when booting */
+	. = ALIGN(SEGMENT_ALIGN);
+	dtb_copy_start = .;
+	. += SZ_2M * 4;
+	dtb_copy_end =.;
+#endif
+
 	BSS_SECTION(0, 0, 0)
 
 #ifndef CONFIG_VERIFIED_KVM
 	. = ALIGN(PAGE_SIZE);
 #else
-	. = ALIGN(SEGMENT_ALIGN);
+	. = ALIGN(SZ_2M);
 #endif
 	. = ALIGN(PAGE_SIZE);
 	idmap_pg_dir = .;
@@ -238,9 +255,6 @@ SECTIONS
 	swapper_pg_end = .;
 #ifdef CONFIG_VERIFIED_KVM
 	. = ALIGN(SEGMENT_ALIGN);
-	dtb_copy_start = .;
-	. += SZ_2M * 4;
-	dtb_copy_end =.;
 
 	stage2_pgs_start = .;
 	. += STAGE2_PAGES_SIZE;
@@ -251,7 +265,7 @@ SECTIONS
 	smmu_pgs_end = .;
 
 	stage2_tmp_pgs_start = .;
-	. += PAGE_SIZE;
+	. += STAGE2_TMP_PAGES_SIZE;
 	stage2_tmp_pgs_end = .;
 
 	. = ALIGN(PAGE_SIZE);
@@ -266,6 +280,7 @@ SECTIONS
 #endif
 
 	__pecoff_data_size = ABSOLUTE(. - __initdata_begin);
+	. = ALIGN(SZ_2M);
 	_end = .;
 
 	STABS_DEBUG
diff --git a/arch/arm64/kint/Helper.c b/arch/arm64/kint/Helper.c
new file mode 100644
index 00000000..2eff2201
--- /dev/null
+++ b/arch/arm64/kint/Helper.c
@@ -0,0 +1,97 @@
+#include "kint.h"
+
+void __hyp_text *el2_bsearch(const void *key, const void *base, size_t num, size_t size,
+	      int (*cmp)(const void *key, const void *elt))
+{
+	const char *pivot;
+	int result;
+	u64 cnt = 0;
+
+	while (num > 0) {
+		
+		pivot = base + (num >> 1) * size;
+		result = cmp(key, pivot);
+
+		if (result == 0)
+			return (void *)pivot;
+
+		if (result > 0) {
+			base = pivot + size;
+			num--;
+		}
+		num >>= 1;
+		cnt++; 
+	}
+	return NULL;
+}
+
+u64 __hyp_text el2_strcmp(const char *s1, const char *s2)
+{
+    while(*s2 && (*s1 == *s2))
+    {
+        s1++;
+        s2++;
+    }
+    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
+}
+
+u64 __hyp_text el2_strncmp(const char *s1, const char *s2, u32 n)
+{
+    while(n && *s2 && (*s1 == *s2))
+    {
+        s1++;
+        s2++;
+		n--;
+    }
+	if(n == 0)
+		return 0;
+
+    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
+}
+
+u64 __hyp_text el2_strlen(const char *str)
+{
+        const char *s;
+
+        for (s = str; *s; ++s)
+                ;
+        return (s - str);
+}
+
+char * __hyp_text el2_next_str(char *string, u64 *secsize)
+{
+	/* Skip non-zero chars */
+	while (string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+
+	/* Skip any zero padding. */
+	while (!string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+	return string;
+}
+
+char*  __hyp_text el2_strncpy(char* dest, const char* source, u32 num)
+{	
+    if (dest == NULL) {
+        return NULL;
+    }
+
+    char* ptr = dest;
+
+    while (*source && num--)
+    {
+        *dest = *source;
+        dest++;
+        source++;
+    }
+
+    *dest = '\0';
+ 
+    return ptr;
+}
diff --git a/arch/arm64/kint/HostKpt.c b/arch/arm64/kint/HostKpt.c
new file mode 100644
index 00000000..ce992038
--- /dev/null
+++ b/arch/arm64/kint/HostKpt.c
@@ -0,0 +1,71 @@
+#include "kint.h"
+
+void __hyp_text host_kpt_handler(u64 addr, u32 hsr)
+{	
+	u64 wdata, rdata, inst, pfn, pc_counter;
+	u32 subid, ret;
+
+	pfn = addr / PAGE_SIZE;
+	acquire_lock_s2page();
+
+	subid = get_pfn_subowner(pfn);
+	
+	if (is_kpt(subid))
+	{
+		inst = fetch_instruction(); 
+		wdata = fetch_wdata(hsr, inst);
+		rdata = fetch_rdata(addr); 
+
+		if (wdata == 0)
+		{
+			unmapping_handler(rdata, wdata, inst, addr, hsr);
+		} 
+		else if (rdata == 0 && wdata !=0) 
+		{
+			mapping_handler(wdata, inst, addr, hsr);
+		} 
+		else if (rdata != 0 && wdata != 0) 
+		{
+			update_handler(rdata, wdata, inst, addr, hsr);
+		}
+	}
+	else if (subid >= EL1_MOD_txt && subid <= EL1_MOD_ro)
+	{
+		wdata = fetch_wdata(hsr, inst);
+		rdata = fetch_rdata(addr); 
+		mod_reloc_handler(wdata, rdata, inst, addr, hsr); 
+	}
+	else if (subid == EL0_PGD)
+	{
+		inst = fetch_instruction();
+		wdata = fetch_wdata(hsr, inst);
+		if (wdata)
+			wdata = wdata | DCPTR_EL1_PXN_TABLE_MASK;
+		ret = handle_host_update(wdata, inst, addr, hsr);
+	}
+	else if (check_host_s1pgtable(addr))
+	{
+		/*
+		 * Currently, we only handle the host kernel page
+		 * table that is allocated from the 2MB-aligned
+		 * stage 1 page pool. The allocator is implemented
+		 * at arch/arm64/kvm/pt_alloc.c for now.
+		 *
+		 * As of now, the only situation that causes a
+		 * trap (no subid) to EL2 due to a permission
+		 * fault is when 'stp' instruction is accessed.
+		 */
+
+		inst = fetch_instruction();
+		wdata = fetch_wdata(hsr, inst);
+		ret = handle_host_update(wdata, inst, addr, hsr);
+	}
+	else
+	{
+		v_panic();
+	}
+
+	release_lock_s2page(); 
+
+	return 0;
+}
diff --git a/arch/arm64/kint/HostKptAux.c b/arch/arm64/kint/HostKptAux.c
new file mode 100644
index 00000000..b640353d
--- /dev/null
+++ b/arch/arm64/kint/HostKptAux.c
@@ -0,0 +1,147 @@
+#include "kint.h"
+
+u32 __hyp_text handle_host_update(u64 wdata, u32 inst,  u64 fault_ipfn, u32 hsr)
+{	
+	u32 inst_stxr_op, inst_stp_op;
+	u64 va, subowner;
+	u64 ISV, far_el2;
+	u32 len;
+	u64 rdata, pc_counter, fault_ipa;
+
+	len = host_dabt_get_as(hsr);
+
+	far_el2 = read_sysreg_el2(far) & offset_mask; //tranform into function 
+	fault_ipa = fault_ipfn | far_el2;
+	subowner = get_pfn_subowner(fault_ipfn >> PAGE_SHIFT);
+	va = __el2_va(fault_ipa);
+
+	inst_stxr_op = inst & STXR_OPCODE_MASK; //transform into function
+	inst_stp_op = inst & STP_OPCODE_MASK;
+	ISV = (hsr & ESR_EL2_ISV_MASK) >> ESR_EL2_ISV_SHIFT; // tranform insto function 
+
+	acquire_lock_host_kpt();
+	
+	if(inst_stxr_op == STXR_OPCODE1 || inst_stxr_op == STXR_OPCODE2)
+	{	
+		stxr_write_handler(wdata, inst, va);
+		host_skip_instr();
+		release_lock_host_kpt();
+        return 0;
+	}
+	else if (inst_stp_op == STP_OPCODE && check_host_s1pgtable(fault_ipfn)
+					&& subowner == NONE)
+	{
+		stp_write_handler(inst, va);
+		host_skip_instr();
+		release_lock_host_kpt();
+		return 0;
+	}
+	else 
+	{
+		if (ISV == 1)
+		{	
+			handle_host_update_write(wdata, va, len);
+			host_skip_instr();
+			release_lock_host_kpt();
+			return 0;
+		}
+		else
+		{
+			print_string("\rError write emulation HSR ISV = 0\n");
+			pc_counter = read_sysreg(elr_el2);
+			printhex_ul(pc_counter);
+			release_lock_host_kpt();
+			v_panic();
+			return 1;
+		}
+	}
+	
+}
+
+void __hyp_text handle_host_remove_page(u64 pfn, u32 vmid)
+{
+	u64 perm, new_pte;
+	u32 ret, subowner;
+
+	if (vmid == HOSTVISOR) // Check if this check is really necessary 
+	{	
+		subowner = get_pfn_subowner(pfn);
+
+		set_pfn_subowner(pfn, 0); 
+		clear_phys_page(pfn);
+		__flush_dcache_area(__el2_va(pfn << PAGE_SHIFT), PAGE_SIZE);
+
+
+		/* Not refund pages if it is protected module */
+		if (!is_mod(subowner))
+		{
+			ret = check_clear_pfn_host(pfn);
+			if (ret == 2U)
+			{
+				perm = pgprot_val(SECT_S2_KERNEL);
+				new_pte = kint_mk_pmd(pfn, perm);
+				mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 2U, new_pte);
+			}
+			else if (ret == 3U)
+			{
+				perm = pgprot_val(PAGE_S2_KERNEL);
+				new_pte = (pfn * PAGE_SIZE) | perm;
+				mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 3U, new_pte);
+			}
+		}
+	}
+}
+
+u32 __hyp_text handle_host_new_page(u64 pfn, u32 subid, u32 vmid)
+{
+	u64 perm, new_pte;
+	u32 owner; 
+
+	if (vmid == HOSTVISOR)
+	{	
+		/// note : remap or map at stage2 page table is the same. maybe flush tlb only when we remap
+		u32 ret = check_clear_pfn_host(pfn);
+
+		if(ret)
+		{
+			if(ret == 1U)
+			{
+				v_panic();
+			}
+			else
+			{
+				if (check_host_s1pgtable(pfn * PAGE_SIZE))
+				{
+					perm = pgprot_val(SECT_S2);
+					new_pte = kint_mk_pmd(pfn, perm);
+					mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 2U, new_pte);
+				}
+				else
+				{
+					perm = pgprot_val(PAGE_S2);
+					new_pte = pfn * PAGE_SIZE | perm;
+					mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 3U, new_pte);
+				}
+			}
+		}
+
+		clear_phys_page(pfn);
+		__flush_dcache_area(__el2_va(pfn << PAGE_SHIFT), PAGE_SIZE);
+		set_pfn_subowner(pfn, subid);
+	}
+}
+
+ void __hyp_text handle_host_leaf_update(u64 wdata, u32 w_subowner, u32 inst,  u64 fault_ipfn, u32 hsr)
+ {	
+	u32 ret;
+	u64 w_pfn, pxn;
+
+//Enable Dynamic EL1 pt PXN
+
+	if(w_subowner != EL1_KCODE && w_subowner != EL1_MOD_txt && !(wdata & DCPTR_EL1_PXN_BLOCK_MASK))
+	{	
+		wdata = wdata | DCPTR_EL1_PXN_BLOCK_MASK; 
+	}
+
+	ret = handle_host_update(wdata, inst, fault_ipfn, hsr);
+ }
diff --git a/arch/arm64/kint/HostKptCore.c b/arch/arm64/kint/HostKptCore.c
new file mode 100644
index 00000000..d4bc0d34
--- /dev/null
+++ b/arch/arm64/kint/HostKptCore.c
@@ -0,0 +1,201 @@
+#include "kint.h"
+
+void __hyp_text stxr_write_handler(u64 wdata, u64 inst, u64 va)
+{
+	u64 inst_op, len;
+	u32 Rs, flag;
+
+	inst_op = inst & STXR_OPCODE_MASK;
+
+	if (inst_op == STXR_OPCODE1) {
+		len = 4;
+	} else if (inst_op == STXR_OPCODE2) {
+		len = 8;
+	} else {
+		print_string("\rUnknown stxr opcode\n");
+		printhex_ul(inst_op);
+		v_panic();
+	}
+
+	Rs = (inst & STXR_Rs_MASK) >> STXR_Rs_SHIFT; //flag
+
+	flag = stxr_write_handler_asm(wdata, va);
+	set_host_regs(Rs, flag);
+}
+
+void __hyp_text stp_write_handler(u64 inst, u64 va)
+{
+	u64 inst_op, inst_op2, wdata1, wdata2;
+	u32 Rt, Rt2;
+
+	inst_op = inst & STP_XZR_MASK;
+	inst_op2 = inst & STP_OPCODE_MASK;
+
+	if (inst_op == STP_XZR_INST) {
+		handle_host_update_write(0x0, va, 8U);
+		handle_host_update_write(0x0, va + 8U, 8U);
+	} else if (inst_op2 == STP_OPCODE) {
+		Rt = (inst & STP_Rt_MASK) >> STP_Rt_SHIFT;
+		Rt2 = (inst & STP_Rt2_MASK) >> STP_Rt2_SHIFT;
+
+		wdata1 = get_host_regs(Rt);
+		wdata2 = get_host_regs(Rt2);
+
+		/*
+		 * FIXME: Required to check the written data, bypass the checking from now
+		 * Possible data in register:
+		 * 1. address of host kpt pool
+		 * 2. address of &pool->free_area[]
+		 */
+		if (1) {
+			handle_host_update_write(wdata1, va, 8U);
+			handle_host_update_write(wdata2, va + 8U, 8U);
+		} else {
+			print_string("\rUnable to handle write data not in kpt pool\n");
+			printhex_ul(inst_op);
+			v_panic();
+		}
+	} else {
+		print_string("\rUnknown stp opcode\n");
+		printhex_ul(inst_op);
+		v_panic();
+	}
+
+}
+
+u64 __hyp_text handle_host_update_read(u64 fault_ipa, u32 len)
+{
+	void __iomem *base = (void *)fault_ipa;
+	u64 rdata;
+	if (len == 8U) {
+		rdata = (u64)readq_relaxed(fault_ipa);
+	} else if (len == 4U) {
+		rdata = (u64)readl_relaxed(fault_ipa);
+	} else if (len == 2U) {
+		rdata = (u64)readw_relaxed(fault_ipa);
+	} else if (len == 1U) {
+		rdata = (u64)readb_relaxed(fault_ipa);
+	} else {
+		print_string("\rhandle read panic\n");
+		printhex_ul(len);
+		v_panic();
+	}
+	return rdata;
+}
+
+void __hyp_text handle_host_update_write(u64 write_content, u64 va, u32 len)
+{
+	void __iomem *base = (void *)va;
+
+	if (len == 8U) {
+#if 0
+		pt_store(COREVISOR, fault_ipa, (u64)write_content);
+#else
+		writeq_relaxed((u64)write_content, base);
+#endif
+
+	} else if (len == 4U) {
+		writel_relaxed((u32)write_content, base);
+	} else if (len == 2U) {
+		writew_relaxed((u16)write_content, base);
+	} else if (len == 1U) {
+		writeb_relaxed((u8)write_content, base);
+	} else {
+		print_string("\rHandle write size panic\n");
+		printhex_ul(len);
+		printhex_ul(write_content);
+		v_panic();
+	}
+}
+
+u32 __hyp_text get_kpt_shift(u32 subid)
+{
+	switch (subid) {
+	case EL1_PGD:
+		return PGD_SHIFT;
+	case EL1_PUD:
+		return PUD_SHIFT;
+	case EL1_PMD:
+		return PMD_SHIFT;
+	case EL1_PTE:
+		return PTE_SHIFT;
+	}
+}
+
+u64 __hyp_text el1_va_to_el2(u64 el1_va)
+{
+	u64 ret, pa, offset, pfn;
+	u64 target;
+	void *ptr;
+
+	offset = el1_va & offset_mask;
+	pfn = translate_to_phys(el1_va);
+	
+	if(pfn != INVALID64)
+	{
+		pa = pfn | offset;
+		pfn = pfn << PAGE_SHIFT;
+
+		return __el2_va(pa);
+	}
+	else
+		v_panic(); // This should not happen
+}
+
+u32 __hyp_text check_clear_pfn_host(u64 pfn)
+{
+	u64 pte, addr;
+	u32 ret, subowner;
+
+	acquire_lock_pt(HOSTVISOR);
+
+	ret = 0U;
+	pte = walk_npt(HOSTVISOR, pfn * PAGE_SIZE);
+	if (pte != 0UL)
+	{
+		if (pte & PUD_MARK)
+		{
+			ret = 1U;
+		}
+		else if (pte & PMD_MARK)
+		{
+			addr = (pfn * PAGE_SIZE) & PMD_MASK;
+			if (check_if_clear_range_host(addr, PMD_SIZE))
+			{
+				set_npt(HOSTVISOR, pfn * PAGE_SIZE, 2U, 0);
+				kvm_tlb_flush_vmid_ipa_host(kint_pfn_pmd(pfn));
+				ret = 2U;
+			}
+		}
+		else
+		{
+			set_npt(HOSTVISOR, pfn * PAGE_SIZE, 3U, 0);
+			kvm_tlb_flush_vmid_ipa_host(pfn * PAGE_SIZE);
+			ret = 3U;
+		}
+    }
+
+	release_lock_pt(HOSTVISOR);
+
+	return ret;
+}
+
+u32 __hyp_text check_if_clear_range_host(u64 start, u64 size)
+{
+	 u64 addr, i;
+	 u32 subowner;
+
+	 for (i = 0; i < (size >> PAGE_SHIFT); i++)
+	 {
+		addr = start + i * PAGE_SIZE;
+		subowner = get_pfn_subowner(addr >> PAGE_SHIFT);
+
+		if (subowner != 0U)
+		{
+			return 0;
+		}
+
+	 }
+
+	 return 1;
+}
diff --git a/arch/arm64/kint/HostKptCoreAux.c b/arch/arm64/kint/HostKptCoreAux.c
new file mode 100644
index 00000000..daa1aa39
--- /dev/null
+++ b/arch/arm64/kint/HostKptCoreAux.c
@@ -0,0 +1,96 @@
+#include "kint.h"
+u32 __hyp_text stxr_write_handler_asm(u32 wdata, u64 fault_ipa) // not working, stxr returns 1
+{
+	u32 flag;
+	asm volatile("stxr_again%=:"
+		     "ldxr %0, [%1]\n\t"
+		     "stxr %w0, %2, [%1] \n\t"
+		     "cbnz %w0, stxr_again%="
+		     : "=&r"(flag)
+		     : "r"(fault_ipa), "r"(wdata)
+		     : "memory");
+	return flag;
+}
+
+u64 __hyp_text fetch_instruction(void){
+	u64 pc_counter, pc_va, inst, kimg_offset; 
+
+	pc_counter = read_sysreg(elr_el2); 
+	kimg_offset = get_kim_voff();
+	inst = (u64)readl_relaxed((void *)__el2_va(pc_counter - kimg_offset));//hum maybe get a case for readq ? instruction might be longer somtimes. 
+
+	return inst; 
+}
+
+u64 __hyp_text fetch_wdata(u64 hsr, u64 inst)
+{	
+	u64 wdata, pc_counter, pc_va; 
+	u32 inst_stxr_op,inst_stp_op, Rt, ISV;
+
+	ISV = (hsr & ESR_EL2_ISV_MASK) >> ESR_EL2_ISV_SHIFT;
+
+	inst_stxr_op = inst & STXR_OPCODE_MASK;
+	inst_stp_op = inst & STP_OPCODE_MASK;
+
+	if (inst_stxr_op == STXR_OPCODE1 || inst_stxr_op == STXR_OPCODE2)
+	{	
+		Rt = (inst & STXR_Rt_MASK) >> STXR_Rt_SHIFT;  //Write content
+		wdata = get_host_regs(Rt);
+	}
+	else if (inst_stp_op == STP_OPCODE)
+	{
+		wdata = 0x0;
+	}
+	else 
+	{
+		if (ISV == 1)
+		{
+			wdata = host_get_mmio_data(hsr);
+		}
+		else
+		{
+			print_string("\rUnable to fetch wdata with HSR ISV = 0\n");
+			v_panic();
+		}
+	}
+	return wdata; 
+}
+
+u64 __hyp_text fetch_rdata(u64 addr) //function doublon avec host handle read un bail comme ca 
+{	
+	u64 rdata, far_el2, fault_ipa; 
+
+	far_el2 = read_sysreg_el2(far) & offset_mask;
+	fault_ipa = addr | far_el2;
+	rdata = (u64)readq_relaxed((void *)__el2_va(fault_ipa));
+
+	return rdata; 
+}
+
+u64 __hyp_text translate_to_phys(u64 v_addr)
+{
+	u64 par,tmp, hpfar; 
+	u32 fault, FST, PTW; 
+
+	par = read_sysreg(par_el1);
+	
+	asm volatile("at s1e1r, %0" : : "r" (v_addr));
+	
+	isb();
+	
+	tmp = read_sysreg(par_el1);
+	write_sysreg(par, par_el1);
+
+	fault = tmp & 1UL; 
+	if(fault)
+	{	
+		FST = (tmp & 0x7E) >> 1;  //Select bit [6-1] 
+		PTW = (tmp & (1UL << 8)); 
+		return INVALID64; 
+	}
+	else
+	{
+		hpfar = ((tmp >> 12) & ((1UL << 36) - 1)) << 12;
+		return hpfar;
+	}
+}
diff --git a/arch/arm64/kint/HostKptOps.c b/arch/arm64/kint/HostKptOps.c
new file mode 100644
index 00000000..291e8835
--- /dev/null
+++ b/arch/arm64/kint/HostKptOps.c
@@ -0,0 +1,132 @@
+#include "kint.h"
+
+void __hyp_text unmapping_handler(u64 rdata, u64 wdata, u64 inst, u64 fault_ipfn, u64 hsr) 
+{	
+	u32 ret, subcount, pfn, owner, subowner;
+
+	pfn = phys_page(rdata) >> PAGE_SHIFT;
+
+	owner = get_pfn_owner(pfn);
+	subowner = get_pfn_subowner(fault_ipfn/PAGE_SIZE);
+
+	if (owner != INVALID_MEM && owner != HOSTVISOR)
+			v_panic();
+
+	if (is_kpt(subowner))
+	{	
+		subcount = get_pfn_subcount(pfn);
+
+		ret = handle_host_update(wdata, inst, fault_ipfn, hsr);
+		set_pfn_el1_va(pfn, 0UL); 
+
+		if (subcount != INVALID_MEM)
+		{	
+			if (subcount == 1)
+			{
+				handle_host_remove_page(pfn, owner);
+			}
+			set_pfn_subcount(pfn, subcount - 1); 
+		}		
+	}
+	
+}
+
+void __hyp_text mapping_handler(u64 wdata, u64 inst, u64 fault_ipfn, u64 hsr)
+{
+	u64 w_pfn, pfn, kpt_index, offset; 
+	u32 type, subowner, w_subowner, w_subcount, subcount, ret, kpt_shift;
+	u32 owner;  
+
+	w_pfn = phys_page(wdata) >> PAGE_SHIFT;
+
+	pfn = fault_ipfn >> PAGE_SHIFT; 
+	type = (wdata & TYPE_BIT_MASK) >> TYPE_BIT_SHIFT;
+	offset = read_sysreg_el2(far) & offset_mask;
+
+	
+	kpt_index = get_pfn_kpt_index(pfn);
+	owner = get_pfn_owner(w_pfn);
+	subowner = get_pfn_subowner(pfn);
+	subcount = get_pfn_subcount(pfn);
+	w_subowner = get_pfn_subowner(w_pfn); 
+	w_subcount = get_pfn_subcount(w_pfn);
+
+	if (points_to_table(subowner, type))
+	{	
+		if (w_subowner == subowner + 1)
+		{	
+			ret = handle_host_update(wdata, inst, fault_ipfn, hsr);
+			set_pfn_subcount(w_pfn, w_subcount + 1);
+
+			kpt_shift = get_kpt_shift(subowner);
+			kpt_index |= (offset / 8) << kpt_shift;						
+			set_pfn_kpt_index(w_pfn, kpt_index);
+			
+		}
+		else if (w_subowner) 
+		{
+			return; 
+		}
+		else
+		{	
+			ret = handle_host_new_page(w_pfn, subowner + 1, owner);
+		}		
+	}
+	else if (points_to_leaf(subowner, type)) 
+	{	
+		handle_host_leaf_update(wdata, w_subowner, inst, fault_ipfn, hsr);
+		set_pfn_subcount(w_pfn, w_subcount + 1);
+		kpt_shift = get_kpt_shift(subowner);
+		kpt_index |= (offset / 8) << kpt_shift;					
+		set_pfn_el1_va(w_pfn, kpt_index);				
+	}
+}
+
+
+void __hyp_text update_handler(u64 rdata, u64 wdata, u64 inst, u64 fault_ipfn, u64 hsr)
+{
+	u64 w_pfn, r_pfn, pfn; 
+	u32 type, ret;
+	u32 subowner;
+	u32 w_subowner, r_subowner;
+	u32 owner, r_owner;
+
+	w_pfn = phys_page(wdata) >> PAGE_SHIFT;
+	r_pfn = phys_page(rdata) >> PAGE_SHIFT; 	
+
+	if(w_pfn != r_pfn)
+		return; 
+
+	pfn = fault_ipfn >> PAGE_SHIFT; 
+	type = (wdata & TYPE_BIT_MASK) >> TYPE_BIT_SHIFT;
+
+	owner = get_pfn_owner(w_pfn);
+	r_owner = get_pfn_owner(r_pfn);
+	subowner = get_pfn_subowner(pfn);
+	w_subowner = get_pfn_subowner(w_pfn); 
+	r_subowner = get_pfn_subowner(r_pfn); 
+
+	if (r_owner != INVALID_MEM && r_owner != HOSTVISOR)
+		v_panic();
+
+	if (points_to_table(subowner, type))
+	{
+		if (w_subowner == subowner + 1) 
+		{	
+			ret = handle_host_update(wdata, inst, fault_ipfn, hsr);
+		}
+		else if (w_subowner)
+		{
+			return; 
+		}
+		else
+		{	
+			ret = handle_host_new_page(w_pfn, subowner + 1, owner);
+		}		
+	}
+	else if (points_to_leaf(subowner, type))
+	{
+		handle_host_leaf_update(wdata, w_subowner, inst, fault_ipfn, hsr);
+	}
+	
+}
diff --git a/arch/arm64/kint/HostModule.c b/arch/arm64/kint/HostModule.c
new file mode 100644
index 00000000..835be35c
--- /dev/null
+++ b/arch/arm64/kint/HostModule.c
@@ -0,0 +1,208 @@
+#include "kint.h"
+#include "../sekvm/hacl-20/Hacl_Ed25519.h"
+#include "../sekvm/hacl-20/Hacl_AES.h"
+
+u32 __hyp_text el2_load_module(u64 p_hdr, u64 mod_percpu, u64 mod_arch, u64 checklists, u32 entsize)
+{   
+  u32 err, i, pgnb;
+
+  struct mod_sec_info secinfo[MAX_VERIFY_SECTION_SIZE];
+  struct el2_mod_info mod;
+  unsigned char mod_name[100];
+
+  acquire_lock_host_kpt();
+  el2_memset(&mod, 0, sizeof(struct el2_mod_info));
+  el2_memset(&secinfo, 0, sizeof(struct mod_sec_info)*MAX_VERIFY_SECTION_SIZE);
+
+  err = init_mapping(&mod, p_hdr, mod_arch);
+  if (err)
+		goto unlock;
+  init_info(secinfo, &mod, checklists, entsize);
+
+  if (mod.verify_size == 0)
+		goto unlock;
+
+  mod.modid = gen_modid();
+  if (mod.modid == V_INVALID)
+		goto unlock;
+
+  el2_get_modinfo(&mod, mod_name);
+
+  /* Signature Verification */
+  pgnb = page_align(mod.verify_size) >> PAGE_SHIFT;
+  mod.buff = alloc_tmp_buffer(pgnb);
+  if (mod.buff == INVALID_MEM)
+		goto fail_checksum;
+
+  move_section(mod.buff, secinfo, 0U, 0U, entsize);
+  err = verify_mod(mod.buff, mod.verify_size, mod_name);
+  if (err)
+		goto fail_checksum;
+
+  err = update_section(&mod, secinfo, mod.buff, entsize);
+  if (err)
+		goto fail_checksum;
+
+  err = simplify_symbol(&mod, mod_percpu);
+  if (err)
+		goto fail_checksum;
+
+  err = relocate(&mod);
+  if (err)
+		goto fail_checksum;
+
+  err = el2_fill_symtab(&mod, checklists, entsize);
+  if (err)
+		goto fail_checksum;
+
+  el2_set_sec(&mod);
+  update_ex_perm(&mod);
+  refund_rw_perm(&mod, secinfo, entsize);
+  release_lock_host_kpt();
+
+  return mod.modid;
+
+fail_checksum:
+	remove_mod(mod.modid);
+unlock:
+ 	refund_rw_perm(&mod, secinfo, entsize);
+	release_lock_host_kpt();
+	return V_INVALID;
+}
+
+const struct sig_info sig[5] = {
+	{ "ipod", "b9b3c34ded3009acd3920dcb3da56666665dab0b9cc5d19ab3d5b4649518690c804688727e90d2f521cdb16c269acd42d22e5a05b94c1f3142d44d838b4a4b0b" },
+	{ "libcrc32c", "da4b3392baa43eceee6ffcbe87c51ad851f028996d1ac7445e7dd2552c136cbdbe45d41948a3c5e41dfe43a9835c8e94a8c785907ac028c2290ba860644aa70f" },
+	{ "xfs", "bdcc8409cac0b4719a11063366c44c0ec034f4faf6aa6476b6e19f5136e2d0c9b60a34a2346ca0a90c29455cb362e4a63eabed38c87a1aca77b254a9afe67f09" },
+	{"crypto_engine","8d676c02b49db072a1bb279bec83e2e1d053a8d645cc0e941210af11cba0b67e7b88d29510180f0e1d2d17e5a7b95002ad3ef0c876ae9d998bebd8444c69e00c"},
+	{"virtio_crypto", "01ae4c1834a88af09aa96cb91fa59cf7fbe0019898df7a232f821c116dec0228dea74583194e6d779ebfcbe1c554e039890b406bf899d1eb57bbe3132efe2a04"},
+};
+
+u32 __hyp_text verify_mod(u64 buff, size_t size, char *name)
+{
+	uint8_t public_key[32];
+	uint8_t signature[64];
+	uint8_t private_key[64];
+
+	bool result;
+	int i, id = -1;
+
+	unsigned char *public_key_hex =
+		"07f8993d1a43239a925ad3d02124b931b7f1d0531122f35d63c85cf79f3f4eca";
+	unsigned char *private_key_hex =
+		"100df9e44a5516fd053dc9ede29914b05d162c3faebbd1fb1897f8169c77a77bee33356625802cb7512453cd2719fec42100215369e30520979e7498506f010e";
+
+	el2_hex2bin(public_key, public_key_hex, 32);
+	el2_hex2bin(private_key, private_key_hex, 64);
+
+	for (i = 0; i < ARRAY_SIZE(sig); i++) {
+		if (!el2_strncmp(name, sig[i].name, el2_strlen(name))) {
+			id = i;
+			break;
+		}
+	}
+
+	if (id != -1) {
+		el2_hex2bin(signature, sig[id].signature_hex, 64);
+		result = Hacl_Ed25519_verify(public_key, size, (uint8_t *)buff,
+						signature);
+	}
+
+	return (result == true)? 0U: V_INVALID;
+}
+
+u32 __hyp_text gen_modid()
+{
+	u32 i;
+	struct el2_mod *info;
+
+	for (i = 0; i < EL2_MOD_INFO_SIZE; i++) {
+		if (!get_mod_in_use(i)) {
+			set_mod_in_use(i, true);
+			return i;
+		}
+	}
+
+	return V_INVALID;
+}
+
+void __hyp_text el2_get_modinfo(struct el2_mod_info *mod, char *mod_name)
+{
+	u32 info_idx, taglen;
+	u64 size;
+	char *name, *p;
+	char *tmp;
+	Elf_Shdr * infosec;
+
+	taglen = el2_strlen("name");
+	info_idx = find_sec(mod, ".modinfo");
+	infosec = &mod->sechdrs[info_idx];
+	size = infosec->sh_size;
+
+	for (p = (char *) el1_va_to_el2(infosec->sh_addr); p; p = el2_next_str(p, &size))
+	{
+		if(el2_strncmp(p, "name", taglen) == 0 && p[taglen] == '=')
+		{
+			name = p + taglen + 1;
+			el2_strncpy(mod_name, name, el2_strlen(name));
+		}
+	}
+	return NULL;
+}
+
+void __hyp_text el2_set_sec(struct el2_mod_info *mod)
+{
+	struct el2_mod *info;
+
+	info = (struct el2_mod *)get_mod_ref(mod->modid);
+	el2_memcpy(&info->mod_sec, &mod->mod_section, sizeof(struct el2_mod_sec));
+	el2_memcpy(&info->mod_tabs, &mod->mod_symtab, sizeof(struct el2_mod_tabs));
+}
+
+void __hyp_text mod_reloc_handler(u64 wdata, u64 rdata, u64 inst, u64 addr, u64 hsr)
+{ 
+
+  if (wdata == 0)
+  { 
+    handle_host_update(wdata, inst, addr, hsr);
+    return;
+  }
+
+  v_panic();
+}
+
+u32 __hyp_text el2_free_module(u32 mod_id)
+{ 
+  char * mod_name; 
+  u32 i;
+  u32 ret = V_INVALID;
+
+  acquire_lock_host_kpt();
+
+  if (get_mod_in_use(mod_id)) {
+		mark_rw_nx(mod_id, 0U);
+		remove_mod(mod_id);
+		ret = 0U;
+  }
+
+  release_lock_host_kpt();
+  return ret;
+}
+
+u32 __hyp_text el2_free_mod_init(u32 mod_id)
+{
+  char * mod_name; 
+  u32 last_idx;
+  u32 ret = V_INVALID;
+
+  acquire_lock_host_kpt();
+
+
+  if (get_mod_in_use(mod_id)) {
+	mark_rw_nx(mod_id, 1U);
+	ret = 0U;
+  }
+
+  release_lock_host_kpt();
+  return ret;
+}
diff --git a/arch/arm64/kint/HostModuleAux.c b/arch/arm64/kint/HostModuleAux.c
new file mode 100644
index 00000000..6be81565
--- /dev/null
+++ b/arch/arm64/kint/HostModuleAux.c
@@ -0,0 +1,533 @@
+#include "kint.h"
+
+u64 __hyp_text elf_size(u64 vhdr)
+{
+	Elf64_Ehdr *hdr;
+	u64 size;
+
+	hdr = (Elf64_Ehdr *)el1_va_to_el2(vhdr);
+	size = hdr->e_shoff + (hdr->e_shentsize * hdr->e_shnum);
+	return size;
+}
+
+bool __hyp_text within_temporary_image(struct el2_mod_info *mod, u64 addr, u64 size)
+{
+	u64 end;
+
+	end = page_align(addr + size);
+
+	return ((addr >= mod->vhdr) && (end <= (mod->vhdr + mod->size))) ? true : false;
+}
+
+struct mod_sec_info __hyp_text init_sec(u32 idx, struct el2_mod_info *mod)
+{
+	struct mod_sec_info secinfo;
+	u64 perm;
+	u32 page_nb, err;
+
+	el2_memset(&secinfo, 0, sizeof(struct mod_sec_info));
+
+	Elf64_Shdr *shdr = &mod->sechdrs[idx];
+	struct verinfo *vinfo = &secinfo.vinfo;
+
+	secinfo.base = shdr->sh_addr;
+	
+	vinfo->size = shdr->sh_size;
+	vinfo->flags = shdr->sh_flags;
+	vinfo->align_size = shdr->sh_addralign? :1;
+	vinfo->info = shdr->sh_info;
+	vinfo->type = shdr->sh_type;
+	vinfo->link = shdr->sh_link;
+
+	if (vinfo->type == SHT_SYMTAB) {
+		mod->index.sym = idx;
+		mod->index.str = shdr->sh_link;
+		mod->strtab = (char *)mod->hdr + mod->sechdrs[mod->index.str].sh_offset;
+	}
+
+	/*
+	 * Remap sections that locacted in final memory layout
+	 * to write-protected before authenticate.
+	 */
+	if (!within_temporary_image(mod, secinfo.base, vinfo->size))
+	{
+		page_nb = page_align(vinfo->size) >> PAGE_SHIFT;
+		perm = pgprot_val(PAGE_S2);
+		err = remap_host_mod_page_range(secinfo.base, page_nb, EL1_AUTH, perm, 3U, 0U);
+		if (err)
+			secinfo.base = 0UL;
+	}
+
+	return secinfo;
+}
+
+u32 __hyp_text remap_host_mod_page(u64 pfn, u32 owner, u64 perm, u32 level, u32 clear)
+{
+	u64 new_pte;
+	u32 i, subowner;
+
+	subowner = get_pfn_subowner(pfn);
+
+
+	if (owner == subowner)
+		return 0U;
+
+	if (get_pfn_owner(pfn) != HOSTVISOR || (subowner != EL1_AUTH && subowner != NONE))
+		return V_INVALID;
+		
+	clear_pfn_host(pfn);
+
+	if (clear) {
+		clear_phys_page(pfn);
+		__flush_dcache_area(__el2_va(pfn << PAGE_SHIFT), PAGE_SIZE);
+	}
+
+	new_pte = (pfn * PAGE_SIZE) | perm;
+	mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, level, new_pte);
+
+	set_pfn_subowner(pfn, owner);
+
+	return 0;
+}
+
+u32 __hyp_text remap_host_mod_page_range(u64 base, u32 page_nb, u32 owner,
+				u64 perm, u32 level, u32 clear)
+{
+	u64 pfn;
+	u32 i, ret;
+
+	for (i = 0; i < page_nb; i++) {
+		pfn = translate_to_phys(base + i * PAGE_SIZE) / PAGE_SIZE;
+		ret = remap_host_mod_page(pfn, owner, perm, level, clear);
+		if (ret == V_INVALID)
+			return ret;
+	}
+	return 0;
+}
+
+u32 __hyp_text get_offset_check(struct mod_sec_info *secinfo, u64 *base, u64 *size, 
+				u64 mask, u32 *start, u32 end)
+{
+	u32 i;
+	long ret;
+
+	*base = 0UL;
+	*size = 0UL;
+
+	for (i = *start; i < end; i++) {
+		if ((secinfo[i].vinfo.flags & SHF_WAX) != mask) {
+			if(*base != 0UL)
+				return i;
+		} else {
+			if(*base == 0UL) {
+				*start = i;
+				*base = secinfo[i].base;
+			}
+
+			ret = el2_align(*size, secinfo[i].vinfo.align_size);
+			if ((*base + ret) != secinfo[i].base) {
+					return V_INVALID;
+			}
+			*size = ret + secinfo[i].vinfo.size;
+		}
+	}
+
+	return end;
+}
+
+const struct kernel_symbol *__hyp_text el2_resolve_symbol(const char *name)
+{
+	u64 owner_modid;
+	const struct kernel_symbol *ksym;
+	int err;
+
+	struct find_symbol_arg fsa = {
+		.name = name,
+		.gplok = true, // assume to be true
+		.sym = NULL,
+	};
+
+	el2_find_symbol(&fsa);
+	
+	return fsa.sym;
+}
+
+
+int __hyp_text reloc_insn_movw_el2(enum aarch64_reloc_op op, __le32 *place,
+				   u64 el1_place, u64 val, int lsb,
+				   enum aarch64_insn_movw_imm_type imm_type)
+{
+	u64 imm;
+	s64 sval;
+	u32 insn = le32_to_cpu(*place); 
+
+	sval = el2_do_reloc(op, el1_place, val);
+	imm = sval >> lsb;
+
+	if (imm_type == AARCH64_INSN_IMM_MOVNZ) {
+		/*
+    	 * For signed MOVW relocations, we have to manipulate the
+    	 * instruction encoding depending on whether or not the
+    	 * immediate is less than zero.
+    	 */
+		insn &= ~(3 << 29);
+		if (sval >= 0) {
+			/* >=0: Set the instruction to MOVZ (opcode 10b). */
+			insn |= 2 << 29;
+		} else {
+			/*
+    		 * <0: Set the instruction to MOVN (opcode 00b).
+    		 *     Since we've masked the opcode already, we
+    		 *     don't need to do anything other than
+    		 *     inverting the new immediate field.
+    		 */
+			imm = ~imm;
+		}
+	}
+
+	/* Update the instruction with the new encoding. */
+	insn = el2_aarch64_insn_encode_immediate(AARCH64_INSN_IMM_16, insn,
+						 imm); // Not an issue
+
+	*place = cpu_to_le32(insn); // This is hte actual update
+
+	if (imm > U16_MAX)
+		return -ERANGE;
+	return 0;
+}
+
+int __hyp_text reloc_insn_imm_el2(enum aarch64_reloc_op op, __le32 *place,
+				  u64 el1_place, u64 val, int lsb, int len,
+				  enum aarch64_insn_imm_type imm_type)
+{
+	u64 imm, imm_mask;
+	s64 sval;
+	u32 insn = le32_to_cpu(*place);
+	/* Calculate the relocation value. */
+	sval = el2_do_reloc(op, el1_place, val);
+	sval >>= lsb;
+
+	/* Extract the value bits and shift them to bit 0. */
+	imm_mask = (BIT(lsb + len) - 1) >> lsb;
+	imm = sval & imm_mask;
+
+	/* Update the instruction's immediate field. */
+	insn = el2_aarch64_insn_encode_immediate(imm_type, insn, imm);
+
+	*place = cpu_to_le32(insn);
+
+	/*
+	 * Extract the upper value bits (including the sign bit) and
+	 * shift them to bit 0.
+	 */
+
+	sval = (s64)(sval & ~(imm_mask >> 1)) >> (len - 1);
+
+	/*
+	 * Overflow has occurred if the upper bits are not all equal to
+	 * the sign bit of the value.
+	 */
+	if ((u64)(sval + 1) >= 2)
+		return -ERANGE;
+
+	return 0;
+}
+
+u32 __hyp_text reloc_insn_adrp_el2(struct el2_mod_info *mod, __le32 *place, u64 el1_place,
+			u64 val, bool in_init)
+{
+	u32 insn;
+	u32 tmp;
+
+	if (!IS_ENABLED(CONFIG_ARM64_ERRATUM_843419) ||
+	    !cpus_have_const_cap(ARM64_WORKAROUND_843419) ||
+	    ((u64)place & 0xfff) < 0xff8) {
+		tmp = reloc_insn_imm_el2(RELOC_OP_PAGE, place, el1_place, val,
+					 12, 21, AARCH64_INSN_IMM_ADR);
+		return tmp;
+	}
+
+	/* patch ADRP to ADR if it is in range */
+	if (!reloc_insn_imm_el2(RELOC_OP_PREL, place, el1_place, val & ~0xfff,
+				0, 21, AARCH64_INSN_IMM_ADR)) {
+		insn = le32_to_cpu(*place);
+		insn &= ~BIT(31);
+	} else {
+		/* out of range for ADR -> emit a veneer */
+		val = el2_module_emit_veneer_for_adrp(mod, place, val & ~0xfff, in_init);
+		if (!val)
+			return -ENOEXEC;
+		insn = el2_aarch64_insn_gen_branch_imm((u64)place, val,
+						   AARCH64_INSN_BRANCH_NOLINK);
+	}
+	*place = cpu_to_le32(insn);
+	return 0;
+}
+
+int __hyp_text apply_relocate_add_el2(struct el2_mod_info *mod, u32 relsec)
+{
+	u32 i;
+	int ovf;
+	bool overflow_check, in_init;
+	Elf64_Sym *sym, *el1_sym;
+	void *loc, *el1_loc;
+	Elf64_Shdr *sechdrs;
+	u64 val, symidx;
+
+	sechdrs = mod->sechdrs;
+	symidx = mod->index.sym;
+
+	Elf64_Rela *rel = (void *)el2_mod_va(sechdrs[relsec].sh_addr, mod); 
+
+	in_init = !el2_strncmp(mod->secstring + sechdrs[sechdrs[relsec].sh_info].sh_name,
+					".init", 5);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+
+		el1_loc = (void*)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+
+		loc = (void *) el1_va_to_el2(el1_loc);
+
+		el1_sym = (Elf64_Sym *)sechdrs[symidx].sh_addr
+					 + ELF64_R_SYM(rel[i].r_info);
+
+		sym = (Elf64_Sym *)el1_va_to_el2(el1_sym);
+
+		val = sym->st_value + rel[i].r_addend;
+
+		overflow_check = true;
+
+		switch (ELF64_R_TYPE(rel[i].r_info)) {
+		/* Null relocations. */
+		case R_ARM_NONE:
+		case R_AARCH64_NONE:
+			ovf = 0;
+			break;
+
+		/* Data relocations. */
+		case R_AARCH64_ABS64:
+			overflow_check = false;
+			ovf = el2_reloc_data(RELOC_OP_ABS, loc, el1_loc, val, 64);
+			break;
+		case R_AARCH64_ABS32:
+			ovf = el2_reloc_data(RELOC_OP_ABS, loc, el1_loc, val, 32);
+			break;
+		case R_AARCH64_ABS16:
+			ovf = el2_reloc_data(RELOC_OP_ABS, loc, el1_loc, val, 16);
+			break;
+		case R_AARCH64_PREL64:
+			overflow_check = false;
+			ovf = el2_reloc_data(RELOC_OP_PREL, loc, el1_loc, val, 64);
+			break;
+		case R_AARCH64_PREL32:
+			ovf = el2_reloc_data(RELOC_OP_PREL, loc, el1_loc, val, 32);
+			break;
+		case R_AARCH64_PREL16:
+			ovf = el2_reloc_data(RELOC_OP_PREL, loc, el1_loc, val, 16);
+			break;
+
+		/* MOVW instruction relocations. */
+		case R_AARCH64_MOVW_UABS_G0_NC:
+			overflow_check = false;
+		case R_AARCH64_MOVW_UABS_G0:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 0,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_UABS_G1_NC:
+			overflow_check = false;
+		case R_AARCH64_MOVW_UABS_G1:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 16,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_UABS_G2_NC:
+			overflow_check = false;
+		case R_AARCH64_MOVW_UABS_G2:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 32,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_UABS_G3:
+			/* We're using the top bits so we can't overflow. */
+			overflow_check = false;
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 48,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_SABS_G0:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 0,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_SABS_G1:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 16,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_SABS_G2:
+			ovf = reloc_insn_movw_el2(RELOC_OP_ABS, loc, el1_loc, val, 32,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G0_NC:
+			overflow_check = false;
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 0,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G0:
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 0,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G1_NC:
+			overflow_check = false;
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 16,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G1:
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 16,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G2_NC:
+			overflow_check = false;
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 32,
+					      AARCH64_INSN_IMM_MOVKZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G2:
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 32,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+		case R_AARCH64_MOVW_PREL_G3:
+			/* We're using the top bits so we can't overflow. */
+			overflow_check = false;
+			ovf = reloc_insn_movw_el2(RELOC_OP_PREL, loc, el1_loc, val, 48,
+					      AARCH64_INSN_IMM_MOVNZ);
+			break;
+
+		/* Immediate instruction relocations. */
+		case R_AARCH64_LD_PREL_LO19:
+			ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 2, 19,
+					     AARCH64_INSN_IMM_19);
+			break;
+		case R_AARCH64_ADR_PREL_LO21:
+			ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 0, 21,
+					     AARCH64_INSN_IMM_ADR);
+			break;
+
+		case R_AARCH64_ADR_PREL_PG_HI21_NC:
+			overflow_check = false;
+		case R_AARCH64_ADR_PREL_PG_HI21:
+			ovf = reloc_insn_adrp_el2(mod, loc, el1_loc, val, in_init);
+			if (ovf && ovf != -ERANGE)
+				return ovf;
+			break;
+		case R_AARCH64_ADD_ABS_LO12_NC:
+		case R_AARCH64_LDST8_ABS_LO12_NC:
+			overflow_check = false;
+			ovf = reloc_insn_imm_el2(RELOC_OP_ABS, loc, el1_loc, val, 0, 12,
+					     AARCH64_INSN_IMM_12);
+			break;
+		case R_AARCH64_LDST16_ABS_LO12_NC:
+			overflow_check = false;
+			ovf = reloc_insn_imm_el2(RELOC_OP_ABS, loc, el1_loc, val, 1, 11,
+					     AARCH64_INSN_IMM_12);
+			break;
+		case R_AARCH64_LDST32_ABS_LO12_NC:
+			overflow_check = false;
+			ovf = reloc_insn_imm_el2(RELOC_OP_ABS, loc, el1_loc, val, 2, 10,
+					     AARCH64_INSN_IMM_12);
+			break;
+		case R_AARCH64_LDST64_ABS_LO12_NC:
+			overflow_check = false;
+			ovf = reloc_insn_imm_el2(RELOC_OP_ABS, loc, el1_loc, val, 3, 9,
+					     AARCH64_INSN_IMM_12);
+			break;
+		case R_AARCH64_LDST128_ABS_LO12_NC:
+			overflow_check = false;
+			ovf = reloc_insn_imm_el2(RELOC_OP_ABS, loc, el1_loc, val, 4, 8,
+					     AARCH64_INSN_IMM_12);
+			break;
+		case R_AARCH64_TSTBR14:
+			ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 2, 14,
+					     AARCH64_INSN_IMM_14);
+			break;
+		case R_AARCH64_CONDBR19:
+			ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 2, 19,
+					     AARCH64_INSN_IMM_19);
+			break;
+		case R_AARCH64_JUMP26:
+		case R_AARCH64_CALL26:
+			ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 2, 26,
+					     AARCH64_INSN_IMM_26);
+
+			if (IS_ENABLED(CONFIG_ARM64_MODULE_PLTS) &&
+			    ovf == -ERANGE) {
+				val = el2_module_emit_plt_entry(mod, loc, &rel[i], sym, in_init);
+				if (!val)
+					return -ENOEXEC;
+				ovf = reloc_insn_imm_el2(RELOC_OP_PREL, loc, el1_loc, val, 2,
+						     26, AARCH64_INSN_IMM_26);
+			}
+			break;
+
+		default:
+			print_string("\rdefault\n");
+			return -1;
+		}
+
+		if (overflow_check && ovf == -ERANGE)
+		{
+			goto overflow;
+		}
+
+	}
+	return 0;
+
+overflow:
+	print_string("\rOverflow\n");
+	return -1;
+}
+
+void __hyp_text mark_ex(u64 el1_base, u64 pgnb, u32 enabled_ex)
+{	
+	int i; 
+	u64 entry, ptr, pfn; 
+	for(i = 0; i < pgnb; i ++)
+	{
+		ptr = get_page_entry(el1_base + i * PAGE_SIZE); 
+		pfn = ptr >> PAGE_SHIFT; 
+		entry = pt_load(COREVISOR, ptr);
+		if (enabled_ex)
+			entry &= ~DCPTR_EL1_PXN_BLOCK_MASK;
+		else
+			entry |= DCPTR_EL1_PXN_BLOCK_MASK;
+		pt_store(COREVISOR, ptr, entry);
+		
+	}                                                                                  
+	kvm_tlb_flush_vmid_ipa_host(pfn * PAGE_SIZE);
+	return;
+}
+
+void __hyp_text refund_host_mod_page(u64 base, u32 pgnb)
+{
+	u64 pfn, perm, new_pte;
+	u32 owner; 
+	u32 i, clr;
+
+	for (i = 0; i < pgnb; i++) {
+		pfn = translate_to_phys(base + i * PAGE_SIZE) / PAGE_SIZE;
+		set_pfn_subowner(pfn, NONE);
+
+		clr = check_clear_pfn_host(pfn);
+
+		if(clr)
+		{
+			if (clr == 2U)
+			{
+				perm = pgprot_val(SECT_S2_KERNEL);
+				new_pte = (pfn * PAGE_SIZE) | perm;
+				mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 2U, new_pte);
+			}
+			else if (clr == 3U)
+			{
+				perm = pgprot_val(PAGE_S2_KERNEL);
+				new_pte = (pfn * PAGE_SIZE) | perm;
+				mmap_s2pt(HOSTVISOR, pfn * PAGE_SIZE, 3U, new_pte);
+			}
+		}
+	}
+}
diff --git a/arch/arm64/kint/HostModuleCore.c b/arch/arm64/kint/HostModuleCore.c
new file mode 100644
index 00000000..a629ecf4
--- /dev/null
+++ b/arch/arm64/kint/HostModuleCore.c
@@ -0,0 +1,246 @@
+#include "kint.h"
+
+u64 __hyp_text el2_do_reloc(enum aarch64_reloc_op reloc_op, u64 place, u64 val)
+{
+	switch (reloc_op) {
+	case RELOC_OP_ABS:
+		return val;
+	case RELOC_OP_PREL:
+		return val - place;
+	case RELOC_OP_PAGE:
+		return (val & ~0xfff) - (place & ~0xfff);
+	case RELOC_OP_NONE:
+		return 0;
+	}
+
+	print_string("do_reloc: unknown relocation operation\n");
+	return 0;
+}
+
+u32 __hyp_text el2_aarch64_insn_encode_immediate(enum aarch64_insn_imm_type type,
+				  u32 insn, u64 imm)
+{
+	u32 immlo, immhi, mask;
+	int shift;
+
+	if (insn == AARCH64_BREAK_FAULT)
+		return AARCH64_BREAK_FAULT;
+
+	switch (type) {
+	case AARCH64_INSN_IMM_ADR:
+		shift = 0;
+		immlo = (imm & ADR_IMM_LOMASK) << ADR_IMM_LOSHIFT;
+		imm >>= ADR_IMM_HILOSPLIT;
+		immhi = (imm & ADR_IMM_HIMASK) << ADR_IMM_HISHIFT;
+		imm = immlo | immhi;
+		mask = ((ADR_IMM_LOMASK << ADR_IMM_LOSHIFT) |
+			(ADR_IMM_HIMASK << ADR_IMM_HISHIFT));
+		break;
+	default:
+		if (el2_aarch64_get_imm_shift_mask(type, &mask, &shift) < 0) {
+			print_string("aarch64_insn_encode_immediate: unknown immediate encoding \n");
+            return -1;
+		}
+	}
+
+	/* Update the immediate field. */
+	insn &= ~(mask << shift);
+	insn |= (imm & mask) << shift;
+
+	return insn;
+}
+
+u64 __hyp_text el2_module_emit_veneer_for_adrp(struct el2_mod_info *mod, void *loc, u64 val,
+				bool in_init)
+{	
+	struct mod_plt_sec *pltsec = in_init ? &mod->arch->init :
+	 						  &mod->arch->core;
+
+	/* Maybe fix this by storing earlier */
+	struct elf_shdr *plt_hdr = (struct elf64_shdr *)el1_va_to_el2(pltsec->plt);
+	struct plt_entry *el1_plt = (struct plt_entry *)plt_hdr->sh_addr;
+	struct plt_entry *plt = (struct plt_entry *)el1_va_to_el2((void *)el1_plt);
+
+	int i = pltsec->plt_num_entries++;
+	u32 mov0, mov1, mov2, br;
+	int rd;
+
+	if (pltsec->plt_num_entries > pltsec->plt_max_entries)
+		{
+			print_string("\rMax plt entry exceeded for module loading\n");
+			return 0;
+		}
+	
+	rd = el2_aarch64_insn_decode_register(AARCH64_INSN_REGTYPE_RD,
+					  le32_to_cpup((__le32 *)loc));
+	
+	mov0 = el2_aarch64_insn_gen_movewide(rd, (u16)~val, 0,
+					 AARCH64_INSN_VARIANT_64BIT,
+					 AARCH64_INSN_MOVEWIDE_INVERSE);
+	
+	mov2 = el2_aarch64_insn_gen_movewide(rd, (u16)(val >> 32), 32,
+					 AARCH64_INSN_VARIANT_64BIT,
+					 AARCH64_INSN_MOVEWIDE_KEEP);	
+
+	br = el2_aarch64_insn_gen_branch_imm((u64)&plt[i].br, (u64)loc + 4,
+					 AARCH64_INSN_BRANCH_NOLINK);
+
+	plt[i] = (struct plt_entry){
+			cpu_to_le32(mov0),
+			cpu_to_le32(mov1),
+			cpu_to_le32(mov2),
+			cpu_to_le32(br)
+	};
+
+	return (u64)&el1_plt[i];
+}
+
+u64 __hyp_text el2_module_emit_plt_entry(struct el2_mod_info *mod, void *loc, const Elf64_Rela *rela,
+			  Elf64_Sym *sym, bool in_init)
+{
+	struct mod_plt_sec *pltsec = in_init? &mod->arch->init :
+	 						  &mod->arch->core;
+
+	/* Maybe fix this by storing earlier */
+	struct elf_shdr *plt_hdr = (struct elf64_shdr *)el1_va_to_el2(pltsec->plt);
+	struct plt_entry *el1_plt = (struct plt_entry *)plt_hdr->sh_addr;
+	struct plt_entry *plt = (struct plt_entry *)el1_va_to_el2((void *)el1_plt);
+
+	int i = pltsec->plt_num_entries;
+	u64 val = sym->st_value + rela->r_addend;
+
+	plt[i] = el2_get_plt_entry(val);
+
+	/*
+	 * Check if the entry we just created is a duplicate. Given that the
+	 * relocations are sorted, this will be the last entry we allocated.
+	 * (if one exists).
+	 *
+	 * Since we don't know either (plt + i) or (plt + i - 1) not on the
+	 * same page as plt, just proceed with it...
+	 */
+	struct plt_entry *plt_i = (struct plt_entry *)el1_va_to_el2((void *)(el1_plt + i));
+	struct plt_entry *plt_ii = (struct plt_entry *)el1_va_to_el2((void *)(el1_plt + i - 1));
+	if (i > 0 && el2_plt_entries_equal(plt_i, plt_ii))
+		return (u64)&el1_plt[i - 1];
+
+	pltsec->plt_num_entries++;
+	if (pltsec->plt_num_entries > pltsec->plt_max_entries)
+		return 0;
+
+	return (u64)&el1_plt[i];
+}
+
+
+u32 __hyp_text find_sec(struct el2_mod_info *mod, const char *name)
+{
+	unsigned int i;
+
+	for (i = 1; i < mod->hdr->e_shnum; i++) {
+		Elf_Shdr *shdr = &mod->sechdrs[i];
+		/* Alloc bit cleared means "ignore it." */
+		if (!el2_strcmp(mod->secstring + shdr->sh_name, name))
+			return i;
+	}
+	return 0;
+}
+
+bool __hyp_text el2_find_symbol(struct find_symbol_arg *fsa)
+{	
+	int i,j ;
+	u32 max_modid;
+	struct el2_mod_tabs *mod_symtab;
+
+	const struct ksym_tab ksymtab =  get_kernel_symtab();
+
+	const struct symsearch arr[] = {
+		{ __el2_va(ksymtab.start_ksymtab), __el2_va(ksymtab.stop_ksymtab), NULL,
+		  NOT_GPL_ONLY, false },
+		{ __el2_va(ksymtab.start_ksymtab_gpl), __el2_va(ksymtab.stop_ksymtab_gpl), NULL,
+		  GPL_ONLY, false },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(arr); i++)
+		if (el2_find_symbol_in_section(&arr[i], fsa))
+			return true;
+
+	for (i = 0; i < EL2_MOD_INFO_SIZE; i++) {
+		if (get_mod_in_use(i)) {
+			mod_symtab = (struct el2_mod_tabs *)get_mod_tab(i);
+			struct symsearch arr[] = {
+				{ mod_symtab->syms, mod_symtab->syms + mod_symtab->num_syms,
+						NULL, NOT_GPL_ONLY, false },
+				{ mod_symtab->gpl_syms, mod_symtab->gpl_syms + mod_symtab->num_gpl_syms,
+						NULL, GPL_ONLY, false },
+			};
+
+			for (j = 0; j < ARRAY_SIZE(arr); j++)
+				if (el2_find_symbol_in_section(&arr[j], fsa))
+					return true;
+		}
+	}
+
+	return false;
+}
+
+
+int __hyp_text el2_reloc_data(enum aarch64_reloc_op op, void *place, u64 el1_place, u64 val, int len)
+{
+	s64 sval = el2_do_reloc(op, el1_place, val);
+
+	switch (len) {
+	case 16:
+		*(s16 *)place = sval;
+		if (sval < S16_MIN || sval > U16_MAX)
+			return -ERANGE;
+		break;
+	case 32:
+		*(s32 *)place = sval;
+		if (sval < S32_MIN || sval > U32_MAX)
+			return -ERANGE;
+		break;
+	case 64:
+		*(s64 *)place = sval;
+		break;
+	default:
+		return 0;
+	}
+	return 0;
+}
+
+u64 __hyp_text get_page_entry(u64 el1_base)
+{
+	
+	u64 ttbr, idx, ptr, entry, pt_leaf;
+	u64 pfn, kpt_index; 
+
+	pt_leaf = 1; 
+
+	ttbr = read_sysreg(ttbr1_el1) & ((1UL << 40UL) - 1UL); 
+	idx = pgd_idx(el1_base) * sizeof(pgd_t);
+	ptr = ttbr | idx;
+	entry = pt_load(COREVISOR, ptr);  
+	
+	ptr = phys_page(entry); 
+	idx = pud_idx(el1_base) * sizeof(pud_t); 
+	ptr |= idx; 
+	entry = pt_load(COREVISOR, ptr); 
+	pt_leaf = entry & TYPE_BIT_MASK;
+	if (!pt_leaf)
+		return ptr; 
+
+	ptr = phys_page(entry); 
+	idx = pmd_idx(el1_base) * sizeof(pmd_t); 
+	ptr |= idx; 
+	entry = pt_load(COREVISOR, ptr); 
+	pt_leaf = entry & TYPE_BIT_MASK;
+	if (!pt_leaf)
+		return ptr; 
+
+	ptr = phys_page(entry); 
+	idx = pte_idx(el1_base) * sizeof(pte_t); 
+	ptr |= idx; 
+
+	return ptr; 
+}
+
diff --git a/arch/arm64/kint/HostModuleCoreAux.c b/arch/arm64/kint/HostModuleCoreAux.c
new file mode 100644
index 00000000..b6263769
--- /dev/null
+++ b/arch/arm64/kint/HostModuleCoreAux.c
@@ -0,0 +1,245 @@
+#include "kint.h"
+
+u64 __hyp_text alloc_tmp_buffer(u64 pgnum)
+{
+	u64 buff;
+
+	buff = get_tmp_buf();
+	if (buff + pgnum * PAGE_SIZE < stage2_tmp_pgs_end)
+	{
+		el2_memset((void *)buff, 0UL, PAGE_SIZE * pgnum);
+	}
+	else
+	{
+		return INVALID_MEM;
+	}
+	return check64(buff);
+}
+
+int __hyp_text el2_cmp_name(const void *va, const void *vb)
+{
+	const char *a;
+	const struct kernel_symbol *b;
+	a = va; b = vb;
+	return el2_strcmp(a, el1_va_to_el2(b->name));
+}
+
+bool __hyp_text el2_find_symbol_in_section(const struct symsearch *syms,
+				   void *data)
+{
+	struct find_symbol_arg *fsa = data;
+	struct kernel_symbol *sym;
+
+	sym = el2_bsearch(fsa->name, syms->start, syms->stop - syms->start,
+			sizeof(struct kernel_symbol), el2_cmp_name);
+
+	if (sym != NULL) {
+		fsa->sym = &syms->start[sym - syms->start];
+		return true;
+	}
+	return false;
+}
+
+#define AARCH64_INSN_SF_BIT	BIT(31)
+#define AARCH64_INSN_N_BIT	BIT(22)
+#define AARCH64_INSN_LSL_12	BIT(22)
+
+int __hyp_text el2_aarch64_get_imm_shift_mask(enum aarch64_insn_imm_type type,
+						u32 *maskp, int *shiftp)
+{
+	u32 mask;
+	int shift;
+
+	switch (type) {
+	case AARCH64_INSN_IMM_26:
+		mask = BIT(26) - 1;
+		shift = 0;
+		break;
+	case AARCH64_INSN_IMM_19:
+		mask = BIT(19) - 1;
+		shift = 5;
+		break;
+	case AARCH64_INSN_IMM_16:
+		mask = BIT(16) - 1;
+		shift = 5;
+		break;
+	case AARCH64_INSN_IMM_14:
+		mask = BIT(14) - 1;
+		shift = 5;
+		break;
+	case AARCH64_INSN_IMM_12:
+		mask = BIT(12) - 1;
+		shift = 10;
+		break;
+	case AARCH64_INSN_IMM_9:
+		mask = BIT(9) - 1;
+		shift = 12;
+		break;
+	case AARCH64_INSN_IMM_7:
+		mask = BIT(7) - 1;
+		shift = 15;
+		break;
+	case AARCH64_INSN_IMM_6:
+	case AARCH64_INSN_IMM_S:
+		mask = BIT(6) - 1;
+		shift = 10;
+		break;
+	case AARCH64_INSN_IMM_R:
+		mask = BIT(6) - 1;
+		shift = 16;
+		break;
+	case AARCH64_INSN_IMM_N:
+		mask = 1;
+		shift = 22;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*maskp = mask;
+	*shiftp = shift;
+
+	return 0;
+}
+
+u32 __hyp_text el2_aarch64_insn_decode_register(enum aarch64_insn_register_type type,
+					u32 insn)
+{
+	int shift;
+
+	switch (type) {
+	case AARCH64_INSN_REGTYPE_RT:
+	case AARCH64_INSN_REGTYPE_RD:
+		shift = 0;
+		break;
+	case AARCH64_INSN_REGTYPE_RN:
+		shift = 5;
+		break;
+	case AARCH64_INSN_REGTYPE_RT2:
+	case AARCH64_INSN_REGTYPE_RA:
+		shift = 10;
+		break;
+	case AARCH64_INSN_REGTYPE_RM:
+		shift = 16;
+		break;
+	default:
+		return 0;
+	}
+
+	return (insn >> shift) & EL2_GENMASK(4, 0);	
+}
+
+u32 __hyp_text el2_aarch64_insn_gen_movewide(enum aarch64_insn_register dst,
+			      int imm, int shift,
+			      enum aarch64_insn_variant variant,
+			      enum aarch64_insn_movewide_type type)
+{
+	u32 insn;
+
+	switch (type) {
+	case AARCH64_INSN_MOVEWIDE_ZERO:
+		insn = aarch64_insn_get_movz_value();
+		break;
+	case AARCH64_INSN_MOVEWIDE_KEEP:
+		insn = aarch64_insn_get_movk_value();
+		break;
+	case AARCH64_INSN_MOVEWIDE_INVERSE:
+		insn = aarch64_insn_get_movn_value();
+		break;
+	default:
+		print_string("unknown movewide encoding\n");
+		return AARCH64_BREAK_FAULT;
+	}
+
+	if (imm & ~(SZ_64K - 1)) {
+		print_string("invalid immediate encoding \n");
+		return AARCH64_BREAK_FAULT;
+	}
+
+	switch (variant) {
+	case AARCH64_INSN_VARIANT_32BIT:
+		if (shift != 0 && shift != 16) {
+			print_string("invalid shift encoding \n");
+			return AARCH64_BREAK_FAULT;
+		}
+		break;
+	case AARCH64_INSN_VARIANT_64BIT:
+		insn |= AARCH64_INSN_SF_BIT;
+		if (shift != 0 && shift != 16 && shift != 32 && shift != 48) {
+			pr_err("%s: invalid shift encoding %d\n", __func__,
+			       shift);
+			return AARCH64_BREAK_FAULT;
+		}
+		break;
+	default:
+		pr_err("%s: unknown variant encoding %d\n", __func__, variant);
+		return AARCH64_BREAK_FAULT;
+	}
+
+	insn |= (shift >> 4) << 21;
+
+	insn = el2_aarch64_insn_encode_register(AARCH64_INSN_REGTYPE_RD, insn, dst);
+
+	return el2_aarch64_insn_encode_immediate(AARCH64_INSN_IMM_16, insn, imm);
+}
+
+u32 __hyp_text el2_aarch64_insn_gen_branch_imm(unsigned long pc, unsigned long addr,
+					  enum aarch64_insn_branch_type type)
+{
+	u32 insn;
+	long offset;
+
+	/*
+	 * B/BL support [-128M, 128M) offset
+	 * ARM64 virtual address arrangement guarantees all kernel and module
+	 * texts are within +/-128M.
+	 */
+	offset = el2_branch_imm_common(pc, addr, SZ_128M);
+	if (offset >= SZ_128M)
+		return AARCH64_BREAK_FAULT;
+
+	switch (type) {
+	case AARCH64_INSN_BRANCH_LINK:
+		insn = aarch64_insn_get_bl_value();
+		break;
+	case AARCH64_INSN_BRANCH_NOLINK:
+		insn = aarch64_insn_get_b_value();
+		break;
+	default:
+		print_string("unknown branch encoding \n");
+		return AARCH64_BREAK_FAULT;
+	}
+
+	return el2_aarch64_insn_encode_immediate(AARCH64_INSN_IMM_26, insn,
+					     offset >> 2);
+}
+
+
+struct plt_entry __hyp_text el2_get_plt_entry(u64 val)
+{
+	/*
+	 * MOVK/MOVN/MOVZ opcode:
+	 * +--------+------------+--------+-----------+-------------+---------+
+	 * | sf[31] | opc[30:29] | 100101 | hw[22:21] | imm16[20:5] | Rd[4:0] |
+	 * +--------+------------+--------+-----------+-------------+---------+
+	 *
+	 * Rd     := 0x10 (x16)
+	 * hw     := 0b00 (no shift), 0b01 (lsl #16), 0b10 (lsl #32)
+	 * opc    := 0b11 (MOVK), 0b00 (MOVN), 0b10 (MOVZ)
+	 * sf     := 1 (64-bit variant)
+	 */
+	return (struct plt_entry){
+		cpu_to_le32(0x92800010 | (((~val      ) & 0xffff)) << 5),
+		cpu_to_le32(0xf2a00010 | ((( val >> 16) & 0xffff)) << 5),
+		cpu_to_le32(0xf2c00010 | ((( val >> 32) & 0xffff)) << 5),
+		cpu_to_le32(0xd61f0200)
+	};
+}
+
+bool __hyp_text el2_plt_entries_equal(const struct plt_entry *a,
+				     const struct plt_entry *b)
+{
+	return a->mov0 == b->mov0 &&
+	       a->mov1 == b->mov1 &&
+	       a->mov2 == b->mov2;
+}
diff --git a/arch/arm64/kint/HostModuleExt.c b/arch/arm64/kint/HostModuleExt.c
new file mode 100644
index 00000000..f2a51b01
--- /dev/null
+++ b/arch/arm64/kint/HostModuleExt.c
@@ -0,0 +1,62 @@
+#include "kint.h"
+
+u32 __hyp_text el2_aarch64_insn_encode_register(enum aarch64_insn_register_type type,
+					u32 insn,
+					enum aarch64_insn_register reg)
+{
+	int shift;
+
+	if (insn == AARCH64_BREAK_FAULT)
+		return AARCH64_BREAK_FAULT;
+
+	if (reg < AARCH64_INSN_REG_0 || reg > AARCH64_INSN_REG_SP) {
+		print_string("\runknown register encoding\n");
+		return AARCH64_BREAK_FAULT;
+	}
+
+	switch (type) {
+	case AARCH64_INSN_REGTYPE_RT:
+	case AARCH64_INSN_REGTYPE_RD:
+		shift = 0;
+		break;
+	case AARCH64_INSN_REGTYPE_RN:
+		shift = 5;
+		break;
+	case AARCH64_INSN_REGTYPE_RT2:
+	case AARCH64_INSN_REGTYPE_RA:
+		shift = 10;
+		break;
+	case AARCH64_INSN_REGTYPE_RM:
+	case AARCH64_INSN_REGTYPE_RS:
+		shift = 16;
+		break;
+	default:
+        print_string("\runknown register type encoding\n");
+		return AARCH64_BREAK_FAULT;
+	}
+
+	insn &= ~(EL2_GENMASK(4, 0) << shift);
+	insn |= reg << shift;
+
+	return insn;
+}
+
+long __hyp_text el2_branch_imm_common(unsigned long pc, unsigned long addr,
+				     long range)
+{
+	long offset;
+
+	if ((pc & 0x3) || (addr & 0x3)) {
+		print_string("A64 instructions must be word aligned\n");
+		return range;
+	}
+
+	offset = ((long)addr - (long)pc);
+
+	if (offset < -range || offset >= range) {
+		print_string("offset out of range\n");
+		return range;
+	}
+
+	return offset;
+}
\ No newline at end of file
diff --git a/arch/arm64/kint/HostModuleOps.c b/arch/arm64/kint/HostModuleOps.c
new file mode 100644
index 00000000..0bf8cd9c
--- /dev/null
+++ b/arch/arm64/kint/HostModuleOps.c
@@ -0,0 +1,415 @@
+#include "kint.h"
+
+u32 __hyp_text init_mapping(struct el2_mod_info *mod, u64 vhdr, u64 mod_arch)
+{
+	u32 i, pgnb, err;
+	u64 hdr, size, pfn, target;
+	u64 host_perm, hyp_perm;
+
+	size = elf_size(vhdr);
+
+	pgnb = page_align(size) >> PAGE_SHIFT;
+
+	hdr = alloc_remap_addr(pgnb);
+
+	hyp_perm = pgprot_val(PAGE_HYP);
+	host_perm = pgprot_val(PAGE_S2);
+
+	for (i = 0; i < pgnb; i++) {
+		pfn = translate_to_phys(vhdr + (i * PAGE_SIZE)) / PAGE_SIZE;
+		target = hdr + i * PAGE_SIZE;
+
+		err = remap_host_mod_page(pfn, EL1_AUTH, host_perm, 3U , 0U);
+		if (err)
+			return err;
+		mmap_s2pt(COREVISOR, target, 3UL, (pfn * PAGE_SIZE) | hyp_perm);
+	}
+
+	mod->vhdr = vhdr;
+	mod->hdr = (Elf64_Ehdr *)hdr;
+	mod->size = page_align(size);
+	mod->sechdrs = (Elf64_Shdr *)((void *)mod->hdr + mod->hdr->e_shoff);
+	mod->el_diff = vhdr - hdr;
+	mod->secstring = (char *)((void *)mod->hdr +
+				  mod->sechdrs[mod->hdr->e_shstrndx].sh_offset);
+	mod->index.sym = 0;
+
+	mod->arch = (struct mod_arch_specific *)el1_va_to_el2(mod_arch);
+
+	return 0U;
+}
+
+void __hyp_text init_info(struct mod_sec_info *secinfo, struct el2_mod_info *mod,
+				u64 checklists, u32 entsize)
+{
+	u32 i;
+	mod->verify_size = 0;
+
+	if (entsize > mod->hdr->e_shnum)
+		return;
+
+	unsigned int *el2_checklists;
+	el2_checklists = (unsigned int *)el1_va_to_el2(checklists);
+
+	for (i = 0; i < entsize; i++)
+	{
+		if (el2_checklists[i] == 0 || el2_checklists[i] >= mod->hdr->e_shnum) {
+			mod->verify_size = 0;
+			return;
+		}
+
+		secinfo[i] = init_sec(el2_checklists[i], mod);
+		if (secinfo[i].base == 0UL) {
+			mod->verify_size = 0;
+			return;
+		}
+
+		mod->verify_size += sizeof(struct verinfo);
+		if(secinfo[i].vinfo.type != SHT_NOBITS)	// mostly plt section
+			mod->verify_size += secinfo[i].vinfo.size;
+	}
+
+	/* symbol table section should be included in verification */
+	if (mod->index.sym == 0) {
+		mod->verify_size = 0;
+		return;
+	}
+
+	/* pcpu */
+	mod->index.pcpu = find_sec(mod, ".data..percpu");
+
+	return;
+}
+
+/*
+ * Looks dirty... Reverse the role when perform write back
+ * rev == 0: addr -> buf
+ * rev == 1: buf -> addr
+ */
+void __hyp_text move_section(u64 buff, struct mod_sec_info *secinfo, u32 rev,
+				u32 start, u32 end)
+{
+	int i;
+	void *addr;
+	u64 base, size;
+	u64 aligned, size_to_write;
+	u32 vinfo_size = sizeof(struct verinfo);
+
+	for (i = start; i < end; i++) {
+
+		if (!rev) {
+			el2_memcpy((void *)buff, &secinfo[i].vinfo, vinfo_size);
+			buff += vinfo_size;
+		}
+
+		if(secinfo[i].vinfo.type == SHT_NOBITS)
+				continue;
+
+		base = secinfo[i].base;
+		size = secinfo[i].vinfo.size;
+
+		if (!rev) {
+			secinfo[i].buff_offset = buff;
+		} else {
+			buff = secinfo[i].buff_offset;
+			secinfo[i].buff_offset = INVALID64;
+		}
+
+		aligned = page_align(base);
+		size_to_write = aligned - base;
+
+		while (size > size_to_write) {
+			addr = el1_va_to_el2(base);
+			if (!rev)
+				el2_memcpy((void *)buff, addr, size_to_write);
+			else
+				el2_memcpy(addr, (void *)buff, size_to_write);
+
+			size -= size_to_write;
+			base += size_to_write;
+			buff += size_to_write;
+			size_to_write = PAGE_SIZE;
+		}
+
+		addr = el1_va_to_el2(base);
+		if (!rev)
+			el2_memcpy((void *)buff, addr, size);
+		else
+			el2_memcpy(addr, (void *)buff, size);
+		buff += size;
+	}
+}
+
+u32 __hyp_text remap_and_rewrite(u64 base, u64 size, u32 owner,
+				struct mod_sec_info *secinfo, u32 start, u32 end)
+{
+	u64 perm;
+	u32 page_nb, ret;
+
+	/* FIXME: 4KB page from now */
+	u64 ex_perm = pgprot_val(PAGE_S2_KCODE);
+	/* FIXME: temprorary marked as RW */
+	u64 ro_perm = pgprot_val(PAGE_S2_KERNEL);
+
+	perm = (owner == EL1_MOD_txt)? ex_perm : ro_perm;
+	page_nb = page_align(size) >> PAGE_SHIFT;
+
+	/* remmap */
+	ret = remap_host_mod_page_range(base, page_nb, owner, perm, 3U, 1U);
+	if (ret == V_INVALID)
+		return ret;
+
+	/* rewrite */
+	move_section(0UL, secinfo, 1U, start, end);
+
+	return 0;
+}
+
+
+u32 __hyp_text update_section(struct el2_mod_info *mod, 
+				struct mod_sec_info *secinfo, u64 buff, u32 entsize)
+{
+	/*
+	 * Checklists
+	 * +------+--------+-----------+-------------+--------------+
+	 * | text | rodata | init text | init rodata | rela_section |
+	 * +------+--------+-----------+-------------+--------------+
+	 * In this case, we may only need to check execution permission.
+	 * Note that we must do verification before rewrite the sections,
+	 * so that we can truely remap the pages and assign the subowner.
+	 */
+	u32 ret, start, end, i, owner;
+	u64 mask;
+
+	static unsigned long const ex_mask = SHF_EXECINSTR | SHF_ALLOC;
+	static unsigned long const ro_mask = SHF_ALLOC;
+	struct el2_mod_sec *s = &mod->mod_section;
+
+	start = 0;
+
+	u64 *secptrs[3][2] = {
+		{ &s->text_base, &s->text_size },
+		{ &s->ro_base, &s->ro_size },
+		{ &s->init_text_base, &s->init_text_size }
+		// { &s->init_ro_base, &s->init_ro_size }
+	};
+
+
+	for (i = 0; i < 3; i++) {
+
+		mask = (i % 2 == 0)? ex_mask : ro_mask;
+		owner = (i % 2 == 0)? EL1_MOD_txt : EL1_MOD_ro;
+
+		/* check */
+		end = get_offset_check(secinfo, secptrs[i][0], secptrs[i][1],
+						mask, &start, entsize);
+		if (end == V_INVALID) {
+			return ret;
+		}
+
+		/* remmap and rewrite */
+		if (*secptrs[i][0] != 0UL && start < end) {
+			ret = remap_and_rewrite(*secptrs[i][0], *secptrs[i][1],
+							owner, secinfo, start, end);
+			if (ret == V_INVALID) {
+				return end;
+			}
+			start = end;
+		}
+	}
+
+	return 0;
+}
+
+
+int __hyp_text simplify_symbol(struct el2_mod_info *mod,
+				u64 mod_percpu)
+{
+	Elf_Shdr *symsec = &mod->sechdrs[mod->index.sym];
+	Elf_Sym *sym = (Elf_Sym *)el1_va_to_el2((u64)symsec->sh_addr);
+	unsigned long secbase;
+	unsigned int i;
+	const struct kernel_symbol *ksym;
+
+	for (i = 1; i < symsec->sh_size / sizeof(Elf_Sym); i++) {
+		const char *name = mod->strtab + sym[i].st_name;
+
+		switch (sym[i].st_shndx) {
+		case SHN_COMMON: 
+		case SHN_ABS:
+		case SHN_LIVEPATCH:
+			break;
+		case SHN_UNDEF:
+			ksym = el2_resolve_symbol(name);
+			/* Ok if resolved.  */
+			if (ksym && !IS_ERR(ksym)) {
+				sym[i].st_value = ksym->value;
+				break;
+			}
+
+			if (!ksym && ELF_ST_BIND(sym[i].st_info) == STB_WEAK)
+					break;
+
+			print_string("Unknown symbol\n");
+			return -1;
+
+		default:
+			/* Divert to percpu allocation if a percpu var. */
+			if (sym[i].st_shndx == mod->index.pcpu)
+				secbase = mod_percpu;
+			else
+				secbase = mod->sechdrs[sym[i].st_shndx].sh_addr;
+			sym[i].st_value += secbase;
+			break;
+		}
+	}
+	return 0;
+}
+
+int __hyp_text relocate(struct el2_mod_info *mod)
+{
+	u32 i;
+	int err = 0;
+
+	for (i = 0; i < mod->hdr->e_shnum; i++) {
+		unsigned int infosec = mod->sechdrs[i].sh_info;
+		/* Not a valid relocation section? */
+		if (infosec >= mod->hdr->e_shnum)
+			continue;
+
+		/* Don't bother with non-allocated sections */
+		if (!(mod->sechdrs[infosec].sh_flags & SHF_ALLOC))
+			continue;
+
+		/* Livepatch relocation sections are applied by livepatch */
+		if (mod->sechdrs[i].sh_flags & SHF_RELA_LIVEPATCH)
+			continue;
+
+		if (mod->sechdrs[i].sh_type == SHT_REL)
+			continue;
+
+		else if (mod->sechdrs[i].sh_type == SHT_RELA)
+			err = apply_relocate_add_el2(mod, i);
+
+		if (err < 0)
+			break;
+	}
+
+	return err;
+}
+
+u32 __hyp_text el2_fill_symtab(struct el2_mod_info *mod, u64 checklists, u32 entsize)
+{
+	u32 i;
+	unsigned int *el2_checklists;
+
+	el2_checklists = (unsigned int *)el1_va_to_el2(checklists);
+
+	/* exported ksymtab */
+	for (i = 1; i < entsize; i++)
+	{
+		Elf64_Shdr *shdr = &mod->sechdrs[i];
+		if ((shdr->sh_flags & SHF_WAX) == SHF_ALLOC) /* read-only */
+		{
+			if(!el2_strcmp(mod->secstring + shdr->sh_name, "__ksymtab"))
+			{
+				mod->mod_symtab.syms = el1_va_to_el2(shdr->sh_addr);
+				mod->mod_symtab.num_syms = shdr->sh_size;
+
+				if (shdr->sh_size > PAGE_SIZE) {
+					/* FIXME: maximum only 1 page from now */
+					return V_INVALID;
+				}
+			}
+			else if(!el2_strcmp(mod->secstring + shdr->sh_name, "__ksymtab_gpl"))
+			{
+				mod->mod_symtab.gpl_syms = el1_va_to_el2(shdr->sh_addr);
+				mod->mod_symtab.num_gpl_syms = shdr->sh_size;
+
+				if (shdr->sh_size > PAGE_SIZE) {
+					/* FIXME: maximum only 1 page from now */
+					return V_INVALID;
+				}
+			}
+		}
+	}
+	return 0U;
+}
+
+void __hyp_text update_ex_perm(struct el2_mod_info *mod)
+{
+	u32 init_page, text_page, ro_page;
+	u64 init_base, init_size, text_base, text_size, ro_base, ro_size;
+
+	init_base = mod->mod_section.init_text_base;
+	init_size = mod->mod_section.init_text_size;
+	init_page = page_align(init_size) / PAGE_SIZE;
+
+	text_base = mod->mod_section.text_base;
+	text_size = mod->mod_section.text_size;
+	text_page = page_align(text_size) / PAGE_SIZE;
+
+	mark_ex(init_base, init_page, 1U);
+	mark_ex(text_base, text_page, 1U);
+}
+
+void __hyp_text refund_rw_perm(struct el2_mod_info *mod,
+		struct mod_sec_info *secinfo, u32 entsize)
+{
+	u64 perm;
+	u32 page_nb, i;
+
+	perm = pgprot_val(PAGE_S2_KERNEL);
+	page_nb = page_align(mod->size) >> PAGE_SHIFT;
+
+	/* Temporary Image */
+	remap_host_mod_page_range(mod->vhdr, page_nb, 0U, perm, 3U, 0U);
+
+	
+	/* Final Image */
+	for (i = 0; i < entsize; i++) {
+		if (secinfo[i].buff_offset != INVALID64
+			&& !within_temporary_image(mod, secinfo[i].base, secinfo[i].vinfo.size))
+		{
+			page_nb = page_align(secinfo[i].vinfo.size) >> PAGE_SHIFT;
+			remap_host_mod_page_range(secinfo[i].base, page_nb, 0U, perm, 3U, 0U);
+		}
+	}
+}
+
+void __hyp_text mark_rw_nx(u32 mod_idx, u32 is_init)
+{
+	struct el2_mod *info;
+	u64 text_base, text_size;
+	u64 ro_base, ro_size;
+	u32 ro_page, text_page;
+
+	info = (struct el2_mod *)get_mod_ref(mod_idx);
+
+	if (is_init) {
+		text_base = info->mod_sec.init_text_base;
+		text_size = info->mod_sec.init_text_size;
+		text_page = page_align(text_size) / PAGE_SIZE;
+	} else {
+		text_base = info->mod_sec.text_base;
+		text_size = info->mod_sec.text_size;
+		text_page = page_align(text_size) / PAGE_SIZE;
+	}
+	// Add in init RO for this 
+	// ro_base = info->mod_sec.ro_base;
+	// ro_size = info->mod_sec.ro_size;
+	// ro_page = page_align(ro_size) / PAGE_SIZE;
+
+	mark_ex(text_base, text_page, 0U);
+	refund_host_mod_page(text_base, text_page);
+	// refund_host_mod_page(ro_base, ro_page);
+}
+
+void __hyp_text remove_mod(u32 mod_idx)
+{
+	struct el2_mod *info;
+
+	info = (struct el2_mod *)get_mod_ref(mod_idx);
+	el2_memset(info, 0, sizeof(struct el2_mod));
+}
+
diff --git a/arch/arm64/kint/HostPageMgmt.c b/arch/arm64/kint/HostPageMgmt.c
new file mode 100644
index 00000000..f5e631f7
--- /dev/null
+++ b/arch/arm64/kint/HostPageMgmt.c
@@ -0,0 +1,162 @@
+#include "kint.h"
+
+u32 __hyp_text get_pfn_subowner(u64 pfn)
+{
+       u64 index;
+       u32 ret;
+
+       index = get_s2_page_index(pfn * PAGE_SIZE);
+       if (index != INVALID64)
+       {
+               ret = get_s2_page_subid(index);
+       }
+       else
+       {
+               ret = INVALID_MEM;
+       }
+       return check(ret);
+}
+
+void __hyp_text set_pfn_subowner(u64 pfn, u32 subid)
+{
+       u64 index;
+
+       index = get_s2_page_index(pfn * PAGE_SIZE);
+       if (index != INVALID64)
+       {
+            set_s2_page_subid(index, subid);
+       }
+	   else
+	   {
+			print_string("\rcould not set subowner\n");
+	   }
+}
+
+void __hyp_text set_pfn_subcount(u64 pfn, u32 subcount)
+{
+    u64 index;
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+	if (index != INVALID64)
+    {
+        set_s2_page_subcount(index, subcount);
+    }
+}
+
+u32 __hyp_text get_pfn_subcount(u64 pfn)
+{
+	u64 index;
+    u32 ret;
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+    if (index != INVALID64)
+    {
+
+		ret = get_s2_page_subcount(index);
+    }
+    else
+    {
+    	ret = INVALID_MEM;
+    }
+    return check(ret);
+}
+
+void __hyp_text set_pfn_kpt_index(u64 pfn, u64 kpt_index)
+{
+    u64 index;
+
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+	if (index != INVALID64)
+    {
+        set_s2_page_kpt_index(index, kpt_index);
+    }
+}
+
+u64 __hyp_text get_pfn_kpt_index(u64 pfn)
+{
+	u64 index;
+    u64 ret;
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+    if (index != INVALID64)
+    {
+
+		ret = get_s2_page_kpt_index(index);
+    }
+    else
+    {
+    	ret = INVALID_MEM;
+    }
+    return check64(ret);
+}
+
+void __hyp_text set_pfn_el1_va(u64 pfn, u64 el1_va)
+{
+    u64 index;
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+	if (index != INVALID64)
+    {
+        set_s2_page_el1_va(index, el1_va);
+    }
+}
+
+u64 __hyp_text get_pfn_el1_va(u64 pfn)
+{
+	u64 index;
+    u64 ret;
+
+    index = get_s2_page_index(pfn * PAGE_SIZE);
+
+    if (index != INVALID64)
+    {
+
+		ret = get_s2_page_el1_va(index);
+    }
+    else
+    {
+        ret = INVALID_MEM;
+    }
+    return check64(ret);
+}
+
+u64 __hyp_text get_pfn_s2_perm(u64 pfn, u32 lvl)
+{
+	u64 subowner, perm;
+
+	subowner = get_pfn_subowner(pfn);
+
+	if (subowner >= EL1_PGD && subowner <= EL1_PTE)
+	{
+		perm = (lvl < 3U)?
+			pgprot_val(SECT_S2) : pgprot_val(PAGE_S2);
+	}
+	else if (subowner == EL1_KCODE)
+	{
+		perm = (lvl < 3U)?
+			pgprot_val(SECT_S2_KCODE) : pgprot_val(PAGE_S2_KCODE);
+	}
+	else if (subowner == EL1_DATA)
+	{
+		perm = (lvl < 3U)?
+			pgprot_val(SECT_S2P) : pgprot_val(PAGE_S2P);
+	}
+	else if (subowner == EL1_RODATA)
+	{
+		perm = (lvl < 3U)?
+			pgprot_val(SECT_S2) : pgprot_val(PAGE_S2);
+	}
+	else
+	{
+		perm = (lvl < 3U)?
+			pgprot_val(SECT_S2_KERNEL) : pgprot_val(PAGE_S2_KERNEL);
+	}
+
+	return perm;
+}
diff --git a/arch/arm64/kint/Makefile b/arch/arm64/kint/Makefile
new file mode 100644
index 00000000..f1b3236b
--- /dev/null
+++ b/arch/arm64/kint/Makefile
@@ -0,0 +1,16 @@
+obj-y += el1_kpt.o
+obj-y += HostPageMgmt.o
+obj-y += HostKpt.o 
+obj-y += HostKptAux.o
+obj-y += HostKptCore.o
+obj-y += HostKptOps.o
+obj-y += HostKptCoreAux.o
+obj-y += HostModule.o
+obj-y += HostModuleOps.o
+obj-y += HostModuleAux.o
+obj-y += HostModuleCore.o
+obj-y += HostModuleCoreAux.o
+obj-y += HostModuleExt.o
+obj-y += Helper.o
+
+core-$(CONFIG_KERNEL_INT) += arch/arm64/kint/
diff --git a/arch/arm64/kint/el1_kpt.c b/arch/arm64/kint/el1_kpt.c
new file mode 100644
index 00000000..66431e0f
--- /dev/null
+++ b/arch/arm64/kint/el1_kpt.c
@@ -0,0 +1,279 @@
+#include "kint.h"
+
+void __hyp_text inc_subcount(u64 pfn)
+{
+	u64 prev_count, inc_count;
+	prev_count = get_pfn_subcount(pfn);
+	inc_count = prev_count + 1;
+	set_pfn_subcount(pfn, inc_count);
+}
+
+u64 __hyp_text init_set_pt_pfn_subowner(u64 entry, u32 subid)
+{
+	u64 pfn;
+	u32 owner;
+
+	pfn = phys_page(entry) >> PAGE_SHIFT;
+	owner = get_pfn_owner(pfn);
+	if (owner == HOSTVISOR)
+	{
+		set_pfn_subowner(pfn, subid);
+		inc_subcount(pfn);
+	}
+	return pfn;
+}
+
+u64 __hyp_text init_set_section_subowner(u64 entry, u32 subid)
+{
+	u64 pfn;
+	u32 owner, subowner;
+
+	pfn = phys_page(entry) >> PAGE_SHIFT;
+	owner = get_pfn_owner(pfn);
+	subowner = get_pfn_subowner(pfn);
+	if (owner == HOSTVISOR)
+	{	
+		if (!is_kpt(subowner))
+		{
+			set_pfn_subowner(pfn, subid);
+		}
+	}
+	return pfn;
+}
+
+u32 __hyp_text is_kcode(u64 entry, u64 size)
+{	
+	u64 pfn, i, start, end;
+	u32 subowner;
+
+	pfn = entry; 
+
+	start = get_text();
+	end = get_etext();
+
+	for (i = 0; i < (size >> 12); i++)
+	{
+		pfn = entry + i * PAGE_SIZE;
+		subowner = get_pfn_subowner(pfn >> 12);
+		
+		if (subowner != EL1_KCODE)
+		{
+			return 0; 
+		}
+	}
+	
+	return 1; 
+}
+
+
+
+#if 1
+void __hyp_text check_if_pte(u64 pte)
+{
+	int i;
+	u32 subid;
+	u64 ptr, page_des, pfn, count, kpt_index;
+
+	kpt_index = get_pfn_kpt_index((pte >> PAGE_SHIFT));
+
+	for (i = 0; i < PTRS_PER_PTE; i++) {
+		ptr = pte + (i * sizeof(pte_t));
+		page_des = pt_load(COREVISOR, ptr);
+
+		if (page_des)
+		{	
+			pfn = phys_page(page_des) >> 12;
+			subid = get_pfn_subowner(pfn);
+			kpt_index |= i << PTE_SHIFT; 
+			set_pfn_kpt_index(pfn, kpt_index); 
+			set_pfn_el1_va(pfn, kpt_index);
+			if (subid != EL1_KCODE && subid != EL1_INIT)
+			{
+				pt_store(COREVISOR, ptr, page_des | DCPTR_EL1_PXN_BLOCK_MASK);
+			} else {
+				pt_store(COREVISOR, ptr, page_des | DCPTR_EL1_XN_BLOCK_MASK);
+			}
+			inc_subcount(pfn);
+		}
+	}
+}
+#endif
+
+void __hyp_text walk_and_set_el1_pmd(u64 pmd)
+{
+	u64 pmde, pte, pmdp, i, pfn, kpt_index;
+
+	kpt_index = get_pfn_kpt_index((pmd >> PAGE_SHIFT));
+	for (i = 0; i < PTRS_PER_PMD; i++) {
+
+		pmdp = pmd + (i * sizeof(pmd_t));
+		pmde = pt_load(COREVISOR, pmdp);
+
+		if (pmde & PMD_TABLE_BIT) {
+			pte = phys_page(pmde);
+			pfn = pte >> PAGE_SHIFT;
+			kpt_index |= i << PMD_SHIFT;
+			set_pfn_kpt_index(pfn, kpt_index);
+			init_set_pt_pfn_subowner(pte, EL1_PTE);
+			check_if_pte(pte);
+		}
+		else if (pmde && !(pmde & PMD_TABLE_BIT))
+		{	
+			if (!is_kcode(phys_pmd_huge(pmde), HUGE_PMD_SIZE)
+				&& !(pmde & DCPTR_EL1_PXN_BLOCK_MASK))
+			{
+				pt_store(COREVISOR, pmdp, pmde | DCPTR_EL1_PXN_BLOCK_MASK);
+			}
+		}
+	}
+}
+
+void __hyp_text walk_and_set_el1_pud(u64 pud)
+{
+	u64 pude, pmd, pudp, pfn, kpt_index, i;
+
+	kpt_index = get_pfn_kpt_index((pud >> PAGE_SHIFT));
+	for (i = 0; i < PTRS_PER_PUD; i++) {
+		pudp = pud + (i * sizeof(pud_t));
+		pude = pt_load(COREVISOR, pudp);
+
+		if (pude & PUD_TABLE_BIT) {
+			pmd = phys_page(pude);
+			pfn = pmd >> PAGE_SHIFT;
+			kpt_index = kpt_index | (i << PUD_SHIFT);
+			set_pfn_kpt_index(pfn, kpt_index);
+			init_set_pt_pfn_subowner(pmd, EL1_PMD);
+			walk_and_set_el1_pmd(pmd);
+		}
+		else if (pude && !(pude & PUD_TABLE_BIT)) 
+		{
+			if (!is_kcode(phys_pud_huge(pud), HUGE_PUD_SIZE)
+				&& !(pude & DCPTR_EL1_PXN_BLOCK_MASK))
+			{	
+				print_string("\rPUD REWRITE\n");
+				pt_store(COREVISOR, pudp, pude | DCPTR_EL1_PXN_BLOCK_MASK);
+			}
+		}
+	}
+}
+
+void __hyp_text walk_and_set_el1_pt(u64 ttbr)
+{
+	u64 pgde, pud, pgdp, pfn;
+	u64 i;
+
+	for (i = 0; i < PTRS_PER_PGD; i++) {
+		pgdp = ttbr + (i * sizeof(pgd_t));
+		pgde = pt_load(COREVISOR, pgdp);
+		if (pgde) {
+			pud = phys_page(pgde);
+			pfn = pud >> PAGE_SHIFT;
+			set_pfn_kpt_index(pfn, i << PGD_SHIFT);
+			init_set_pt_pfn_subowner(pud, EL1_PUD);
+			walk_and_set_el1_pud(pud);
+		}
+	}
+	return;
+}
+
+void __hyp_text init_init_sec(void)
+{
+	u64 start, end, diff, i;
+	start = get_inittext_begin() >> 12;
+	end = get_inittext_end() >> 12;
+
+	diff = end - start; 
+
+	for (i = 0; i < diff; i++)
+	{	
+		init_set_section_subowner((start + i) << 12, EL1_INIT); 
+	}
+}
+
+void __hyp_text init_text(void)
+{
+	u64 start, end, diff, i;
+	start = get_text() >> 12;
+	end = get_etext() >> 12;
+
+	diff = end - start; 
+
+	for (i = 0; i < diff; i++)
+	{	
+		init_set_section_subowner((start + i) << 12, EL1_KCODE); 
+	}
+}
+
+void __hyp_text init_rodata(void)
+{
+	u64 start, end, diff, i, zero_page;
+	start = get_rodata() >> 12;
+	end = get_erodata() >> 12;
+
+	diff = end - start;
+
+	for (i = 0; i < diff; i++)
+	{
+		init_set_section_subowner((start + i) << 12, EL1_RODATA);
+	}
+
+	zero_page = get_host_zero_page();
+	init_set_section_subowner(zero_page, EL1_RODATA);
+}
+
+void __hyp_text init_data(void)
+{
+	u64 start, end, diff, i;
+	start = get_data() >> 12;
+	end = get_edata() >> 12;
+
+	diff = end - start; 
+
+	for (i = 0; i < diff; i++)
+	{	
+		init_set_section_subowner((start + i) << 12, EL1_DATA); 
+	}
+}
+
+void __hyp_text init_el1_pts(void)
+{
+	u64 ttbr, tramp;
+	ttbr = get_host_ttbr1();
+	print_string("\rTTBR\n");
+	printhex_ul(ttbr);
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	tramp = ttbr - (PAGE_SIZE + RESERVED_TTBR0_SIZE);
+#endif
+
+	acquire_lock_s2page();
+
+	init_text();
+	init_data();
+	init_init_sec();
+	init_rodata();
+	init_set_pt_pfn_subowner(ttbr, EL1_PGD);
+	walk_and_set_el1_pt(ttbr);
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	init_set_pt_pfn_subowner(tramp, EL1_PGD);
+	walk_and_set_el1_pt(tramp);
+#endif
+	release_lock_s2page();
+}
+
+void __hyp_text init_s2_page(void)
+{	
+	u64 i; 
+	u64 index; 
+	acquire_lock_s2page();
+
+	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start); 
+	for( i = 0; i < S2_PFN_SIZE; i++)
+	{
+		el2_data->s2_pages[i].subid  = 0; 
+		el2_data->s2_pages[i].subcount = 0;
+		el2_data->s2_pages[i].dynamic = 0;
+		el2_data->s2_pages[i].kpt_index = 0;
+		el2_data->s2_pages[i].el1_va = 0;
+	}
+	release_lock_s2page();
+}
diff --git a/arch/arm64/kint/kint.h b/arch/arm64/kint/kint.h
new file mode 100644
index 00000000..5494b2ce
--- /dev/null
+++ b/arch/arm64/kint/kint.h
@@ -0,0 +1,373 @@
+#include "../sekvm/hypsec.h"
+#include "../sekvm/MmioOps.h"
+
+#define STXR_OPCODE_MASK 0xFFE08000
+#define STXR_OPCODE1 0x88000000
+#define STXR_OPCODE2 0xC8000000
+/* FIXME: hardcoded for inst 'stp xzr, xzr, [x[0:31], #0]'*/
+#define STP_XZR_MASK 0xFFFFFC1F
+#define STP_XZR_INST 0xA9007C1F
+/* FIXME: 'stp' instruction only when 'wback = false && imm7 == 0' from now'*/
+#define STP_OPCODE_MASK 0xFFFF8000
+#define STP_OPCODE 0xA9000000
+
+#define offset_shift (12)
+#define offset_mask ((UL(1) << offset_shift) - 1)
+
+#define TYPE_BIT_SHIFT 1
+#define TYPE_BIT_MASK (UL(0x1) << TYPE_BIT_SHIFT)
+
+#define ESR_EL2_ISV_SHIFT 24
+#define ESR_EL2_ISV_MASK (UL(0x1) << ESR_EL2_ISV_SHIFT)
+
+#define DCPTR_EL1_TB_SHIFT (1)
+#define DCPTR_EL1_TB_MASK (UL(0x1) << DCPTR_EL1_TB_SHIFT)
+
+#define STXR_Rt_SHIFT 0
+#define STXR_Rt_MASK (UL(0x1F) << STXR_Rt_SHIFT)
+
+#define STXR_Rs_SHIFT 16
+#define STXR_Rs_MASK (UL(0x1F) << STXR_Rs_SHIFT)
+
+#define STXR_Rn_SHIFT 5
+#define STXR_Rn_MASK (UL(0x1F) << STXR_Rn_SHIFT)
+
+#define STP_Rt_SHIFT 0
+#define STP_Rt_MASK (UL(0x1F) << STP_Rt_SHIFT)
+
+#define STP_Rt2_SHIFT 10
+#define STP_Rt2_MASK (UL(0x1F) << STP_Rt2_SHIFT)
+
+#define DCPTR_EL1_AP_TABLE_SHIFT (61)
+#define DCPTR_EL1_AP_TABLE_MASK (UL(3) << DCPTR_EL1_AP_TABLE_SHIFT)
+
+#define DCPTR_EL1_XN_TABLE_SHIFT (60)
+#define DCPTR_EL1_XN_TABLE_MASK (UL(1) << DCPTR_EL1_XN_TABLE_SHIFT)
+
+#define DCPTR_EL1_PXN_TABLE_SHIFT (59)
+#define DCPTR_EL1_PXN_TABLE_MASK (UL(1) << DCPTR_EL1_PXN_TABLE_SHIFT)
+
+#define DCPTR_EL1_AP_BLOCK_SHIFT (6)
+#define DCPTR_EL1_AP_BLOCK_MASK (UL(0x3) << DCPTR_EL1_AP_BLOCK_SHIFT)
+
+#define DCPTR_EL1_XN_BLOCK_SHIFT (54)
+#define DCPTR_EL1_XN_BLOCK_MASK (UL(1) << DCPTR_EL1_XN_BLOCK_SHIFT)
+
+#define DCPTR_EL1_PXN_BLOCK_SHIFT (53)
+#define DCPTR_EL1_PXN_BLOCK_MASK (UL(1) << DCPTR_EL1_PXN_BLOCK_SHIFT)
+
+#define is_kpt(x) (x <= EL1_PTE && x >= EL1_PGD)
+#define is_mod(x) (x == EL1_MOD_txt || x == EL1_MOD_ro)
+
+#define points_to_table(x, y)                                                  \
+	((x >= EL1_PUD && x <= EL1_PMD && y == 1) || (x == EL1_PGD))
+
+#define points_to_leaf(x, y)                                                   \
+	((x >= EL1_PUD && x <= EL1_PMD && y == 0) || (x == EL1_PTE))
+
+#define kint_pfn_pmd(pfn) (pfn << PAGE_SHIFT) & HUGE_PMD_MASK
+#define kint_pfn_pud(pfn) (pfn << PAGE_SHIFT) & HUGE_PUD_MASK
+#define kint_mk_pmd(pfn, prot) ((kint_pfn_pmd(pfn)) | prot)
+#define kint_mk_pud(pfn, prot) ((kint_pfn_pud(pfn)) | prot)
+
+#define el2_mapped(x) (x >= 0x40040000000 && x <= 0x40140000000)
+
+#define dword_size 4
+#define qword_size 8
+#define page_align(x) ((x + PAGE_SIZE - 1UL) & ~(PAGE_SIZE - 1UL))
+#define dword_align(x) ((x + dword_size - 1UL & ~(dword_size - 1UL)))
+#define el2_align(x, a) ((x + a - 1UL & ~(a - 1UL)))
+#define el2_mod_va(x, mod) (x - mod->el_diff)
+
+#define MAX_VERIFY_SECTION_SIZE 100
+#define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
+#define EL2_GENMASK(h, l) \
+	(((~0UL) - (1UL << (l)) + 1) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+#define ELF_ST_BIND(x)		((x) >> 4)
+
+#define ADR_IMM_HILOSPLIT 2
+#define ADR_IMM_SIZE SZ_2M
+#define ADR_IMM_LOMASK ((1 << ADR_IMM_HILOSPLIT) - 1)
+#define ADR_IMM_HIMASK ((ADR_IMM_SIZE >> ADR_IMM_HILOSPLIT) - 1)
+#define ADR_IMM_LOSHIFT 29
+#define ADR_IMM_HISHIFT 5
+#define AARCH64_BREAK_MON 0xd4200000
+#define FAULT_BRK_IMM 0x100
+#define AARCH64_BREAK_FAULT (AARCH64_BREAK_MON | (FAULT_BRK_IMM << 5))
+
+#define SHF_WAX (SHF_ALLOC | SHF_EXECINSTR | SHF_WRITE)
+
+enum aarch64_insn_movw_imm_type {
+	AARCH64_INSN_IMM_MOVNZ,
+	AARCH64_INSN_IMM_MOVKZ,
+};
+
+enum aarch64_reloc_op {
+	RELOC_OP_NONE,
+	RELOC_OP_ABS,
+	RELOC_OP_PREL,
+	RELOC_OP_PAGE,
+};
+
+struct verinfo {
+	u64 size;
+	u64 flags;
+	u64 align_size;
+	u64 info;
+	u64 type;
+	u64 link;
+};
+
+struct sig_info {
+	char name[100];
+	char signature_hex[128];
+};
+
+struct mod_sec_info {
+	u64 base;
+	u64 buff_offset;
+	struct verinfo vinfo;
+};
+
+struct el2_mod_info {
+	Elf64_Ehdr *hdr;
+	Elf64_Shdr *sechdrs;
+	char *secstring;
+	char *strtab;
+	u64 el_diff;
+	u64 buff;
+	u64 size;
+	u64 verify_size;
+	u64 vhdr;
+	u32 modid;
+	// arm64 only
+	struct mod_arch_specific *arch;
+	struct el2_mod_sec mod_section;
+	struct el2_mod_tabs mod_symtab;
+	struct {
+		unsigned int sym, str, pcpu;
+	} index;
+};
+
+struct find_symbol_arg {
+	/* Input */
+	const char *name;
+	bool gplok;
+
+	/* Output */
+	const struct kernel_symbol *sym;
+};
+
+/*
+ * HostModule
+ */
+
+u32 __hyp_text verify_mod(u64 buff, size_t size, char *name);
+u32 __hyp_text gen_modid(void);
+void __hyp_text el2_get_modinfo(struct el2_mod_info *mod, char *mod_name);
+void __hyp_text el2_set_sec(struct el2_mod_info *mod);
+void __hyp_text mod_reloc_handler(u64 wdata, u64 rdata, u64 inst,  u64 addr, u64 hsr);
+
+/*
+ * HostModuleOps
+ */
+
+u32 __hyp_text init_mapping(struct el2_mod_info *mod, u64 vhdr, u64 mod_arch);
+void __hyp_text init_info(struct mod_sec_info *secinfo, struct el2_mod_info *mod,
+				u64 checklists, u32 entsize);
+void __hyp_text move_section(u64 buff, struct mod_sec_info *secinfo, u32 rev,
+				u32 start, u32 end);
+u32 __hyp_text remap_and_rewrite(u64 base, u64 size, u32 owner,
+				struct mod_sec_info *secinfo, u32 start, u32 end);
+u32 __hyp_text update_section(struct el2_mod_info *mod,
+				struct mod_sec_info *secinfo, u64 buff, u32 entsize);
+int __hyp_text simplify_symbol(struct el2_mod_info *mod,
+				u64 mod_percpu);
+int __hyp_text relocate(struct el2_mod_info *mod);
+u32 __hyp_text el2_fill_symtab(struct el2_mod_info *mod, u64 checklists, u32 entsize);
+void __hyp_text update_ex_perm(struct el2_mod_info *mod);
+
+void __hyp_text refund_rw_perm(struct el2_mod_info *mod,
+		struct mod_sec_info *secinfo, u32 entsize);
+void __hyp_text mark_rw_nx(u32 mod_idx, u32 is_init);
+void __hyp_text remove_mod(u32 mod_idx); 
+
+/*
+ * HostModuleAux
+ */
+
+u64 __hyp_text elf_size(u64 vhdr);
+bool __hyp_text within_temporary_image(struct el2_mod_info *mod, u64 addr, u64 size);
+struct mod_sec_info __hyp_text init_sec(u32 idx, struct el2_mod_info *mod);
+u32 __hyp_text remap_host_mod_page(u64 pfn, u32 owner, u64 perm, u32 level, u32 clear);
+u32 __hyp_text remap_host_mod_page_range(u64 base, u32 page_nb, u32 owner,
+				u64 perm, u32 level, u32 clear);
+u32 __hyp_text get_offset_check(struct mod_sec_info *secinfo, u64 *base, u64 *size,
+				u64 mask, u32 *start, u32 end);
+const struct kernel_symbol *__hyp_text el2_resolve_symbol(const char *name);
+
+int __hyp_text reloc_insn_movw_el2(enum aarch64_reloc_op op, __le32 *place,
+				   u64 el1_place, u64 val, int lsb,
+				   enum aarch64_insn_movw_imm_type imm_type);
+int __hyp_text reloc_insn_imm_el2(enum aarch64_reloc_op op, __le32 *place,
+				  u64 el1_place, u64 val, int lsb, int len,
+				  enum aarch64_insn_imm_type imm_type);
+u32 __hyp_text reloc_insn_adrp_el2(struct el2_mod_info *mod, __le32 *place,
+				   u64 el1_loc, u64 val, bool in_init);
+int __hyp_text apply_relocate_add_el2(struct el2_mod_info *mod, u32 relsec);
+
+void __hyp_text mark_ex(u64 base, u64 pgnb, u32 enabled_ex);
+void __hyp_text refund_host_mod_page(u64 base, u32 pgnb);
+/*
+ * HostModuleCore
+ */
+
+u32 __hyp_text find_sec(struct el2_mod_info *mod, const char *name);
+bool __hyp_text el2_find_symbol(struct find_symbol_arg *fsa);
+
+u64 __hyp_text el2_do_reloc(enum aarch64_reloc_op reloc_op, u64 place, u64 val);
+int __hyp_text el2_reloc_data(enum aarch64_reloc_op op, void *place, u64 el1_place, u64 val, int len);
+u32 __hyp_text el2_aarch64_insn_encode_immediate(
+	enum aarch64_insn_imm_type type, u32 insn, u64 imm);
+u64 __hyp_text el2_module_emit_veneer_for_adrp(struct el2_mod_info *mod, void *loc,
+					       u64 val, bool in_init);
+u64 __hyp_text el2_module_emit_plt_entry(struct el2_mod_info *mod, void *loc, const Elf64_Rela *rela,
+			  Elf64_Sym *sym, bool in_init);
+
+u64 __hyp_text get_page_entry(u64 el1_base); 
+
+/*
+ * HostModuleCoreAux
+ */
+
+u64 __hyp_text alloc_tmp_buffer(u64 pgnum);
+int __hyp_text el2_cmp_name(const void *va, const void *vb);
+bool __hyp_text el2_find_symbol_in_section(const struct symsearch *syms, void *data);
+
+int __hyp_text el2_aarch64_get_imm_shift_mask(enum aarch64_insn_imm_type type,
+					      u32 *maskp, int *shiftp);
+u32 __hyp_text el2_aarch64_insn_decode_register(enum aarch64_insn_register_type type,
+					u32 insn);
+u32 __hyp_text el2_aarch64_insn_gen_movewide(enum aarch64_insn_register dst,
+			      int imm, int shift,
+			      enum aarch64_insn_variant variant,
+			      enum aarch64_insn_movewide_type type);
+u32 __hyp_text el2_aarch64_insn_gen_branch_imm(unsigned long pc, unsigned long addr,
+					  enum aarch64_insn_branch_type type);
+struct plt_entry __hyp_text el2_get_plt_entry(u64 val);
+bool __hyp_text el2_plt_entries_equal(const struct plt_entry *a,
+				     const struct plt_entry *b);
+
+/*
+ * HostModuleExt
+ */
+
+u32 __hyp_text el2_aarch64_insn_encode_register(enum aarch64_insn_register_type type,
+					u32 insn,
+					enum aarch64_insn_register reg);
+long __hyp_text el2_branch_imm_common(unsigned long pc, unsigned long addr,
+				     long range);
+/*
+ * Helper
+ */
+
+void __hyp_text *el2_bsearch(const void *key, const void *base, size_t num,
+			     size_t size,
+			     int (*cmp)(const void *key, const void *elt));
+u64 __hyp_text el2_strcmp(const char *a, const char *b);
+u64 __hyp_text el2_strncmp(const char *s1, const char *s2, u32 n);
+u64 __hyp_text el2_strlen(const char *str); 
+char * __hyp_text el2_next_str(char *string, u64 *secsize);
+char* __hyp_text el2_strncpy(char* dest, const char* source, u32 num);
+
+/*
+ * HostKpt Functions are in hypsec.h
+ */
+
+/*
+ * HostKptOps
+ */
+
+void __hyp_text unmapping_handler(u64 rdata, u64 wdata, u64 inst,
+				  u64 fault_ipfn, u64 hsr);
+void __hyp_text mapping_handler(u64 wdata, u64 inst, u64 fault_ipfn, u64 hsr);
+void __hyp_text update_handler(u64 rdata, u64 wdata, u64 inst, u64 fault_ipfn,
+			       u64 hsr);
+
+/*
+ * HostKptAux
+ */
+
+u32 __hyp_text handle_host_update(u64 wdata, u32 inst, u64 fault_ipfn, u32 hsr);
+u32 __hyp_text handle_host_new_page(u64 pfn, u32 subid, u32 vmid);
+void __hyp_text handle_host_remove_page(u64 pfn, u32 vmid);
+void __hyp_text handle_host_leaf_update(u64 wdata, u32 w_subowner, u32 inst,
+					u64 fault_ipfn, u32 hsr);
+
+/*
+ * HostKptCore
+ */
+
+u64 __hyp_text el1_va_to_el2(u64 el1_va);
+void __hyp_text handle_host_update_write(u64 wdata, u64 fault_ipa, u32 len);
+u64 __hyp_text handle_host_update_read(u64 fault_ipa, u32 len);
+void __hyp_text stxr_write_handler(u64 wdata, u64 inst, u64 va);
+void __hyp_text stp_write_handler(u64 inst, u64 va);
+u32 __hyp_text get_kpt_shift(u32 subid);
+u32 __hyp_text check_clear_pfn_host(u64 pfn);
+u32 __hyp_text check_if_clear_range_host(u64 start, u64 size);
+
+/*
+ * HostKptCoreAux
+ */
+
+u64 __hyp_text fetch_rdata(u64 addr);
+u64 __hyp_text fetch_wdata(u64 hsr, u64 inst);
+u64 __hyp_text fetch_instruction(void);
+u32 __hyp_text stxr_write_handler_asm(u32 wdata, u64 fault_ipa);
+
+/*
+ * el1_kpt
+ */
+
+void __hyp_text init_text(void);
+void __hyp_text init_data(void);
+u64 __hyp_text init_set_section_subowner(u64 entry, u32 subid);
+u32 __hyp_text is_kcode(u64 entry, u64 size);
+
+
+static u64 inline get_kim_voff(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->kimage_voff;
+};
+
+static struct ksym_tab inline get_kernel_symtab(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->kernel_symtab;
+}
+
+static u64 inline get_mod_ref(u32 modid)
+{
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return (u64) &el2_data->mod_info[modid];
+}
+
+static bool inline get_mod_in_use(u32 modid)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->mod_info[modid].in_use;
+}
+
+static void inline set_mod_in_use(u32 modid, bool in_use)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->mod_info[modid].in_use = in_use;
+}
+
+static u64 inline get_mod_tab(u32 modid)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return &el2_data->mod_info[modid].mod_tabs;
+}
diff --git a/arch/arm64/kvm/Makefile b/arch/arm64/kvm/Makefile
index 0f2a135b..5c8ac416 100644
--- a/arch/arm64/kvm/Makefile
+++ b/arch/arm64/kvm/Makefile
@@ -20,6 +20,7 @@ kvm-$(CONFIG_KVM_ARM_HOST) += inject_fault.o regmap.o va_layout.o
 kvm-$(CONFIG_KVM_ARM_HOST) += hyp.o hyp-init.o handle_exit.o
 kvm-$(CONFIG_KVM_ARM_HOST) += guest.o debug.o reset.o sys_regs.o sys_regs_generic_v8.o
 kvm-$(CONFIG_KVM_ARM_HOST) += vgic-sys-reg-v3.o fpsimd.o
+kvm-$(CONFIG_KVM_ARM_HOST) += pt_alloc.o
 kvm-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/aarch32.o
 
 kvm-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/vgic/vgic.o
diff --git a/arch/arm64/kvm/hyp/Makefile b/arch/arm64/kvm/hyp/Makefile
index 7c5d4cf1..c301d8e2 100644
--- a/arch/arm64/kvm/hyp/Makefile
+++ b/arch/arm64/kvm/hyp/Makefile
@@ -24,6 +24,7 @@ endif
 obj-$(CONFIG_KVM_ARM_HOST) += fpsimd.o
 obj-$(CONFIG_KVM_ARM_HOST) += tlb.o
 obj-$(CONFIG_KVM_ARM_HOST) += hyp-entry.o
+obj-$(CONFIG_KVM_ARM_HOST) += vm-entry.o
 obj-$(CONFIG_KVM_ARM_HOST) += s2-setup.o
 
 # KVM code is run at a different exception code with a different map, so
diff --git a/arch/arm64/kvm/hyp/hyp-entry.S b/arch/arm64/kvm/hyp/hyp-entry.S
index 9785760b..f0d24329 100644
--- a/arch/arm64/kvm/hyp/hyp-entry.S
+++ b/arch/arm64/kvm/hyp/hyp-entry.S
@@ -77,6 +77,16 @@
 	eret
 .endm
 
+
+.macro	handle_sys64
+	save_callee_saved_regs
+	mov x1, sp
+	mov x0, lr
+    bl  handle_host_sys_regs
+	restore_callee_saved_regs
+	eret
+.endm
+
 	.align 11
 
 .macro enable_stage2_trans t0, t1
@@ -94,6 +104,7 @@
 .endm
 #endif
 
+
 .macro do_el2_call
 	/*
 	 * Shuffle the parameters before calling the function
@@ -120,39 +131,38 @@ ENTRY(__vhe_hyp_call)
 	ret
 ENDPROC(__vhe_hyp_call)
 
-el1_sync:				// Guest trapped into EL2
+/* Here, we're pretty sure the host traps from host kernel! */
+
+el1_sync:						// Host trapped into EL2
+	mrs 	x1, tpidr_el2		// Check before entry, it must be tpidr_el2 = 0 
+	cbnz 	x1, __hyp_panic
 
 	mrs	x0, esr_el2
 	lsr	x0, x0, #ESR_ELx_EC_SHIFT
 	cmp	x0, #ESR_ELx_EC_HVC64
 	ccmp	x0, #ESR_ELx_EC_HVC32, #4, ne
-#ifndef CONFIG_VERIFIED_KVM
-	b.ne	el1_trap
-
-	mrs	x1, vttbr_el2		// If vttbr is valid, the guest
-	cbnz	x1, el1_hvc_guest	// called HVC
-#else
-	b.eq	4f
-	cmp	x0, #ESR_ELx_EC_DABT_LOW
+	
+	b.eq	4f	
+	cmp x0, #ESR_ELx_EC_SYS64
 	b.eq	5f
+	cmp	x0, #ESR_ELx_EC_DABT_LOW
+	b.eq	6f
 	cmp	x0, #ESR_ELx_EC_IABT_LOW
-	b.ne	el1_trap
+	b.ne	__hyp_panic
 
-5:
-	/* if tpidr_el2 = 0, we know if traps from host kernel! */
-	mrs     x1, tpidr_el2
-	cbnz    x1, el1_trap
+6:
 
 	ldp	x0, x1,   [sp], #16
 	handle_dabt
-4:
-	mrs	x1, tpidr_el2
-	cbnz	x1, el1_hvc_guest	// called HVC
-#endif
 
-	/* Here, we're pretty sure the host called HVC. */
-	ldp	x0, x1, [sp], #16
+5:
+	
+	ldp x0, x1,	  [sp], #16
+	handle_sys64
 
+4:
+	ldp	x0, x1, [sp], #16
+	
 	cmp	x0, #HVC_GET_VECTORS
 	b.ne	2f
 	mrs	x0, vbar_el2
@@ -195,107 +205,6 @@ el1_sync:				// Guest trapped into EL2
 	eret
 #endif
 
-el1_hvc_guest:
-	/*
-	 * Fastest possible path for ARM_SMCCC_ARCH_WORKAROUND_1.
-	 * The workaround has already been applied on the host,
-	 * so let's quickly get back to the guest. We don't bother
-	 * restoring x1, as it can be clobbered anyway.
-	 */
-	ldr	x1, [sp]				// Guest's x0
-	eor	w1, w1, #ARM_SMCCC_ARCH_WORKAROUND_1
-	cbz	w1, wa_epilogue
-
-	/* ARM_SMCCC_ARCH_WORKAROUND_2 handling */
-	eor	w1, w1, #(ARM_SMCCC_ARCH_WORKAROUND_1 ^ \
-			  ARM_SMCCC_ARCH_WORKAROUND_2)
-	cbnz	w1, el1_trap
-
-#ifdef CONFIG_ARM64_SSBD
-alternative_cb	arm64_enable_wa2_handling
-	b	wa2_end
-alternative_cb_end
-	get_vcpu_ptr	x2, x0
-	ldr	x0, [x2, #VCPU_WORKAROUND_FLAGS]
-
-	// Sanitize the argument and update the guest flags
-	ldr	x1, [sp, #8]			// Guest's x1
-	clz	w1, w1				// Murphy's device:
-	lsr	w1, w1, #5			// w1 = !!w1 without using
-	eor	w1, w1, #1			// the flags...
-	bfi	x0, x1, #VCPU_WORKAROUND_2_FLAG_SHIFT, #1
-	str	x0, [x2, #VCPU_WORKAROUND_FLAGS]
-
-	/* Check that we actually need to perform the call */
-	hyp_ldr_this_cpu x0, arm64_ssbd_callback_required, x2
-	cbz	x0, wa2_end
-
-	mov	w0, #ARM_SMCCC_ARCH_WORKAROUND_2
-	smc	#0
-
-	/* Don't leak data from the SMC call */
-	mov	x3, xzr
-wa2_end:
-	mov	x2, xzr
-	mov	x1, xzr
-#endif
-
-wa_epilogue:
-	mov	x0, xzr
-	add	sp, sp, #16
-	eret
-
-el1_trap:
-#ifndef CONFIG_VERIFIED_KVM
-	get_vcpu_ptr	x1, x0
-#else
-	mrs	x1, tpidr_el2
-#endif
-	mov	x0, #ARM_EXCEPTION_TRAP
-	b	__guest_exit
-
-el1_irq:
-#ifndef CONFIG_VERIFIED_KVM
-	get_vcpu_ptr	x1, x0
-#else
-	mrs	x1, tpidr_el2
-#endif
-	mov	x0, #ARM_EXCEPTION_IRQ
-	b	__guest_exit
-
-el1_error:
-#ifndef CONFIG_VERIFIED_KVM
-	get_vcpu_ptr	x1, x0
-#else
-	mrs	x1, tpidr_el2
-#endif
-	mov	x0, #ARM_EXCEPTION_EL1_SERROR
-	b	__guest_exit
-
-el2_error:
-	ldp	x0, x1, [sp], #16
-
-	/*
-	 * Only two possibilities:
-	 * 1) Either we come from the exit path, having just unmasked
-	 *    PSTATE.A: change the return code to an EL2 fault, and
-	 *    carry on, as we're already in a sane state to handle it.
-	 * 2) Or we come from anywhere else, and that's a bug: we panic.
-	 *
-	 * For (1), x0 contains the original return code and x1 doesn't
-	 * contain anything meaningful at that stage. We can reuse them
-	 * as temp registers.
-	 * For (2), who cares?
-	 */
-	mrs	x0, elr_el2
-	adr	x1, abort_guest_exit_start
-	cmp	x0, x1
-	adr	x1, abort_guest_exit_end
-	ccmp	x0, x1, #4, ne
-	b.ne	__hyp_panic
-	mov	x0, #(1 << ARM_EXIT_WITH_SERROR_BIT)
-	eret
-
 ENTRY(__hyp_do_panic)
 	mov	lr, #(PSR_F_BIT | PSR_I_BIT | PSR_A_BIT | PSR_D_BIT |\
 		      PSR_MODE_EL1h)
@@ -311,7 +220,7 @@ ENTRY(__hyp_panic)
 ENDPROC(__hyp_panic)
 
 .macro invalid_vector	label, target = __hyp_panic
-	.align	2
+	.align 2
 \label:
 	b \target
 ENDPROC(\label)
@@ -325,22 +234,25 @@ ENDPROC(\label)
 	invalid_vector	el2h_sync_invalid
 	invalid_vector	el2h_irq_invalid
 	invalid_vector	el2h_fiq_invalid
+	invalid_vector	el2h_error_invalid
+	invalid_vector	el1_irq_invalid
 	invalid_vector	el1_fiq_invalid
-
+	invalid_vector	el1_error_invalid
+	
 	.ltorg
-
+	
 	.align 11
 
 .macro valid_vect target
 	.align 7
-	stp	x0, x1, [sp, #-16]!
+	stp x0, x1, [sp, #-16]!
 	b	\target
 .endm
 
 .macro invalid_vect target
 	.align 7
 	b	\target
-	ldp	x0, x1, [sp], #16
+	ldp x0,x1, [sp], #16
 	b	\target
 .endm
 
@@ -353,76 +265,17 @@ ENTRY(__kvm_hyp_vector)
 	invalid_vect	el2h_sync_invalid	// Synchronous EL2h
 	invalid_vect	el2h_irq_invalid	// IRQ EL2h
 	invalid_vect	el2h_fiq_invalid	// FIQ EL2h
-	valid_vect	el2_error		// Error EL2h
+	invalid_vect	el2h_error_invalid	// Error EL2h
 
-	valid_vect	el1_sync		// Synchronous 64-bit EL1
-	valid_vect	el1_irq			// IRQ 64-bit EL1
+	valid_vect		el1_sync			// Synchronous 64-bit EL1
+	invalid_vect	el1_irq_invalid		// IRQ 64-bit EL1
 	invalid_vect	el1_fiq_invalid		// FIQ 64-bit EL1
-	valid_vect	el1_error		// Error 64-bit EL1
+	invalid_vect	el1_error_invalid	// Error 64-bit EL1
 
-	valid_vect	el1_sync		// Synchronous 32-bit EL1
-	valid_vect	el1_irq			// IRQ 32-bit EL1
+	valid_vect		el1_sync			// Synchronous 32-bit EL1
+	invalid_vect	el1_irq_invalid		// IRQ 32-bit EL1
 	invalid_vect	el1_fiq_invalid		// FIQ 32-bit EL1
-	valid_vect	el1_error		// Error 32-bit EL1
+	invalid_vect	el1_error_invalid	// Error 32-bit EL1
 ENDPROC(__kvm_hyp_vector)
 
-#ifdef CONFIG_KVM_INDIRECT_VECTORS
-.macro hyp_ventry
-	.align 7
-1:	.rept 27
-	nop
-	.endr
-/*
- * The default sequence is to directly branch to the KVM vectors,
- * using the computed offset. This applies for VHE as well as
- * !ARM64_HARDEN_EL2_VECTORS.
- *
- * For ARM64_HARDEN_EL2_VECTORS configurations, this gets replaced
- * with:
- *
- * stp	x0, x1, [sp, #-16]!
- * movz	x0, #(addr & 0xffff)
- * movk	x0, #((addr >> 16) & 0xffff), lsl #16
- * movk	x0, #((addr >> 32) & 0xffff), lsl #32
- * br	x0
- *
- * Where addr = kern_hyp_va(__kvm_hyp_vector) + vector-offset + 4.
- * See kvm_patch_vector_branch for details.
- */
-alternative_cb	kvm_patch_vector_branch
-	b	__kvm_hyp_vector + (1b - 0b)
-	nop
-	nop
-	nop
-	nop
-alternative_cb_end
-.endm
-
-.macro generate_vectors
-0:
-	.rept 16
-	hyp_ventry
-	.endr
-	.org 0b + SZ_2K		// Safety measure
-.endm
-
-	.align	11
-ENTRY(__bp_harden_hyp_vecs_start)
-	.rept BP_HARDEN_EL2_SLOTS
-	generate_vectors
-	.endr
-ENTRY(__bp_harden_hyp_vecs_end)
-
 	.popsection
-
-ENTRY(__smccc_workaround_1_smc_start)
-	sub	sp, sp, #(8 * 4)
-	stp	x2, x3, [sp, #(8 * 0)]
-	stp	x0, x1, [sp, #(8 * 2)]
-	mov	w0, #ARM_SMCCC_ARCH_WORKAROUND_1
-	smc	#0
-	ldp	x2, x3, [sp, #(8 * 0)]
-	ldp	x0, x1, [sp, #(8 * 2)]
-	add	sp, sp, #(8 * 4)
-ENTRY(__smccc_workaround_1_smc_end)
-#endif
diff --git a/arch/arm64/kvm/hyp/switch-simple.c b/arch/arm64/kvm/hyp/switch-simple.c
index f0f6129e..3ed0250d 100644
--- a/arch/arm64/kvm/hyp/switch-simple.c
+++ b/arch/arm64/kvm/hyp/switch-simple.c
@@ -45,7 +45,7 @@ static void __hyp_text __deactivate_traps_common(void)
 	set_pmuserenr_el0(0);
 }
 
-static void __hyp_text __activate_traps_nvhe(struct kvm_vcpu *vcpu)
+static void __hyp_text __activate_traps_nvhe(struct kvm_vcpu *vcpu, unsigned long vm_vector_ptr)
 {
 	u64 val;
 
@@ -55,9 +55,10 @@ static void __hyp_text __activate_traps_nvhe(struct kvm_vcpu *vcpu)
 	val |= CPTR_EL2_TTA | CPTR_EL2_TZ;
 
 	set_cptr_el2(val);
+	set_vbar_el2(vm_vector_ptr);
 }
 
-static void __hyp_text __activate_traps(struct kvm_vcpu *vcpu)
+static void __hyp_text __activate_traps(struct kvm_vcpu *vcpu, unsigned long vm_vector_ptr)
 {
 	u64 hcr = HCR_HYPSEC_VM_FLAGS;
 
@@ -71,10 +72,10 @@ static void __hyp_text __activate_traps(struct kvm_vcpu *vcpu)
 
 	/* We don't support RAS_EXTN for now in HypSec */
 
-	__activate_traps_nvhe(vcpu);
+	__activate_traps_nvhe(vcpu, vm_vector_ptr);
 }
 
-static void __hyp_text __deactivate_traps_nvhe(void)
+static void __hyp_text __deactivate_traps_nvhe(unsigned long hyp_vector_ptr)
 {
 	__deactivate_traps_common();
 	/*
@@ -84,11 +85,12 @@ static void __hyp_text __deactivate_traps_nvhe(void)
 	set_mdcr_el2(0);
 
 	set_cptr_el2(CPTR_EL2_DEFAULT);
+	set_vbar_el2(hyp_vector_ptr);
 }
 
-static void __hyp_text __deactivate_traps(struct kvm_vcpu *vcpu)
+static void __hyp_text __deactivate_traps(struct kvm_vcpu *vcpu, unsigned long hyp_vector_ptr)
 {
-	__deactivate_traps_nvhe();
+	__deactivate_traps_nvhe(hyp_vector_ptr);
 }
 
 void activate_traps_vhe_load(struct kvm_vcpu *vcpu)
@@ -273,6 +275,8 @@ int __hyp_text __kvm_vcpu_run_nvhe(u32 vmid, int vcpu_id)
 	struct el2_data *el2_data;
 	struct kvm_vcpu *vcpu;
 	struct shadow_vcpu_context *prot_ctxt;
+	unsigned long hyp_vector_ptr; 
+	unsigned long vm_vector_ptr; 
 
 	/* check if vm is verified and vcpu is already active. */
 	hypsec_set_vcpu_active(vmid, vcpu_id);
@@ -285,6 +289,8 @@ int __hyp_text __kvm_vcpu_run_nvhe(u32 vmid, int vcpu_id)
 	host_ctxt = kern_hyp_va(vcpu->arch.host_cpu_context);
 	host_ctxt->__hyp_running_vcpu = vcpu;
 	shadow_ctxt = (struct kvm_cpu_context *)prot_ctxt;
+	hyp_vector_ptr = (unsigned long)kern_hyp_va(kvm_ksym_ref(__kvm_hyp_vector));
+	vm_vector_ptr = (unsigned long)kvm_get_vm_vector();
 
 	__sysreg_save_state_nvhe(host_ctxt);
 
@@ -292,7 +298,7 @@ int __hyp_text __kvm_vcpu_run_nvhe(u32 vmid, int vcpu_id)
 	//__restore_shadow_kvm_regs(vcpu, prot_ctxt);
 	restore_shadow_kvm_regs();
 
-	__activate_traps(vcpu);
+	__activate_traps(vcpu,vm_vector_ptr);
 	__activate_vm(vmid & 0xff);
 	if (vcpu->arch.was_preempted) {
 		hypsec_tlb_flush_local_vmid();
@@ -329,7 +335,7 @@ int __hyp_text __kvm_vcpu_run_nvhe(u32 vmid, int vcpu_id)
 	__timer_disable_traps(vcpu);
 	__hyp_vgic_save_state(vcpu);
 
-	__deactivate_traps(vcpu);
+	__deactivate_traps(vcpu, hyp_vector_ptr);
 	__deactivate_vm(vcpu);
 	__host_el2_restore_state(el2_data);
 
diff --git a/arch/arm64/kvm/hyp/switch-simple.h b/arch/arm64/kvm/hyp/switch-simple.h
index a614c20e..8d41e6eb 100644
--- a/arch/arm64/kvm/hyp/switch-simple.h
+++ b/arch/arm64/kvm/hyp/switch-simple.h
@@ -114,3 +114,7 @@ static void __hyp_text set_hpfar_el2(u64 val)
 	write_sysreg(val, hpfar_el2);
 }
 */
+static void __hyp_text set_vbar_el2(u64 val)
+{
+	write_sysreg(val, vbar_el2);
+}	
diff --git a/arch/arm64/kvm/hyp/vm-entry.S b/arch/arm64/kvm/hyp/vm-entry.S
new file mode 100644
index 00000000..c49db03a
--- /dev/null
+++ b/arch/arm64/kvm/hyp/vm-entry.S
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2015-2018 - ARM Ltd
+ * Author: Marc Zyngier <marc.zyngier@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/linkage.h>
+
+#include <asm/alternative.h>
+#include <asm/assembler.h>
+#include <asm/cpufeature.h>
+#include <asm/kvm_arm.h>
+#include <asm/kvm_asm.h>
+#include <asm/kvm_mmu.h>
+#include <asm/mmu.h>
+
+	.text
+	.pushsection	.hyp.text, "ax"
+	
+el1_sync:				//Here, we ensure that only guest trapped into EL2
+	
+	mrs x1, tpidr_el2
+	cbz x1, __hyp_panic
+
+	mrs	x0, esr_el2
+	lsr	x0, x0, #ESR_ELx_EC_SHIFT
+	cmp	x0, #ESR_ELx_EC_HVC64
+	ccmp	x0, #ESR_ELx_EC_HVC32, #4, ne
+#ifndef CONFIG_VERIFIED_KVM
+	b.ne	el1_trap
+
+	mrs	x1, vttbr_el2		// If vttbr is valid, the guest
+	cbnz	x1, el1_hvc_guest	// called HVC
+#else	
+	b.ne	el1_trap
+	
+	/*  tpidr_el2 always > 0 at here*/
+	mrs		x1, tpidr_el2
+	cbnz	x1, el1_hvc_guest
+
+	/* Never come in */
+	b __hyp_panic	
+#endif
+
+el1_hvc_guest:
+	/*
+	 * Fastest possible path for ARM_SMCCC_ARCH_WORKAROUND_1.
+	 * The workaround has already been applied on the host,
+	 * so let's quickly get back to the guest. We don't bother
+	 * restoring x1, as it can be clobbered anyway.
+	 */
+	ldr	x1, [sp]				// Guest's x0
+	eor	w1, w1, #ARM_SMCCC_ARCH_WORKAROUND_1
+	cbz	w1, wa_epilogue
+
+	/* ARM_SMCCC_ARCH_WORKAROUND_2 handling */
+	eor	w1, w1, #(ARM_SMCCC_ARCH_WORKAROUND_1 ^ \
+			  ARM_SMCCC_ARCH_WORKAROUND_2)
+	cbnz	w1, el1_trap
+
+#ifdef CONFIG_ARM64_SSBD
+alternative_cb	arm64_enable_wa2_handling
+	b	wa2_end
+alternative_cb_end
+	get_vcpu_ptr	x2, x0
+	ldr	x0, [x2, #VCPU_WORKAROUND_FLAGS]
+
+	// Sanitize the argument and update the guest flags
+	ldr	x1, [sp, #8]			// Guest's x1
+	clz	w1, w1				// Murphy's device:
+	lsr	w1, w1, #5			// w1 = !!w1 without using
+	eor	w1, w1, #1			// the flags...
+	bfi	x0, x1, #VCPU_WORKAROUND_2_FLAG_SHIFT, #1
+	str	x0, [x2, #VCPU_WORKAROUND_FLAGS]
+
+	/* Check that we actually need to perform the call */
+	hyp_ldr_this_cpu x0, arm64_ssbd_callback_required, x2
+	cbz	x0, wa2_end
+
+	mov	w0, #ARM_SMCCC_ARCH_WORKAROUND_2
+	smc	#0
+
+	/* Don't leak data from the SMC call */
+	mov	x3, xzr
+wa2_end:
+	mov	x2, xzr
+	mov	x1, xzr
+#endif
+
+wa_epilogue:
+	mov	x0, xzr
+	add	sp, sp, #16
+	eret
+
+el1_trap:
+#ifndef CONFIG_VERIFIED_KVM
+	get_vcpu_ptr	x1, x0
+#else
+	mrs	x1, tpidr_el2
+#endif
+	mov	x0, #ARM_EXCEPTION_TRAP
+	b	__guest_exit
+
+el1_irq:
+#ifndef CONFIG_VERIFIED_KVM
+	get_vcpu_ptr	x1, x0
+#else
+	mrs	x1, tpidr_el2
+#endif
+	mov	x0, #ARM_EXCEPTION_IRQ
+	b	__guest_exit
+
+el1_error:
+#ifndef CONFIG_VERIFIED_KVM
+	get_vcpu_ptr	x1, x0
+#else
+	mrs	x1, tpidr_el2
+#endif
+	mov	x0, #ARM_EXCEPTION_EL1_SERROR
+	b	__guest_exit
+
+el2_error:
+	ldp	x0, x1, [sp], #16
+
+	/*
+	 * Only two possibilities:
+	 * 1) Either we come from the exit path, having just unmasked
+	 *    PSTATE.A: change the return code to an EL2 fault, and
+	 *    carry on, as we're already in a sane state to handle it.
+	 * 2) Or we come from anywhere else, and that's a bug: we panic.
+	 *
+	 * For (1), x0 contains the original return code and x1 doesn't
+	 * contain anything meaningful at that stage. We can reuse them
+	 * as temp registers.
+	 * For (2), who cares?
+	 */
+	mrs	x0, elr_el2
+	adr	x1, abort_guest_exit_start
+	cmp	x0, x1
+	adr	x1, abort_guest_exit_end
+	ccmp	x0, x1, #4, ne
+	b.ne	__hyp_panic
+	mov	x0, #(1 << ARM_EXIT_WITH_SERROR_BIT)
+	eret
+
+
+.macro invalid_vector	label, target = __hyp_panic
+	.align	2
+\label:
+	b \target
+ENDPROC(\label)
+.endm
+
+	/* None of these should ever happen */
+	invalid_vector	el2t_sync_invalid
+	invalid_vector	el2t_irq_invalid
+	invalid_vector	el2t_fiq_invalid
+	invalid_vector	el2t_error_invalid
+	invalid_vector	el2h_sync_invalid
+	invalid_vector	el2h_irq_invalid
+	invalid_vector	el2h_fiq_invalid
+	invalid_vector	el1_fiq_invalid
+
+	.ltorg
+
+	.align 11
+
+.macro valid_vect target
+	.align 7
+	stp	x0, x1, [sp, #-16]!
+	b	\target
+.endm
+
+.macro invalid_vect target
+	.align 7
+	b	\target
+	ldp	x0, x1, [sp], #16
+	b	\target
+.endm
+
+ENTRY(__kvm_vm_vector)
+	invalid_vect	el2t_sync_invalid	// Synchronous EL2t
+	invalid_vect	el2t_irq_invalid	// IRQ EL2t
+	invalid_vect	el2t_fiq_invalid	// FIQ EL2t
+	invalid_vect	el2t_error_invalid	// Error EL2t
+
+	invalid_vect	el2h_sync_invalid	// Synchronous EL2h
+	invalid_vect	el2h_irq_invalid	// IRQ EL2h
+	invalid_vect	el2h_fiq_invalid	// FIQ EL2h
+	valid_vect	el2_error		// Error EL2h
+
+	valid_vect	el1_sync		// Synchronous 64-bit EL1
+	valid_vect	el1_irq			// IRQ 64-bit EL1
+	invalid_vect	el1_fiq_invalid		// FIQ 64-bit EL1
+	valid_vect	el1_error		// Error 64-bit EL1
+
+	valid_vect	el1_sync		// Synchronous 32-bit EL1
+	valid_vect	el1_irq			// IRQ 32-bit EL1
+	invalid_vect	el1_fiq_invalid		// FIQ 32-bit EL1
+	valid_vect	el1_error		// Error 32-bit EL1
+ENDPROC(__kvm_vm_vector)
+
+#ifdef CONFIG_KVM_INDIRECT_VECTORS
+.macro hyp_ventry
+	.align 7
+1:	.rept 27
+	nop
+	.endr
+/*
+ * The default sequence is to directly branch to the KVM vectors,
+ * using the computed offset. This applies for VHE as well as
+ * !ARM64_HARDEN_EL2_VECTORS.
+ *
+ * For ARM64_HARDEN_EL2_VECTORS configurations, this gets replaced
+ * with:
+ *
+ * stp	x0, x1, [sp, #-16]!
+ * movz	x0, #(addr & 0xffff)
+ * movk	x0, #((addr >> 16) & 0xffff), lsl #16
+ * movk	x0, #((addr >> 32) & 0xffff), lsl #32
+ * br	x0
+ *
+ * Where addr = kern_hyp_va(__kvm_hyp_vector) + vector-offset + 4.
+ * See kvm_patch_vector_branch for details.
+ */
+alternative_cb	kvm_patch_vector_branch
+	b	__kvm_hyp_vector + (1b - 0b)
+	nop
+	nop
+	nop
+	nop
+alternative_cb_end
+.endm
+
+.macro generate_vectors
+0:
+	.rept 16
+	hyp_ventry
+	.endr
+	.org 0b + SZ_2K		// Safety measure
+.endm
+
+	.align	11
+ENTRY(__bp_harden_hyp_vecs_start)
+	.rept BP_HARDEN_EL2_SLOTS
+	generate_vectors
+	.endr
+ENTRY(__bp_harden_hyp_vecs_end)
+
+	.popsection
+
+ENTRY(__smccc_workaround_1_smc_start)
+	sub	sp, sp, #(8 * 4)
+	stp	x2, x3, [sp, #(8 * 0)]
+	stp	x0, x1, [sp, #(8 * 2)]
+	mov	w0, #ARM_SMCCC_ARCH_WORKAROUND_1
+	smc	#0
+	ldp	x2, x3, [sp, #(8 * 0)]
+	ldp	x0, x1, [sp, #(8 * 2)]
+	add	sp, sp, #(8 * 4)
+ENTRY(__smccc_workaround_1_smc_end)
+#endif
diff --git a/arch/arm64/kvm/pt_alloc.c b/arch/arm64/kvm/pt_alloc.c
new file mode 100644
index 00000000..3ac659dc
--- /dev/null
+++ b/arch/arm64/kvm/pt_alloc.c
@@ -0,0 +1,550 @@
+#include <asm/kvm_hyp.h>
+#include <asm/kvm_mmu.h>
+#include <asm/page.h>
+
+#include <linux/spinlock.h>
+#include <linux/kvm_host.h>
+#include <linux/memblock.h>
+#include <linux/types.h>
+
+
+#define HYP_NO_ORDER	USHRT_MAX
+
+/*
+ * FIXME: It would be better to add an extra header file
+ * and migrate some code to another locations
+ */
+
+struct hyp_page {
+	unsigned short refcount;
+	unsigned short order;
+};
+
+/* reserved memory base */
+u64 host_s1_mem_base;
+u64 host_s1_mem_size;
+static u64 host_s1_mem_pfn;
+
+/* reserved memory region for kernel page table */
+u64 host_s1_pgtable_mem_base;
+u64 host_s1_pgtable_mem_size;
+u64 host_s1_pgtable_early_mem_base;
+
+static u64 host_s1_sparse_mem_base;
+static u64 host_s1_sparse_mem_size;
+
+/*
+ * reserved memory region for kernel module
+ * 1. rodata section
+ * 2. init text or text section
+ */
+u64 host_s1_module_ro_base;
+u64 host_s1_module_ro_size;
+
+u64 host_s1_module_text_base;
+u64 host_s1_module_text_size;
+
+static u64 __sekvm_vmemmap;
+
+/* Reservation */
+void  __init early_sekvm_hyp_reserve(void);
+void  __init sekvm_hyp_reserve(void);
+
+struct hyp_pool {
+	/*
+	 * Spinlock protecting concurrent changes to the memory pool as well as
+	 * the struct hyp_page of the pool's pages until we have a proper atomic
+	 * API at EL2.
+	 */
+	spinlock_t lock;
+	struct list_head free_area[MAX_ORDER];
+	phys_addr_t range_start;
+	phys_addr_t range_end;
+	unsigned short max_order;
+};
+
+/* Allocation */
+void *host_alloc_pt_pages(unsigned short order);
+void host_free_pt_pages(unsigned long addr);
+void *host_alloc_mod_pages(unsigned short order, bool ro);
+static void *host_alloc_pages(struct hyp_pool *pool, unsigned short order);
+
+
+/* API */
+static inline u64 host_s1_pgtable_pages(void);
+static inline u64 host_s1_module_pages(void);
+static inline u64 host_s1_vmemmap_pages(u64 vmemmap_entsize);
+void host_split_page(struct hyp_page *page);
+void host_get_page(struct hyp_pool *pool, void *addr);
+void host_put_page(struct hyp_pool *pool, void *addr);
+
+/* Finalise */
+/* FIXME: Used pages cannot be freed */
+int host_s1_pool_init(struct hyp_pool *pool, u64 base, u64 size);
+void host_s1_pool_finalise(void);
+
+static struct hyp_pool host_s1_pgtable_pool;
+static struct hyp_pool host_s1_module_ro_pool;
+static struct hyp_pool host_s1_module_text_pool;
+
+#define sekvm_vmemmap ((struct hyp_page *)__sekvm_vmemmap)
+
+#define __sekvm_va(phys)	__va(phys)
+#define __sekvm_pa(virt)	(phys_addr_t)__pa(virt)
+
+#define sekvm_phys_to_pfn(phys)	((phys) >> PAGE_SHIFT)
+#define sekvm_pfn_to_phys(pfn)	((phys_addr_t)((pfn) << PAGE_SHIFT))
+#define sekvm_phys_to_page(phys)	(&sekvm_vmemmap[sekvm_phys_to_pfn(phys - host_s1_mem_base)])
+#define sekvm_virt_to_page(virt)	sekvm_phys_to_page(__sekvm_pa(virt))
+#define sekvm_virt_to_pfn(virt)	sekvm_phys_to_pfn(__sekvm_pa(virt))
+
+#define sekvm_page_to_pfn(page)	  (((u64)(page) - (u64)(sekvm_vmemmap)) / sizeof(struct hyp_page)) + host_s1_mem_pfn
+#define sekvm_page_to_phys(page)  sekvm_pfn_to_phys((sekvm_page_to_pfn(page)))
+#define sekvm_page_to_virt(page)	__sekvm_va(sekvm_page_to_phys(page))
+#define sekvm_page_to_pool(page)	(((struct hyp_page *)page)->pool)
+
+static inline u64 host_s1_pgtable_pages(void)
+{
+	return (PMD_SIZE * (256 + 128)) >> PAGE_SHIFT;
+}
+
+static inline u64 host_s1_module_pages(void)
+{
+	return (PMD_SIZE * 128) >> PAGE_SHIFT;
+}
+
+static inline u64 host_s1_vmemmap_pages(u64 vmemmap_entsize)
+{
+	u64 start, end;
+
+	start = host_s1_mem_base;
+
+	if (!start)
+			return 0;
+
+	host_s1_mem_pfn = sekvm_phys_to_pfn(start);
+
+	if (!host_s1_sparse_mem_base)
+		end = host_s1_mem_base + (host_s1_module_pages() << PAGE_SHIFT);
+	else
+		end = host_s1_sparse_mem_base + host_s1_sparse_mem_size;
+
+	if (end <= start)
+			return 0;
+
+	return (((end - start) >> PAGE_SHIFT) * vmemmap_entsize);
+}
+
+static inline int sekvm_hyp_page_count(void *addr)
+{
+	struct hyp_page *p = sekvm_virt_to_page(addr);
+
+	return p->refcount;
+}
+
+static inline void *sekvm_phys_to_virt(phys_addr_t phys)
+{
+	return __sekvm_va(phys);
+}
+
+static inline phys_addr_t sekvm_virt_to_phys(void *addr)
+{
+	return __sekvm_pa(addr);
+}
+
+static struct hyp_page *__find_buddy_nocheck(struct hyp_pool *pool,
+					     struct hyp_page *p,
+					     unsigned short order)
+{
+	phys_addr_t addr = sekvm_page_to_phys(p);
+
+	addr ^= (PAGE_SIZE << order);
+
+	/*
+	 * Don't return a page outside the pool range -- it belongs to
+	 * something else and may not be mapped in hyp_vmemmap.
+	 */
+	if (addr < pool->range_start || addr >= pool->range_end)
+		return NULL;
+
+	return sekvm_phys_to_page(addr);
+}
+
+/* Find a buddy page currently available for allocation */
+static struct hyp_page *__find_buddy_avail(struct hyp_pool *pool,
+					   struct hyp_page *p,
+					   unsigned short order)
+{
+	struct hyp_page *buddy = __find_buddy_nocheck(pool, p, order);
+
+	if (!buddy || buddy->order != order || buddy->refcount)
+		return NULL;
+
+	return buddy;
+
+}
+
+/*
+ * Pages that are available for allocation are tracked in free-lists, so we use
+ * the pages themselves to store the list nodes to avoid wasting space. As the
+ * allocator always returns zeroed pages (which are zeroed on the hyp_put_page()
+ * path to optimize allocation speed), we also need to clean-up the list node in
+ * each page when we take it out of the list.
+ */
+static inline void page_remove_from_list(struct hyp_page *p)
+{
+	struct list_head *node = sekvm_page_to_virt(p);
+
+	__list_del_entry(node);
+	memset(node, 0, sizeof(*node));
+}
+
+static inline void page_add_to_list(struct hyp_page *p, struct list_head *head)
+{
+	struct list_head *node = sekvm_page_to_virt(p);
+
+	INIT_LIST_HEAD(node);
+	list_add_tail(node, head);
+}
+
+static inline struct hyp_page *node_to_page(struct list_head *node)
+{
+	return sekvm_virt_to_page(node);
+}
+
+static void __hyp_attach_page(struct hyp_pool *pool,
+			      struct hyp_page *p, bool init)
+{
+	unsigned short order = p->order;
+	struct hyp_page *buddy;
+
+	if (init)
+		memset(sekvm_page_to_virt(p), 0, PAGE_SIZE << p->order);
+
+	/*
+	 * Only the first struct hyp_page of a high-order page (otherwise known
+	 * as the 'head') should have p->order set. The non-head pages should
+	 * have p->order = HYP_NO_ORDER. Here @p may no longer be the head
+	 * after coallescing, so make sure to mark it HYP_NO_ORDER proactively.
+	 */
+	p->order = HYP_NO_ORDER;
+	for (; (order + 1) < pool->max_order; order++) {
+		buddy = __find_buddy_avail(pool, p, order);
+		if (!buddy)
+			break;
+
+		/* Take the buddy out of its list, and coallesce with @p */
+		page_remove_from_list(buddy);
+		buddy->order = HYP_NO_ORDER;
+		p = min(p, buddy);
+	}
+
+	/* Mark the new head, and insert it */
+	p->order = order;
+	page_add_to_list(p, &pool->free_area[order]);
+}
+
+static struct hyp_page *__hyp_extract_page(struct hyp_pool *pool,
+					   struct hyp_page *p,
+					   unsigned short order)
+{
+	struct hyp_page *buddy;
+
+	page_remove_from_list(p);
+	while (p->order > order) {
+		/*
+		 * The buddy of order n - 1 currently has HYP_NO_ORDER as it
+		 * is covered by a higher-level page (whose head is @p). Use
+		 * __find_buddy_nocheck() to find it and inject it in the
+		 * free_list[n - 1], effectively splitting @p in half.
+		 */
+		p->order--;
+		buddy = __find_buddy_nocheck(pool, p, p->order);
+		buddy->order = p->order;
+		page_add_to_list(buddy, &pool->free_area[buddy->order]);
+	}
+
+	return p;
+}
+
+static inline void hyp_page_ref_inc(struct hyp_page *p)
+{
+	BUG_ON(p->refcount == USHRT_MAX);
+	p->refcount++;
+}
+
+static inline int hyp_page_ref_dec_and_test(struct hyp_page *p)
+{
+	BUG_ON(!p->refcount);
+	p->refcount--;
+	return (p->refcount == 0);
+}
+
+static inline void hyp_set_page_refcounted(struct hyp_page *p)
+{
+	BUG_ON(p->refcount);
+	p->refcount = 1;
+}
+
+static void __hyp_put_page(struct hyp_pool *pool, struct hyp_page *p, bool init)
+{
+	if (hyp_page_ref_dec_and_test(p))
+		__hyp_attach_page(pool, p, init);
+}
+
+/*
+ * Changes to the buddy tree and page refcounts must be done with the hyp_pool
+ * lock held. If a refcount change requires an update to the buddy tree (e.g.
+ * hyp_put_page()), both operations must be done within the same critical
+ * section to guarantee transient states (e.g. a page with null refcount but
+ * not yet attached to a free list) can't be observed by well-behaved readers.
+ */
+void host_put_page(struct hyp_pool *pool, void *addr)
+{
+	struct hyp_page *p = sekvm_virt_to_page(addr);
+
+	spin_lock(&pool->lock);
+	__hyp_put_page(pool, p, 0);
+	spin_unlock(&pool->lock);
+}
+
+void host_get_page(struct hyp_pool *pool, void *addr)
+{
+	struct hyp_page *p = sekvm_virt_to_page(addr);
+
+	spin_lock(&pool->lock);
+	hyp_page_ref_inc(p);
+	spin_unlock(&pool->lock);
+}
+
+void host_split_page(struct hyp_page *p)
+{
+	unsigned short order = p->order;
+	unsigned int i;
+
+	p->order = 0;
+	for (i = 1; i < (1 << order); i++) {
+		struct hyp_page *tail = p + i;
+
+		tail->order = 0;
+		hyp_set_page_refcounted(tail);
+	}
+}
+
+static void host_free_pages(struct hyp_pool *pool, void *addr)
+{
+	struct hyp_page *p;
+
+	spin_lock(&pool->lock);
+	p = sekvm_virt_to_page(addr);
+	__hyp_put_page(pool, p, 0);
+	spin_unlock(&pool->lock);
+	return;
+}
+
+static void *host_alloc_pages(struct hyp_pool *pool, unsigned short order)
+{
+	unsigned short i = order;
+	struct hyp_page *p;
+	spin_lock(&pool->lock);
+
+	/* Look for a high-enough-order page */
+	while (i < pool->max_order && list_empty(&pool->free_area[i]))
+		i++;
+	if (i >= pool->max_order) {
+		spin_unlock(&pool->lock);
+		return NULL;
+	}
+
+	/* Extract it from the tree at the right order */
+	p = node_to_page(pool->free_area[i].next);
+	p = __hyp_extract_page(pool, p, order);
+
+	hyp_set_page_refcounted(p);
+	spin_unlock(&pool->lock);
+
+	return sekvm_page_to_virt(p);
+}
+
+void *host_alloc_pt_pages(unsigned short order)
+{
+	if (!host_s1_sparse_mem_base)
+		return NULL;
+	else
+		return host_alloc_pages(&host_s1_pgtable_pool, order);
+}
+
+void host_free_pt_pages(unsigned long addr)
+{
+	host_free_pages(&host_s1_pgtable_pool, addr);
+}
+
+void *host_alloc_mod_pages(unsigned short order, bool ro)
+{
+	if (ro)
+		return host_alloc_pages(&host_s1_module_ro_pool, order);
+	else
+		return host_alloc_pages(&host_s1_module_text_pool, order);
+}
+
+int host_s1_pool_init(struct hyp_pool* pool, u64 base, u64 size)
+{
+	struct hyp_page *p;
+	int i;
+	unsigned int nr_pages = size >> PAGE_SHIFT;
+	phys_addr_t phys = base;
+
+	u64 pfn = phys >> PAGE_SHIFT;
+	spin_lock_init(&pool->lock);
+	pool->max_order = min(MAX_ORDER, get_order(nr_pages << PAGE_SHIFT));
+	for (i = 0; i < pool->max_order; i++)
+		INIT_LIST_HEAD(&pool->free_area[i]);
+	pool->range_start = phys;
+	pool->range_end = phys + (nr_pages << PAGE_SHIFT);
+
+	p = sekvm_phys_to_page(phys);
+	for (i = 0; i < nr_pages; i++) {
+		p[i].order = 0;
+		hyp_set_page_refcounted(&p[i]);
+	}
+
+	/* Attach the unused pages to the buddy tree */
+	for (i = 0; i < nr_pages; i++)
+		__hyp_put_page(pool, &p[i], 1);
+
+	return 0;
+}
+
+void host_s1_pool_finalise(void)
+{
+		if (host_s1_sparse_mem_base)
+			host_s1_pool_init(&host_s1_pgtable_pool,
+							host_s1_sparse_mem_base, host_s1_sparse_mem_size);
+		host_s1_pool_init(&host_s1_module_ro_pool,
+						host_s1_module_ro_base, host_s1_module_ro_size);
+		host_s1_pool_init(&host_s1_module_text_pool,
+						host_s1_module_text_base, host_s1_module_text_size);
+}
+
+void __init sekvm_divide_reserve_mem(void)
+{	
+		BUG_ON(!host_s1_pgtable_early_mem_base ||
+						host_s1_pgtable_early_mem_base < host_s1_pgtable_mem_base);
+
+		u64 rest = host_s1_pgtable_early_mem_base - host_s1_pgtable_mem_base;
+
+		if (rest < PMD_SIZE)
+		{
+				host_s1_sparse_mem_base = 0UL;
+		}
+		else
+		{
+			host_s1_sparse_mem_base = host_s1_pgtable_mem_base;
+			host_s1_sparse_mem_size = ALIGN(host_s1_pgtable_early_mem_base - PMD_SIZE, PMD_SIZE)
+					- host_s1_sparse_mem_base;
+	
+			BUG_ON(!host_s1_sparse_mem_base || host_s1_sparse_mem_size < 0);
+		
+			pr_info("SeKVM: Sparse memory : %llx - %llx\n",
+							host_s1_sparse_mem_base,
+							host_s1_sparse_mem_base + host_s1_sparse_mem_size);
+		}
+
+		/*
+		 * The part of kernel module
+		 * +-------------+------+-----------------+----+-------------+
+		 * | unused page | text | 2 * unused page | ro | unused page |
+		 * +-------------+------+-----------------+----+-------------+
+		 */
+
+		u64 mod_pages = host_s1_module_pages();
+
+		BUG_ON((host_s1_mem_base + (mod_pages << PAGE_SHIFT))
+						> host_s1_pgtable_mem_base);
+		
+		host_s1_module_text_base = host_s1_mem_base + PAGE_SIZE;
+		host_s1_module_text_size = ((mod_pages / 2) << PAGE_SHIFT) - (2 * PAGE_SIZE);
+
+		host_s1_module_ro_base = ALIGN(host_s1_module_text_base + host_s1_module_text_size,
+						PMD_SIZE) + PAGE_SIZE;
+		host_s1_module_ro_size = ((mod_pages / 2) << PAGE_SHIFT) - (2 * PAGE_SIZE);
+
+		BUG_ON(!host_s1_module_text_base || !host_s1_module_ro_base);
+
+		pr_info("SeKVM: Module memory:\n"
+				"\ttext  : %llx - %llx\n"
+				"\tro    : %llx - %llx\n",
+				host_s1_module_text_base, host_s1_module_text_base + host_s1_module_text_size,
+				host_s1_module_ro_base, host_s1_module_ro_base + host_s1_module_ro_size);
+
+
+		u64 vm_size = host_s1_vmemmap_pages(sizeof(struct hyp_page));
+		__sekvm_vmemmap = __va(memblock_alloc(vm_size, PMD_SIZE));
+
+		pr_info("SeKVM: Reserved %lld B at 0x%llx - vmemmap\n", vm_size,
+						__sekvm_vmemmap);
+
+		/* Almost done, clear early mem base */
+		host_s1_pgtable_early_mem_base = 0;
+
+		host_s1_pool_finalise();
+	}
+
+void __init early_sekvm_hyp_reserve(void)
+{
+	/*
+	 * FIXME: hardcode the value for now.
+	 * 1. Stage 1 kernel page table (256 + 128) * 2MB
+	 * 2. Stage 1 kernel module (RO) 64 * 2MB
+	 * 3. Stage 1 kernel module (TEXT) 64 * 2MB
+	 * +-------------------+-----------------+----------+
+	 * | host module(text) | host module(ro) | host kpt |
+	 * +-------------------+-----------------+----------+
+	 */
+	unsigned long total_pages = 0UL;
+
+	total_pages += host_s1_pgtable_pages();
+	total_pages += host_s1_module_pages();
+
+	host_s1_mem_size = total_pages << PAGE_SHIFT;
+
+	/*
+	 * Since in the stage 2 translation page table, the host user and
+	 * kernel will share the same stage 2 page table (vttbr_el2).
+	 *
+	 * Here, we hope to allocate PMD-aligned pages for kernel pages
+	 * and PUD-aligned pages for user pages in stage 2 translation to
+	 * reduce TLB pressure and separate both at different PUD block.
+	 */
+	host_s1_mem_base = memblock_alloc(ALIGN(host_s1_mem_size, PUD_SIZE),
+					PUD_SIZE);
+
+	if (!host_s1_mem_base)
+		host_s1_mem_base = memblock_alloc(ALIGN(host_s1_mem_size, PMD_SIZE),
+						PMD_SIZE);
+	else
+		host_s1_mem_size = ALIGN(host_s1_mem_size, PUD_SIZE);
+
+	if (!host_s1_mem_base)
+		host_s1_mem_base = memblock_alloc(host_s1_mem_size, PAGE_SIZE);
+	else
+		host_s1_mem_size = ALIGN(host_s1_mem_size, PMD_SIZE);
+
+	/* OOM, not handled from now.*/
+	BUG_ON(!host_s1_mem_base);
+
+	/*
+	 * Reserve two reserved pages/block to safely bind
+	 * both sides of the kernel page table pool
+	 * +------------------+---------------+----------------+------------------+
+	 * | unused 2MB block | host rest kpt | host early kpt | unused 2MB block |
+	 * +------------------+---------------+----------------+------------------+
+	 */
+	host_s1_pgtable_mem_base = host_s1_mem_base
+			+ (host_s1_module_pages() << PAGE_SHIFT) + PMD_SIZE;
+	host_s1_pgtable_mem_size = (host_s1_pgtable_pages() << PAGE_SHIFT) - (2 * PMD_SIZE);
+	host_s1_pgtable_early_mem_base = host_s1_pgtable_mem_base + host_s1_pgtable_mem_size;
+
+	pr_info("SeKVM: Reserved %lld MiB at 0x%llx\n", host_s1_mem_size  >> 20,
+					host_s1_mem_base);
+}
diff --git a/arch/arm64/lib/memset.S b/arch/arm64/lib/memset.S
index f2670a9f..9a02fa82 100644
--- a/arch/arm64/lib/memset.S
+++ b/arch/arm64/lib/memset.S
@@ -208,12 +208,12 @@ ENTRY(memset)
 2:
 	sub	count, count, zva_len_x
 3:
-	dc	zva, dst
-	add	dst, dst, zva_len_x
+	dc zva, dst
+	add dst, dst, zva_len_x
 	subs	count, count, zva_len_x
 	b.ge	3b
 	ands	count, count, zva_bits_x
 	b.ne	.Ltail_maybe_long
 	ret
 ENDPIPROC(memset)
-ENDPROC(__memset)
+ENDPROC(__memset)
\ No newline at end of file
diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c
index c127f94d..7521ad2c 100644
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@ -27,6 +27,10 @@
 #include <asm/smp.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_VERIFIED_KVM
+#include <asm/hypsec_host.h>
+#endif
+
 static u32 asid_bits;
 static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 
@@ -245,6 +249,27 @@ switch_mm_fastpath:
 		cpu_switch_mm(mm->pgd, mm);
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+static bool sec_switch_mm = true;
+u32 hyp_do_switch_mm(pgd_t *pgd, struct mm_struct *mm)
+{
+	if(!sec_switch_mm)
+		return 0;
+
+	u64 ttbr0 = virt_to_phys(pgd);
+	u64 asid = atomic64_read(&mm->context.id);
+
+	u32 ret = kvm_call_core(HVC_DO_SWITCH_MM, ttbr0, asid);
+
+	if (!ret)
+		post_ttbr_update_workaround();
+	else
+		sec_switch_mm = false;
+
+	return (ret == 0)? 1 : 0;
+}
+#endif
+
 /* Errata workaround post TTBRx_EL1 update. */
 asmlinkage void post_ttbr_update_workaround(void)
 {
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index 9abf8a1e..7836e165 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -40,6 +40,7 @@
 #include <linux/mm.h>
 #include <linux/kexec.h>
 #include <linux/crash_dump.h>
+#include <linux/kvm_host.h>
 
 #include <asm/boot.h>
 #include <asm/fixmap.h>
@@ -457,6 +458,9 @@ void __init arm64_memblock_init(void)
 	 * pagetables with memblock.
 	 */
 	memblock_reserve(__pa_symbol(_text), _end - _text);
+
+	early_sekvm_hyp_reserve();
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start) {
 		memblock_reserve(initrd_start, initrd_end - initrd_start);
@@ -486,6 +490,7 @@ void __init arm64_memblock_init(void)
 	memblock_allow_resize();
 }
 
+
 void __init bootmem_init(void)
 {
 	unsigned long min, max;
@@ -498,6 +503,8 @@ void __init bootmem_init(void)
 	max_pfn = max_low_pfn = max;
 
 	arm64_numa_init();
+
+	sekvm_divide_reserve_mem();
 	/*
 	 * Sparsemem tries to allocate bootmem in memory_present(), so must be
 	 * done after the fixed reservations.
@@ -603,6 +610,49 @@ void __init mem_init(void)
 
 	mem_init_print_info(NULL);
 
+#ifdef CONFIG_KERNEL_INT
+#define MLK(b, t) b, t, ((t) - (b)) >> 10
+#define MLM(b, t) b, t, ((t) - (b)) >> 20
+#define MLK_ROUNDUP(b, t) b, t, DIV_ROUND_UP(((t) - (b)), SZ_1K)
+
+	pr_notice("Virtual kernel memory layout:\n"
+			"    fixmap    : 0x%08lx - 0x%08lx   (%4ld kB)\n"
+			"    vmalloc   : 0x%08lx - 0x%08lx   (%4ld MB)\n"
+			"    lowmem    : 0x%08lx - 0x%08lx   (%4ld MB)\n"
+#ifdef CONFIG_HIGHMEM
+			"    pkmap     : 0x%08lx - 0x%08lx   (%4ld MB)\n"
+#endif
+#ifdef CONFIG_MODULES
+			"    modules   : 0x%08lx - 0x%08lx   (%4ld MB)\n"
+#endif
+			"      .text   : 0x%lx" " - 0x%lx" "   (%4td kB)\n"
+			"      .rodata : 0x%lx" " - 0x%lx" "   (%4td kB)\n"
+			"      .init   : 0x%lx" " - 0x%lx" "   (%4td kB)\n"
+			"      .data   : 0x%lx" " - 0x%lx" "   (%4td kB)\n"
+			"       .bss   : 0x%lx" " - 0x%lx" "   (%4td kB)\n",
+
+			MLK(FIXADDR_START, FIXADDR_START + FIXADDR_SIZE),
+			MLM(VMALLOC_START, VMALLOC_END),
+			MLM(PAGE_OFFSET, (unsigned long)high_memory),
+#ifdef CONFIG_HIGHMEM
+			MLM(PKMAP_BASE, (PKMAP_BASE) + (LAST_PKMAP) *
+				(PAGE_SIZE)),
+#endif
+#ifdef CONFIG_MODULES
+			MLM(MODULES_VADDR, MODULES_END),
+#endif
+
+			MLK_ROUNDUP(_text, _etext),
+			MLK_ROUNDUP(__start_rodata, __inittext_begin),
+			MLK_ROUNDUP(__init_begin, __init_end),
+			MLK_ROUNDUP(_sdata, _edata),
+			MLK_ROUNDUP(__bss_start, __bss_stop));
+
+#undef MLK
+#undef MLM
+#undef MLK_ROUNDUP
+#endif
+
 	/*
 	 * Check boundaries twice: Some fundamental inconsistencies can be
 	 * detected at build time already.
@@ -639,6 +689,7 @@ void free_initmem(void)
 	 * prevents the region from being reused for kernel modules, which
 	 * is not supported by kallsyms.
 	 */
+	
 	unmap_kernel_range((u64)__init_begin, (u64)(__init_end - __init_begin));
 }
 
diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c
index 493ff756..efa6db4b 100644
--- a/arch/arm64/mm/mmu.c
+++ b/arch/arm64/mm/mmu.c
@@ -55,6 +55,8 @@ u64 idmap_ptrs_per_pgd = PTRS_PER_PGD;
 u64 kimage_voffset __ro_after_init;
 EXPORT_SYMBOL(kimage_voffset);
 
+static unsigned long eguard_page[(PAGE_SIZE / sizeof(unsigned long))] __block_aligned_bss;
+EXPORT_SYMBOL(eguard_page);
 /*
  * Empty_zero_page is a special page that is used for zero-initialized data
  * and COW.
@@ -66,6 +68,9 @@ static pte_t bm_pte[PTRS_PER_PTE] __page_aligned_bss;
 static pmd_t bm_pmd[PTRS_PER_PMD] __page_aligned_bss __maybe_unused;
 static pud_t bm_pud[PTRS_PER_PUD] __page_aligned_bss __maybe_unused;
 
+unsigned long guard_page[PAGE_SIZE / sizeof(unsigned long)] __block_aligned_bss;
+EXPORT_SYMBOL(guard_page);
+
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 			      unsigned long size, pgprot_t vma_prot)
 {
@@ -102,6 +107,33 @@ static phys_addr_t __init early_pgtable_alloc(void)
 	return phys;
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+static phys_addr_t __init sekvm_early_pgtable_alloc(void)
+{
+	phys_addr_t phys;
+	void *ptr;
+
+	phys = sekvm_memblock_alloc(PAGE_SIZE, PAGE_SIZE);
+
+	/*
+	 * The FIX_{PGD,PUD,PMD} slots may be in active use, but the FIX_PTE
+	 * slot will be free, so we can (ab)use the FIX_PTE slot to initialise
+	 * any level of table.
+	 */
+	ptr = pte_set_fixmap(phys);
+
+	memset(ptr, 0, PAGE_SIZE);
+
+	/*
+	 * Implicit barriers also ensure the zeroed page is visible to the page
+	 * table walker
+	 */
+	pte_clear_fixmap();
+
+	return phys;
+}
+#endif
+
 static bool pgattr_change_is_safe(u64 old, u64 new)
 {
 	/*
@@ -351,7 +383,11 @@ static void __create_pgd_mapping(pgd_t *pgdir, phys_addr_t phys,
 
 static phys_addr_t pgd_pgtable_alloc(void)
 {
+#ifndef CONFIG_VERIFIED_KVM
 	void *ptr = (void *)__get_free_page(PGALLOC_GFP);
+#else
+	void *ptr = host_alloc_pt_pages(0);
+#endif
 	if (!ptr || !pgtable_page_ctor(virt_to_page(ptr)))
 		BUG();
 
@@ -382,7 +418,7 @@ void __init create_pgd_mapping(struct mm_struct *mm, phys_addr_t phys,
 			       pgprot_t prot, bool page_mappings_only)
 {
 	int flags = 0;
-
+	
 	BUG_ON(mm == &init_mm);
 
 	if (page_mappings_only)
@@ -412,7 +448,11 @@ static void __init __map_memblock(pgd_t *pgdp, phys_addr_t start,
 				  phys_addr_t end, pgprot_t prot, int flags)
 {
 	__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,
+#ifdef CONFIG_VERIFIED_KVM
+			     prot, sekvm_early_pgtable_alloc, flags);
+#else
 			     prot, early_pgtable_alloc, flags);
+#endif
 }
 
 void __init mark_linear_text_alias_ro(void)
@@ -517,7 +557,11 @@ static void __init map_kernel_segment(pgd_t *pgdp, void *va_start, void *va_end,
 	BUG_ON(!PAGE_ALIGNED(size));
 
 	__create_pgd_mapping(pgdp, pa_start, (unsigned long)va_start, size, prot,
+#ifdef CONFIG_VERIFIED_KVM
+			     sekvm_early_pgtable_alloc, flags);
+#else
 			     early_pgtable_alloc, flags);
+#endif
 
 	if (!(vm_flags & VM_NO_GUARD))
 		size += PAGE_SIZE;
diff --git a/arch/arm64/mm/pgd.c b/arch/arm64/mm/pgd.c
index 289f9113..58a053d0 100644
--- a/arch/arm64/mm/pgd.c
+++ b/arch/arm64/mm/pgd.c
@@ -26,12 +26,24 @@
 #include <asm/page.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_VERIFIED_KVM
+#include <asm/hypsec_host.h>
+#endif
+
 static struct kmem_cache *pgd_cache __ro_after_init;
 
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	if (PGD_SIZE == PAGE_SIZE)
+#ifndef CONFIG_KERNEL_INT
 		return (pgd_t *)__get_free_page(PGALLOC_GFP);
+#else
+	{
+		u64 pgd = (void *)host_alloc_pt_pages(0);
+		hyp_alloc_el0_pgd(__pa(pgd));
+		return (pgd_t *)pgd;
+	}
+#endif
 	else
 		return kmem_cache_alloc(pgd_cache, PGALLOC_GFP);
 }
@@ -39,7 +51,14 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
 	if (PGD_SIZE == PAGE_SIZE)
+#ifndef CONFIG_KERNEL_INT
 		free_page((unsigned long)pgd);
+#else
+	{
+		hyp_free_el0_pgd(__pa(pgd));
+		host_free_pt_pages((unsigned long)pgd);
+	}
+#endif
 	else
 		kmem_cache_free(pgd_cache, pgd);
 }
diff --git a/arch/arm64/sekvm/AbstractMachine.c b/arch/arm64/sekvm/AbstractMachine.c
index 717e533b..5d2a207b 100644
--- a/arch/arm64/sekvm/AbstractMachine.c
+++ b/arch/arm64/sekvm/AbstractMachine.c
@@ -1,11 +1,10 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "hacl-20/Hacl_Ed25519.h"
 #include "hacl-20/Hacl_AES.h"
 
 void __hyp_text v_panic(void)
 {
-	//__hyp_panic();
+	
 	u32 vmid = get_cur_vmid();
 	u32 vcpuid = get_cur_vcpu_id();
 	if (vmid) {
@@ -15,7 +14,8 @@ void __hyp_text v_panic(void)
 		print_string("\rhost\n");
 		printhex_ul(read_sysreg(elr_el2));
 	}
-	printhex_ul(ESR_ELx_EC(read_sysreg(esr_el2)));
+	printhex_ul(read_sysreg(esr_el2));
+	__hyp_panic();
 }
 
 void __hyp_text clear_phys_mem(u64 pfn)
diff --git a/arch/arm64/sekvm/BootAux.c b/arch/arm64/sekvm/BootAux.c
index 0cf26742..2d16e9de 100644
--- a/arch/arm64/sekvm/BootAux.c
+++ b/arch/arm64/sekvm/BootAux.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/BootCore.c b/arch/arm64/sekvm/BootCore.c
index e22c2e58..0cc5f183 100644
--- a/arch/arm64/sekvm/BootCore.c
+++ b/arch/arm64/sekvm/BootCore.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/BootOps.c b/arch/arm64/sekvm/BootOps.c
index 9046c380..0c008577 100644
--- a/arch/arm64/sekvm/BootOps.c
+++ b/arch/arm64/sekvm/BootOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
@@ -350,8 +349,8 @@ void __hyp_text __el2_encrypt_buf(u32 vmid, u64 buf, u64 out_buf)
 	else
 	{
 		tmp_pa = get_tmp_buf();
-        	encrypt_buf(vmid, (u64)__el2_va(hpa), (u64)tmp_pa, PAGE_SIZE);
-        	el2_memcpy(__el2_va(out_buf), (void*)tmp_pa, PAGE_SIZE);
+        encrypt_buf(vmid, (u64)__el2_va(hpa), (u64)tmp_pa, PAGE_SIZE);
+        el2_memcpy(__el2_va(out_buf), (void*)tmp_pa, PAGE_SIZE);
 	}
 
 	release_lock_s2page();
@@ -381,7 +380,6 @@ void __hyp_text __el2_decrypt_buf(u32 vmid, void *buf, u32 len)
 
 		decrypt_buf(vmid, (u64)__el2_va(buf), (u64)tmp_pa, len);
 		el2_memcpy(__el2_va(buf), (void*)tmp_pa, PAGE_SIZE);
-
 		release_lock_s2page();
 	}
 
diff --git a/arch/arm64/sekvm/FaultHandler.c b/arch/arm64/sekvm/FaultHandler.c
index 3dfd1a7f..27751fce 100644
--- a/arch/arm64/sekvm/FaultHandler.c
+++ b/arch/arm64/sekvm/FaultHandler.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/types.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_hyp.h>
@@ -20,6 +19,7 @@
 #include <kvm/pvops.h>
 
 #include "hypsec.h"
+#include "MmioOps.h"
 
 u32 __hyp_text handle_pvops(u32 vmid, u32 vcpuid)
 {
@@ -58,15 +58,37 @@ void __hyp_text handle_host_stage2_fault(unsigned long host_lr,
 					 struct s2_host_regs *host_regs)
 {
 	u32 ret;
-	u64 addr;
+	u64 v_addr, at_addr, addr, esr;
+	u32 ESR_DFSC, is_write; 
 
+	acquire_lock_host_kpt();
+	esr = read_sysreg(esr_el2); 
 	addr = read_sysreg(hpfar_el2);
+	v_addr = read_sysreg(far_el2);
+	at_addr = translate_to_phys(v_addr);
+	release_lock_host_kpt();
+	
+	ESR_DFSC = esr & ESR_EL2_DFSC_MASK;
+	is_write = host_dabt_is_write(esr);
+
 	addr = (addr & HPFAR_MASK) * 256UL;
 	set_per_cpu_host_regs((u64)host_regs);
-
 	ret = emulate_mmio(addr, read_sysreg(esr_el2));
+
 	if (ret == V_INVALID)
 	{
+#ifndef CONFIG_KERNEL_INT
 		map_page_host(addr);
+#else	
+		// permission fault level 1-3
+		if (is_WP_fault(ESR_DFSC, is_write))
+		{		
+			host_kpt_handler(at_addr, esr);
+		}
+		else
+		{	
+			map_page_host(addr);
+		}
+#endif
 	}
 }
diff --git a/arch/arm64/sekvm/Helper.c b/arch/arm64/sekvm/Helper.c
index c56ab78c..a9d3eef1 100644
--- a/arch/arm64/sekvm/Helper.c
+++ b/arch/arm64/sekvm/Helper.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/types.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_hyp.h>
@@ -147,7 +146,7 @@ void __hyp_text print_string(char *input)
 	stage2_spin_unlock(&el2_data->console_lock);
 }
 
-void __hyp_text el2_memset(void *b, int c, int len)
+void __hyp_text __attribute__((optimize("O0"))) el2_memset(void *b, int c, int len)
 {
 	char *s = b;
 
diff --git a/arch/arm64/sekvm/HostPtSwitch.c b/arch/arm64/sekvm/HostPtSwitch.c
new file mode 100644
index 00000000..10e0f170
--- /dev/null
+++ b/arch/arm64/sekvm/HostPtSwitch.c
@@ -0,0 +1,186 @@
+#include "hypsec.h"
+#ifdef CONFIG_KERNEL_INT
+#include "../kint/kint.h"
+#endif
+
+#ifdef CONFIG_ARM64_PA_BITS_52
+#define phys_to_ttbr(addr)	(((addr) | ((addr) >> 46)) & TTBR_BADDR_MASK_52)
+#else
+#define phys_to_ttbr(addr)	(addr)
+#endif
+
+static inline bool check_if_swapper(u64 baddr)
+{
+	u64 swapper;
+	bool user_flag = false;
+
+	if (baddr == 0UL)
+		return false;
+
+	swapper = get_host_ttbr1();
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	user_flag = baddr & USER_ASID_FLAG;
+#endif
+	return (baddr == swapper && !user_flag);
+}
+
+static inline bool is_swapper_or_tramp(u64 baddr)
+{
+	u64 tramp, swapper;
+
+	if (baddr == 0UL)
+		return false;
+
+	swapper = get_host_ttbr1();
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	tramp = swapper - (PAGE_SIZE + RESERVED_TTBR0_SIZE);
+#else
+	tramp = 0UL;
+#endif
+	return ((baddr == swapper) || (baddr == tramp));
+}
+
+static inline void el2_host_set_reserved_ttbr0_asm(void)
+{
+	unsigned long ttbr = phys_to_ttbr(get_host_zero_page());
+
+	asm volatile(
+		"msr TTBR0_EL1, %0\n"
+		:
+		: "r" (ttbr)
+		:
+	);
+}
+
+static inline void el2_do_switch_mm_asm(u64 ttbr0, u64 ttbr1, u64 asid)
+{
+	asm volatile(
+#ifdef CONFIG_ARM64_SW_TTBR0_PAN
+		"bfi	%1, %0, #48, #16\n"		// set the ASID field in TTBR0
+#endif
+		"bfi	%2, %0, #48, #16\n"		// set the ASID
+		"msr	TTBR1_EL1, %2\n"		// in TTBR1 (since TCR.A1 is set)
+		"msr	TTBR0_EL1, %1\n"		// now update TTBR0
+		:
+		: "r" (asid), "r" (ttbr0), "r" (ttbr1)
+		:
+	);
+}
+
+u32 __hyp_text el2_do_switch_mm(u64 ttbr0, u64 asid)
+{
+	u64 baddr0, baddr1;
+	u64 hcr;
+	u32 owner0, owner1, subowner0;
+
+	/* ttbr0_el1 */
+#ifdef CONFIG_ARM64_SW_TTBR0_PAN
+	baddr0 = ttbr0 & ~TTBR_ASID_MASK;
+#else
+	baddr0 = ttbr0;
+#endif
+
+	/* ttbr1_el1 */
+	baddr1 = read_sysreg(ttbr1_el1) & ~TTBR_ASID_MASK;
+
+	// acquire_lock_s2page();
+
+	owner0 = get_pfn_owner(baddr0 >> PAGE_SHIFT);
+	owner1 = get_pfn_owner(baddr1 >> PAGE_SHIFT);
+
+#ifdef CONFIG_KERNEL_INT
+	subowner0 = get_pfn_subowner(baddr0 >> PAGE_SHIFT);
+#endif
+
+	hcr = read_sysreg(hcr_el2);
+
+	if ((hcr & HCR_TVM) == 0)
+	/*
+	 * Do not trap to EL2 anymore, let the host
+	 * handle the mm switch itself.
+	 */
+		goto fail;
+
+	if (owner0 == HOSTVISOR && owner1 == HOSTVISOR)
+	{
+		if (check_if_swapper(baddr1) && !is_swapper_or_tramp(baddr0)
+#ifdef CONFIG_KERNEL_INT
+			&& (subowner0 == EL0_PGD) /* EL0_PGD */
+#endif
+		   )
+		{
+			/* No translations will be possible via TTBR0. */
+			el2_host_set_reserved_ttbr0_asm();
+			el2_do_switch_mm_asm(phys_to_ttbr(ttbr0), baddr1, asid);
+		}
+		else
+		{
+			__hyp_panic();
+		}
+	}
+	else
+	{
+		__hyp_panic();
+	}
+
+	// release_lock_s2page();
+	return 0;
+
+fail:
+	// release_lock_s2page();
+	return -1;
+}
+
+#ifdef CONFIG_KERNEL_INT
+void __hyp_text el2_do_alloc_el0_pgd(u64 addr)
+{
+	u64 pfn;
+	u32 owner, subowner;
+
+	pfn = phys_page(addr) >> PAGE_SHIFT;
+
+	acquire_lock_s2page();
+
+	owner = get_pfn_owner(pfn);
+	subowner = get_pfn_subowner(pfn);
+
+	if (owner != HOSTVISOR)
+	{
+		print_string("pgd: not a host page.\n");
+		// v_panic();
+	}
+	else if (!subowner)
+	{
+		handle_host_new_page(pfn, EL0_PGD, owner);
+	}
+
+	release_lock_s2page();
+}
+
+void __hyp_text el2_do_free_el0_pgd(u64 addr)
+{
+	u64 pfn;
+	u32 owner, subowner;
+
+	pfn = phys_page(addr) >> PAGE_SHIFT;
+
+	acquire_lock_s2page();
+
+	owner = get_pfn_owner(pfn);
+	subowner = get_pfn_subowner(pfn);
+
+	if (owner != HOSTVISOR)
+	{
+		print_string("pgd: not a host page.\n");
+		// v_panic();
+	}
+
+	if (subowner == EL0_PGD)
+	{
+		handle_host_remove_page(pfn, owner);
+	}
+
+	release_lock_s2page();
+}
+
+#endif
diff --git a/arch/arm64/sekvm/HostSysRegsHandler.c b/arch/arm64/sekvm/HostSysRegsHandler.c
new file mode 100644
index 00000000..6fe03c30
--- /dev/null
+++ b/arch/arm64/sekvm/HostSysRegsHandler.c
@@ -0,0 +1,138 @@
+#include "hypsec.h"
+
+static void inline advance_pc(void)
+{
+	u64 pc = read_sysreg(elr_el2);
+	write_sysreg(pc + 4, elr_el2);
+}
+
+/*
+ * 1. The base address of translation table of EL0 regime should owned by HOSTVISOR
+ * 2. The base address of translation table of EL0 should not point to kernel space(TTBR1_EL1)
+ * We do optimization on context switches, so no longer perform ttbr0 update at here,
+ * see HostPtSwitch.c
+ */
+static void __hyp_text handle_ttbr0(u64 val)
+{
+	__hyp_panic();
+/*
+	u64 pfn,baddr;
+	u32 owner;
+
+#ifdef CONFIG_ARM64_SW_TTBR0_PAN
+	baddr = val & ~TTBR_ASID_MASK;
+#else
+	baddr = val;
+#endif
+
+	pfn = baddr / PAGE_SIZE;
+	owner = get_pfn_owner(pfn);
+	
+	u64 swapper = get_host_ttbr1();
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+	u64 tramp = swapper - (PAGE_SIZE + RESERVED_TTBR0_SIZE);	// tramp_pg_dir 
+	if( owner == HOSTVISOR && baddr != swapper && baddr != tramp ){
+#else
+	if( owner == HOSTVISOR && baddr != swapper ){
+#endif
+		asm volatile(
+        	"msr TTBR0_EL1, %0\n"
+			:: "r" (val)
+			:
+		);
+	} else {
+		__hyp_panic();
+	}
+*/
+}
+
+/*
+ * 1. The base address of translation table of EL1 regime should owned by HOSTVISOR
+ * 2. The value of base address of translation table after booting should only be
+ * 	  the kernel page or trampoline page
+ */
+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
+static void __hyp_text handle_ttbr1(u64 val)
+{
+	u64 pfn, baddr;
+	u64 swapper;
+	u32 owner;
+
+	baddr = val & ~TTBR_ASID_MASK;		/*TCR_EL1.A1 = 1, ASID defined by ttbr1.ASID*/
+	pfn = baddr / PAGE_SIZE;
+	
+	owner = get_pfn_owner(pfn);
+	if( owner == HOSTVISOR ){
+		swapper = get_host_ttbr1();									// swapper_pg_dir
+		u64 tramp = swapper - (PAGE_SIZE + RESERVED_TTBR0_SIZE);	// tramp_pg_dir 
+		bool user_flag = val & USER_ASID_FLAG;
+		
+		if( ( baddr == tramp &&  user_flag ) || ( baddr == swapper && !user_flag ) ){
+
+			asm volatile(
+        		"msr TTBR1_EL1, %0\n"
+				:: "r" (val)
+				:
+			);
+
+		} else {
+				__hyp_panic();
+		}
+	} else {
+		__hyp_panic();
+	}
+}
+#else
+static inline void __hyp_text handle_ttbr1(u64 val)
+{
+	__hyp_panic();
+}
+#endif
+
+void __hyp_text handle_host_sys_regs(unsigned long host_lr,
+				struct s2_host_regs *host_regs)
+{
+	u32 esr;
+	int Rt;
+	esr = read_sysreg(esr_el2);
+	set_per_cpu_host_regs((u64)host_regs);
+
+	Rt = (esr >> 5) & 0x1f;
+	bool is_write = !(esr & 1);
+	u64 val = 0;
+	unsigned long ret = 0;
+
+	if (!is_write)
+	/*
+	 * The registers is written by host
+	 * with instruction MSR and traps to EL2,
+	 * hence the bit should be 1 in ESR_EL2
+	 */
+		__hyp_panic();
+
+
+	val = get_host_regs(Rt);
+	ret = sec_el2_handle_sys_reg(esr);
+
+	switch (ret) {
+		case TTBR0_EL1:
+			handle_ttbr0(val);
+			break;
+		case TTBR1_EL1:
+			handle_ttbr1(val);
+			break;
+		default:
+			/*
+			 * Extend handler if needed. By default, the remaining
+			 * system register will not modified after booting.
+			 * Remaining Register:
+			 * SCTLR_EL1, TCR_EL1, ESR_EL1, FAR_EL1, ASFR0_EL1, ASFR_EL1,
+			 * MAIR_EL1, AMAIR_EL1, CONTEXTIDR_EL1
+			 */
+			__hyp_panic();
+			break;
+	}
+
+	/*Move PC to next instruction and continue execution when return to address in ELR_EL2*/
+	advance_pc();
+}
diff --git a/arch/arm64/sekvm/Makefile b/arch/arm64/sekvm/Makefile
index 560bbb6d..19849c64 100644
--- a/arch/arm64/sekvm/Makefile
+++ b/arch/arm64/sekvm/Makefile
@@ -36,3 +36,9 @@ obj-y += MmioSPTWalk.o
 obj-y += MmioSPTOps.o
 obj-y += TrapDispatcher.o
 obj-y += FaultHandler.o
+obj-y += HostSysRegsHandler.o
+obj-y += HostPtSwitch.o
+
+
+
+core-$(CONFIG_VERIFIED_KVM) += arch/arm64/sekvm/
diff --git a/arch/arm64/sekvm/MemAux.c b/arch/arm64/sekvm/MemAux.c
index ee489497..bf06760d 100644
--- a/arch/arm64/sekvm/MemAux.c
+++ b/arch/arm64/sekvm/MemAux.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
@@ -8,7 +7,7 @@
 void __hyp_text map_page_host(u64 addr)
 {
 	u64 pfn, new_pte, perm;
-	u32 owner, count;
+	u32 owner, count, subowner;
 
 	pfn = addr / PAGE_SIZE;
 	new_pte = 0UL;
@@ -16,6 +15,7 @@ void __hyp_text map_page_host(u64 addr)
 	acquire_lock_s2page();
 	owner = get_pfn_owner(pfn);
 	count = get_pfn_count(pfn);
+
 	//uncomment the following for m400
 	//if (!(addr >= 0x4000000000 && addr < 0x5000000000)) {
 	if (owner == INVALID_MEM)
@@ -27,15 +27,80 @@ void __hyp_text map_page_host(u64 addr)
 	}
 	else
 	{
+#ifndef CONFIG_KERNEL_INT
 		if (owner == HOSTVISOR || count > 0U)
 		{
 			perm = pgprot_val(PAGE_S2_KERNEL);
 			new_pte = (pfn * PAGE_SIZE) | perm;
 			mmap_s2pt(HOSTVISOR, addr, 3U, new_pte);
 		}
+#else
+		subowner = get_pfn_subowner(pfn);
+		if (owner == HOSTVISOR || count > 0UL)
+		{	
+			if (subowner == EL1_KCODE)
+			{	
+				perm = pgprot_val(SECT_S2_KCODE);
+				new_pte = kint_mk_pmd(pfn, perm);
+				mmap_s2pt(HOSTVISOR, addr, 2U, new_pte);
+			} else if ((subowner >= EL1_PGD && subowner <= EL1_PTE) || subowner == EL0_PGD) {
+				if (check_host_s1pgtable(addr)) {
+					perm = pgprot_val(SECT_S2);
+					new_pte = kint_mk_pmd(pfn, perm);
+					mmap_s2pt(HOSTVISOR, addr, 2U, new_pte);
+				}
+				else
+				{
+					perm = pgprot_val(PAGE_S2);
+					new_pte = (pfn * PAGE_SIZE) | perm;
+					mmap_s2pt(HOSTVISOR, addr, 3U, new_pte);
+				}
+			} else if (subowner == EL1_RODATA) {
+				if (check_host_vdso(addr)) {
+					perm = pgprot_val(PAGE_S2_KCODE);
+					new_pte = (pfn * PAGE_SIZE) | perm;
+					mmap_s2pt(HOSTVISOR, addr, 3U, new_pte);
+				} else {
+					perm = pgprot_val(PAGE_S2);
+					new_pte = (pfn * PAGE_SIZE) | perm;
+					mmap_s2pt(HOSTVISOR, addr, 3U, new_pte);
+				}
+			} else if (subowner == EL1_DATA) {
+				perm = pgprot_val(SECT_S2P);
+				new_pte = kint_mk_pmd(pfn, perm);
+				mmap_s2pt(HOSTVISOR, addr, 2U, new_pte);
+			} else if (subowner == EL1_INIT) {
+				perm = pgprot_val(SECT_S2_KERNEL);
+				new_pte = kint_mk_pmd(pfn, perm);
+				mmap_s2pt(HOSTVISOR, addr, 2U, new_pte);
+			}
+			else
+			{
+				if (owner != HOSTVISOR || check_host_module(addr))
+				{
+					perm = pgprot_val(PAGE_S2_KERNEL);
+					new_pte = (pfn * PAGE_SIZE) | perm;
+					mmap_s2pt(HOSTVISOR, addr, 3U, new_pte);
+				}
+				else if (!in_kint_range(addr, PUD_SIZE))
+				{
+					perm = pgprot_val(SECT_S2_KERNEL);
+					new_pte = kint_mk_pud(pfn, perm);
+					mmap_s2pt(HOSTVISOR, addr, 1U, new_pte);
+				}
+				else
+				{
+					perm = pgprot_val(SECT_S2_KERNEL);
+					new_pte = kint_mk_pmd(pfn, perm);
+					mmap_s2pt(HOSTVISOR, addr, 2U, new_pte);
+				}
+			}
+		}
+#endif
 		else
 		{
 			print_string("\rfaults on host\n");
+			printhex_ul(owner);
 			v_panic();
 		}
 	}
@@ -129,6 +194,7 @@ void __hyp_text map_pfn_vm(u32 vmid, u64 addr, u64 pte, u32 level)
 		pte = paddr | perm;
 		pte &= ~PMD_TABLE_BIT;
 		mmap_s2pt(vmid, addr, 2U, pte);
+
 	}
 	else if (level == 3U)
 	{
@@ -240,6 +306,14 @@ void __hyp_text update_smmu_page(u32 vmid, u32 cbndx, u32 index, u64 iova, u64 p
 		map_spt(cbndx, index, iova, pte);
 		if (owner == HOSTVISOR)
 		{
+#ifdef CONFIG_KERNEL_INT
+			u32 subowner;
+			subowner = get_pfn_subowner(pfn);
+			if (subowner != NONE) {
+				print_string("\r Map to protected memory page\n");
+				v_panic();
+			}
+#endif
 			count = get_pfn_count(pfn);
 			if (count < EL2_SMMU_CFG_SIZE)
 			{
diff --git a/arch/arm64/sekvm/MemBlock.c b/arch/arm64/sekvm/MemBlock.c
index fde27029..f77906aa 100644
--- a/arch/arm64/sekvm/MemBlock.c
+++ b/arch/arm64/sekvm/MemBlock.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/MemHandler.c b/arch/arm64/sekvm/MemHandler.c
index a126d451..ebd0cab4 100644
--- a/arch/arm64/sekvm/MemHandler.c
+++ b/arch/arm64/sekvm/MemHandler.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 void __hyp_text el2_clear_vm_stage2_range(u32 vmid, u64 start, u64 size)
diff --git a/arch/arm64/sekvm/MemOps.c b/arch/arm64/sekvm/MemOps.c
index 3cd3adbb..3af0f61f 100644
--- a/arch/arm64/sekvm/MemOps.c
+++ b/arch/arm64/sekvm/MemOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/MmioOps.h b/arch/arm64/sekvm/MmioOps.h
index 9697ba5d..a9609483 100644
--- a/arch/arm64/sekvm/MmioOps.h
+++ b/arch/arm64/sekvm/MmioOps.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ARM_VERIFIED_MMIO__
 #define __ARM_VERIFIED_MMIO__
 
diff --git a/arch/arm64/sekvm/MmioPTAlloc.c b/arch/arm64/sekvm/MmioPTAlloc.c
index ff0076a6..813635f2 100644
--- a/arch/arm64/sekvm/MmioPTAlloc.c
+++ b/arch/arm64/sekvm/MmioPTAlloc.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/MmioPTWalk.c b/arch/arm64/sekvm/MmioPTWalk.c
index ec92ef86..fdb61081 100644
--- a/arch/arm64/sekvm/MmioPTWalk.c
+++ b/arch/arm64/sekvm/MmioPTWalk.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/MmioSPTOps.c b/arch/arm64/sekvm/MmioSPTOps.c
index aa592ec4..9d550aca 100644
--- a/arch/arm64/sekvm/MmioSPTOps.c
+++ b/arch/arm64/sekvm/MmioSPTOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/MmioSPTWalk.c b/arch/arm64/sekvm/MmioSPTWalk.c
index b4aa9112..3a1c3c0a 100644
--- a/arch/arm64/sekvm/MmioSPTWalk.c
+++ b/arch/arm64/sekvm/MmioSPTWalk.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/NPTOps.c b/arch/arm64/sekvm/NPTOps.c
index f21e0114..340f3a6a 100644
--- a/arch/arm64/sekvm/NPTOps.c
+++ b/arch/arm64/sekvm/NPTOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
@@ -41,9 +40,24 @@ void __hyp_text clear_pfn_host(u64 pfn)
 	pte = walk_npt(HOSTVISOR, pfn * PAGE_SIZE);
 	if (pte != 0UL)
 	{
-		set_npt(HOSTVISOR, pfn * PAGE_SIZE, 3U, 0);
-		kvm_tlb_flush_vmid_ipa_host(pfn * PAGE_SIZE);
-        }
+		if (pte & PUD_MARK)
+		{
+			/*
+			 * No support for clearing PUD page
+			 */
+			v_panic();
+		}
+		else if (v_pmd_table(pte) == PMD_TYPE_TABLE)
+		{
+			set_npt(HOSTVISOR, pfn * PAGE_SIZE, 3U, 0);
+			kvm_tlb_flush_vmid_ipa_host(pfn * PAGE_SIZE);
+		}
+		else
+		{
+			set_npt(HOSTVISOR, pfn * PAGE_SIZE, 2U, 0);
+			kvm_tlb_flush_vmid_ipa_host(kint_pfn_pmd(pfn));
+		}
+    }
 
 	release_lock_pt(HOSTVISOR);
 }
diff --git a/arch/arm64/sekvm/NPTWalk.c b/arch/arm64/sekvm/NPTWalk.c
index 81de1010..c1a3f49b 100644
--- a/arch/arm64/sekvm/NPTWalk.c
+++ b/arch/arm64/sekvm/NPTWalk.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
@@ -66,16 +65,23 @@ u64 __hyp_text walk_npt(u32 vmid, u64 addr)
 		pud = pgd;
 	}
 
-	pmd = walk_pmd(vmid, pud, addr, 0U);
-
-	if (v_pmd_table(pmd) == PMD_TYPE_TABLE)
+	if (v_pud_table(pud) == PUD_TYPE_TABLE)
 	{
-		pte = walk_pte(vmid, pmd, addr);
-		ret = pte;
+		pmd = walk_pmd(vmid, pud, addr, 0U);
+
+		if (v_pmd_table(pmd) == PMD_TYPE_TABLE)
+		{
+			pte = walk_pte(vmid, pmd, addr);
+			ret = pte;
+		}
+		else
+		{
+			ret = pmd;
+		}
 	}
 	else
 	{
-		ret = pmd;
+		ret = pud;
 	}
 
 	return check64(ret);
@@ -84,9 +90,16 @@ u64 __hyp_text walk_npt(u32 vmid, u64 addr)
 void __hyp_text set_npt(u32 vmid, u64 addr, u32 level, u64 pte)
 {
 	u64 vttbr, pgd, pud, pmd;
+	u64 pfn, perm;
 
 	vttbr = get_pt_vttbr(vmid);	
-	pgd = walk_pgd(vmid, vttbr, addr, 1U);
+	pfn = addr >> PAGE_SHIFT;
+
+	if (vmid == HOSTVISOR && level == 1U)
+		pgd = walk_pgd(vmid, vttbr, addr, 0U);
+	else
+		pgd = walk_pgd(vmid, vttbr, addr, 1U);
+
 	if (vmid == COREVISOR)
 	{
 		pud = walk_pud(vmid, pgd, addr, 1U);
@@ -96,13 +109,29 @@ void __hyp_text set_npt(u32 vmid, u64 addr, u32 level, u64 pte)
 		pud = pgd;
 	}
 
-	if (level == 2U)
+	if (level == 1U)
+	{
+		if (v_pud_table(pud) == PUD_TYPE_TABLE)
+		{
+			/* fallback to PMD */
+			perm = get_pfn_s2_perm(pfn, 2U);
+			pte = kint_mk_pmd(pfn, perm);
+			set_npt(vmid, addr, 2U, pte);
+		}
+		else
+		{
+			v_set_pud(vmid, vttbr, addr, pte);
+		}
+	}
+	else if (level == 2U)
 	{
 		pmd = walk_pmd(vmid, pud, addr, 0U);
 		if (v_pmd_table(pmd) == PMD_TYPE_TABLE)
 		{
-			print_string("\rset existing npt: pmd\n");
-			v_panic();
+			/* fallback to PTE */
+			perm = get_pfn_s2_perm(pfn, 3U);
+			pte = (pfn * PAGE_SIZE) | perm;
+			set_npt(vmid, addr, 3U, pte);
 		}
 		else
 		{
@@ -111,10 +140,17 @@ void __hyp_text set_npt(u32 vmid, u64 addr, u32 level, u64 pte)
 	}
 	else
 	{
-		pmd = walk_pmd(vmid, pud, addr, 1U);
-		if (v_pmd_table(pmd) == PMD_TYPE_TABLE)
+		if (v_pud_table(pud) == PUD_TYPE_TABLE)
 		{
-			v_set_pte(vmid, pmd, addr, pte);
+			pmd = walk_pmd(vmid, pud, addr, 1U);
+			if (v_pmd_table(pmd) == PMD_TYPE_TABLE) {
+				v_set_pte(vmid, pmd, addr, pte);
+			}
+			else
+			{
+				print_string("\rset existing npt: pte\n");
+				v_panic();
+			}
 		}
 		else
 		{
diff --git a/arch/arm64/sekvm/PTAlloc.c b/arch/arm64/sekvm/PTAlloc.c
index 00c47ed4..77ed299f 100644
--- a/arch/arm64/sekvm/PTAlloc.c
+++ b/arch/arm64/sekvm/PTAlloc.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/PTWalk.c b/arch/arm64/sekvm/PTWalk.c
index e073c547..7b474b19 100644
--- a/arch/arm64/sekvm/PTWalk.c
+++ b/arch/arm64/sekvm/PTWalk.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
@@ -92,13 +91,25 @@ u64 __hyp_text walk_pte(u32 vmid, u64 pmd, u64 addr)
 	return check64(ret);
 }
 
+void __hyp_text v_set_pud(u32 vmid, u64 pgd, u64 addr, u64 pud)
+{
+	u64 pgd_pa, pud_idx;
+
+	pgd_pa = phys_page(pgd);
+	pud_idx = pud_idx(addr);
+	if (pud != 0UL)
+		pud |= PUD_MARK;
+	pt_store(vmid, pgd_pa | (pud_idx * 8UL), pud);
+}
+
 void __hyp_text v_set_pmd(u32 vmid, u64 pud, u64 addr, u64 pmd)
 {
 	u64 pud_pa, pmd_idx;
 
 	pud_pa = phys_page(pud);
 	pmd_idx = pmd_idx(addr);
-	pmd |= PMD_MARK;
+	if (pmd != 0UL)
+		pmd |= PMD_MARK;
 	pt_store(vmid, pud_pa | (pmd_idx * 8UL), pmd);
 }
 
@@ -107,6 +118,7 @@ void __hyp_text v_set_pte(u32 vmid, u64 pmd, u64 addr, u64 pte)
 	u64 pmd_pa, pte_idx;
 	pmd_pa = phys_page(pmd);
 	pte_idx = pte_idx(addr);
-	pte |= PTE_MARK;
+	if (pte != 0UL)
+		pte |= PTE_MARK;
 	pt_store(vmid, pmd_pa | (pte_idx * 8UL), pte);
 }
diff --git a/arch/arm64/sekvm/PageIndex.c b/arch/arm64/sekvm/PageIndex.c
index 714b8bf0..18e7026c 100644
--- a/arch/arm64/sekvm/PageIndex.c
+++ b/arch/arm64/sekvm/PageIndex.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/PageMgmt.c b/arch/arm64/sekvm/PageMgmt.c
index 2a724227..a3a7e678 100644
--- a/arch/arm64/sekvm/PageMgmt.c
+++ b/arch/arm64/sekvm/PageMgmt.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/SmmuAux.c b/arch/arm64/sekvm/SmmuAux.c
index 332dbb7a..380565d4 100644
--- a/arch/arm64/sekvm/SmmuAux.c
+++ b/arch/arm64/sekvm/SmmuAux.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
@@ -11,7 +10,7 @@ u32 __hyp_text is_smmu_range(u64 addr)
 	i = 0U;
 	res = V_INVALID;
 
-	while (i < total_smmu)
+	while (i < total_smmu) 
 	{
 		base = get_smmu_base(i);
 		size = get_smmu_size(i);
@@ -47,4 +46,4 @@ void __hyp_text handle_host_mmio(u64 index, u32 hsr)
 		handle_smmu_write(hsr, fault_ipa, len, index);
 		host_skip_instr();
 	}
-}
+}
\ No newline at end of file
diff --git a/arch/arm64/sekvm/SmmuCore.c b/arch/arm64/sekvm/SmmuCore.c
index 05047a1d..db4f7593 100644
--- a/arch/arm64/sekvm/SmmuCore.c
+++ b/arch/arm64/sekvm/SmmuCore.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
@@ -79,4 +78,4 @@ void __hyp_text handle_smmu_read(u32 hsr, u64 fault_ipa, u32 len)
 	{
 		__handle_smmu_read(hsr, fault_ipa, len);
 	}	
-}
+}
\ No newline at end of file
diff --git a/arch/arm64/sekvm/SmmuCoreAux.c b/arch/arm64/sekvm/SmmuCoreAux.c
index 085c3a8d..1d4d9633 100644
--- a/arch/arm64/sekvm/SmmuCoreAux.c
+++ b/arch/arm64/sekvm/SmmuCoreAux.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
diff --git a/arch/arm64/sekvm/SmmuOps.c b/arch/arm64/sekvm/SmmuOps.c
index 7cc948a7..65793542 100644
--- a/arch/arm64/sekvm/SmmuOps.c
+++ b/arch/arm64/sekvm/SmmuOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
@@ -16,6 +15,7 @@ u32 __hyp_text emulate_mmio(u64 addr, u32 hsr)
 	return ret;
 }
 
+
 void __hyp_text  __el2_free_smmu_pgd(u32 cbndx, u32 index)
 {
 	u32 vmid, power;
diff --git a/arch/arm64/sekvm/SmmuRaw.c b/arch/arm64/sekvm/SmmuRaw.c
index 0ca2e8ab..a9fbce3c 100644
--- a/arch/arm64/sekvm/SmmuRaw.c
+++ b/arch/arm64/sekvm/SmmuRaw.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include "MmioOps.h"
 
diff --git a/arch/arm64/sekvm/TrapDispatcher.c b/arch/arm64/sekvm/TrapDispatcher.c
index efe27fa8..bdb9425f 100644
--- a/arch/arm64/sekvm/TrapDispatcher.c
+++ b/arch/arm64/sekvm/TrapDispatcher.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/types.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_hyp.h>
@@ -53,11 +52,14 @@ static void __hyp_text hvc_enable_s2_trans(void)
 
 	if (!el2_data->installed) {
 		protect_el2_mem();
+#ifdef CONFIG_KERNEL_INT
+		init_s2_page();
+		init_el1_pts();
+#endif
 		el2_data->installed = true;
 	}
 
 	__init_stage2_translation();
-
 	write_sysreg(el2_data->host_vttbr, vttbr_el2);
 	write_sysreg(HCR_HOST_NVHE_FLAGS, hcr_el2);
 	__kvm_flush_vm_context();
@@ -82,7 +84,7 @@ void __hyp_text	handle_host_hvc(struct s2_host_regs *hr)
 	ret = 0;
 	ret64 = 0;
 	callno = hr->regs[0];
-
+		
 	if (callno == HVC_ENABLE_S2_TRANS)
 	{
 		hvc_enable_s2_trans();
@@ -165,6 +167,39 @@ void __hyp_text	handle_host_hvc(struct s2_host_regs *hr)
 	{
 		el2_kvm_phys_addr_ioremap((u32)arg1, arg2, arg3, arg4);
 	}
+	
+#ifdef CONFIG_KERNEL_INT
+	else if (callno == HVC_MLOAD)
+	{
+		ret = el2_load_module(arg1, arg2, arg3, arg4, (u32)arg5);
+		set_host_regs(0, ret);
+	}
+
+	else if (callno == HVC_MFREE)
+	{
+		ret = el2_free_module(arg1);
+		set_host_regs(0, ret);
+	}
+
+	else if (callno == HVC_MOD_INIT_FREE)
+	{
+		ret = el2_free_mod_init(arg1);
+		set_host_regs(0, ret);
+	}
+	else if (callno == HVC_ALLOC_EL0_PGD)
+	{
+		el2_do_alloc_el0_pgd(arg1);
+	}
+	else if (callno == HVC_FREE_EL0_PGD)
+	{
+		el2_do_free_el0_pgd(arg1);
+	}
+#endif
+	else if (callno == HVC_DO_SWITCH_MM)
+	{
+		ret = el2_do_switch_mm(arg1, arg2);
+		set_host_regs(0, ret);
+	}
 	else
 	{
 		print_string("\rno support hvc:\n");
diff --git a/arch/arm64/sekvm/VCPUOps.c b/arch/arm64/sekvm/VCPUOps.c
index db1b4f94..92716c25 100644
--- a/arch/arm64/sekvm/VCPUOps.c
+++ b/arch/arm64/sekvm/VCPUOps.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/VCPUOpsAux.c b/arch/arm64/sekvm/VCPUOpsAux.c
index f9216c6a..31a62d10 100644
--- a/arch/arm64/sekvm/VCPUOpsAux.c
+++ b/arch/arm64/sekvm/VCPUOpsAux.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 #include <uapi/linux/psci.h>
 
diff --git a/arch/arm64/sekvm/VMPower.c b/arch/arm64/sekvm/VMPower.c
index 58f01454..dc734e0d 100644
--- a/arch/arm64/sekvm/VMPower.c
+++ b/arch/arm64/sekvm/VMPower.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include "hypsec.h"
 
 /*
diff --git a/arch/arm64/sekvm/el1.c b/arch/arm64/sekvm/el1.c
index 1fb29296..218619d6 100644
--- a/arch/arm64/sekvm/el1.c
+++ b/arch/arm64/sekvm/el1.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/types.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_hyp.h>
@@ -19,6 +18,11 @@
 #include <asm/spinlock_types.h>
 #include <linux/serial_reg.h>
 
+#ifdef CONFIG_KERNEL_INT
+#include <asm/pgtable.h>
+#include <asm/memory.h>
+#endif 
+
 #include "hypsec.h"
 
 u64 mach_phys_mem_start;
@@ -31,6 +35,23 @@ u64 mach_phys_mem_size;
 #define CRm(_x) 	.CRm = _x
 #define Op2(_x) 	.Op2 = _x
 
+#ifdef CONFIG_KERNEL_INT
+extern const struct kernel_symbol __start___ksymtab[];
+extern const struct kernel_symbol __stop___ksymtab[];
+extern const struct kernel_symbol __start___ksymtab_gpl[];
+extern const struct kernel_symbol __stop___ksymtab_gpl[];
+extern char vdso_start[], vdso_end[];
+#endif
+
+extern u64 host_s1_mem_base;
+extern u64 host_s1_mem_size;
+extern u64 host_s1_pgtable_mem_base;
+extern u64 host_s1_pgtable_mem_size;
+extern u64 host_s1_module_ro_base;
+extern u64 host_s1_module_ro_size;
+extern u64 host_s1_module_text_base;
+extern u64 host_s1_module_text_size;
+
 #define SYS_DESC(reg)					\
 	Op0(sys_reg_Op0(reg)), Op1(sys_reg_Op1(reg)),	\
 	CRn(sys_reg_CRn(reg)), CRm(sys_reg_CRm(reg)),	\
@@ -196,6 +217,7 @@ void init_el2_data_page(void)
 	memset(el2_data->vm_info, 0,
 		sizeof(struct el2_vm_info) * EL2_VM_INFO_SIZE);
 	el2_data->last_remap_ptr = 0;
+	
 
 	pool_start = el2_data->page_pool_start + STAGE2_CORE_PAGES_SIZE + STAGE2_HOST_POOL_SIZE;
 	for (i = 1; i < EL2_VM_INFO_SIZE - 1; i++) {
@@ -276,6 +298,48 @@ void init_el2_data_page(void)
 	el2_memcpy(el2_data->key, key, 16);
 	el2_memcpy(el2_data->iv, iv, 16);
 
+	el2_data->host_s1_mem_base = host_s1_mem_base;
+	el2_data->host_s1_mem_size = host_s1_mem_size;
+
+	/* kernel page table pool */
+	el2_data->host_s1_pgtable_mem_base = host_s1_pgtable_mem_base;
+	el2_data->host_s1_pgtable_mem_size = host_s1_pgtable_mem_size;
+
+	/* kernel module text section pool */
+	el2_data->host_s1_module_text_base = host_s1_module_text_base;
+	el2_data->host_s1_module_text_size = host_s1_module_text_size;
+
+	/* kernel module ro section pool */
+	el2_data->host_s1_module_ro_base = host_s1_module_ro_base;
+	el2_data->host_s1_module_ro_size = host_s1_module_ro_size;
+
+
+#ifdef CONFIG_KERNEL_INT
+	el2_data->text				= __pa_symbol(_text);
+	el2_data->etext				= __pa_symbol(_etext);
+	el2_data->rodata			= __pa_symbol(__start_rodata);
+	el2_data->erodata			= __pa_symbol(__inittext_begin);
+	el2_data->vdso_start		= __pa_symbol(vdso_start);
+	el2_data->vdso_end			= __pa_symbol(vdso_end);
+	el2_data->init_text_begin 	= __pa_symbol(__inittext_begin);
+	el2_data->init_text_end 	= __pa_symbol(__inittext_end);
+	el2_data->data 				= __pa_symbol(_data);
+	el2_data->edata 			= __pa_symbol(_end);
+	el2_data->host_ttbr1 		= __pa_symbol(swapper_pg_dir);
+	el2_data->host_zero_page	= __pa_symbol(empty_zero_page);
+	el2_data->kimage_voff 		= kimage_voffset; 
+	el2_data->next_modid 		= 0UL; 
+	memset(&el2_data->mod_info, 0, sizeof(struct el2_mod)*EL2_MOD_INFO_SIZE);
+	
+	el2_data->kernel_symtab.start_ksymtab 	= __pa_symbol(__start___ksymtab);
+	el2_data->kernel_symtab.stop_ksymtab	= __pa_symbol(__stop___ksymtab);
+
+	el2_data->kernel_symtab.start_ksymtab_gpl 	= __pa_symbol(__start___ksymtab_gpl);
+	el2_data->kernel_symtab.stop_ksymtab_gpl 	= __pa_symbol(__stop___ksymtab_gpl);
+
+	/* It is recommended tcr register cannot be modified after booting */
+	el2_data->host_tcr_flag = read_sysreg(tcr_el1) & INVALID64;
+#endif
 	return;
 }
 
@@ -463,6 +527,7 @@ struct kvm_vcpu* hypsec_alloc_vcpu(u32 vmid, int vcpu_id)
 	return &shared_data->vcpu_pool[index];
 }
 
+
 int el2_set_boot_info(u32 vmid, unsigned long load_addr,
 			unsigned long size, int type)
 {
@@ -550,3 +615,28 @@ void hypsec_phys_addr_ioremap(u32 vmid, u64 gpa, u64 pa, u64 size)
 {
 	kvm_call_core(HVC_PHYS_ADDR_IOREMAP, vmid, gpa, pa, size);
 }
+
+u32 el2_mod_checksum(u64 p_hdr, u64 mod_percpu, u64 mod_arch, u64 checklists, u32 entsize)
+{
+	kvm_call_core(HVC_MLOAD, p_hdr, mod_percpu, mod_arch, checklists, entsize);
+}
+
+u32 hyp_unload_init_mod(u32 mod_id)
+{
+	kvm_call_core(HVC_MOD_INIT_FREE, mod_id);
+}
+
+u32 hyp_free_module(u32 mod_id)
+{
+	kvm_call_core(HVC_MFREE, mod_id);
+}
+
+void hyp_alloc_el0_pgd(u64 addr)
+{
+	kvm_call_core(HVC_ALLOC_EL0_PGD, addr);
+}
+
+void hyp_free_el0_pgd(u64 addr)
+{
+	kvm_call_core(HVC_FREE_EL0_PGD, addr);
+}
diff --git a/arch/arm64/sekvm/el2.c b/arch/arm64/sekvm/el2.c
index e5eeb00d..77bf72b9 100644
--- a/arch/arm64/sekvm/el2.c
+++ b/arch/arm64/sekvm/el2.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/types.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_hyp.h>
diff --git a/arch/arm64/sekvm/hypsec.h b/arch/arm64/sekvm/hypsec.h
index 239c287b..426ac3d4 100644
--- a/arch/arm64/sekvm/hypsec.h
+++ b/arch/arm64/sekvm/hypsec.h
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef HYPSEC_HYPSEC_H
 #define HYPSEC_HYPSEC_H
 
@@ -23,7 +22,10 @@
 
 #include <asm/hypsec_constant.h>
 
-typedef unsigned long long u64;
+#ifdef CONFIG_KERNEL_INT
+#include <asm/module.h>
+#endif
+
 typedef unsigned u32;
 typedef u64 phys_addr_t;
 
@@ -31,11 +33,11 @@ typedef u64 phys_addr_t;
  * AbstractMachine
  */
 
-static u32 inline check(u32 val) {
+static u32 inline check(u32 val){
 	return val;
 };
 
-static u64 inline check64(u64 val) {
+static u64 inline check64(u64 val){
 	return val;
 };
 
@@ -47,38 +49,39 @@ u32     verify_image(u32 vmid, u32 load_idx, u64 addr);
 ///u64     get_sys_reg_desc_val(u32 index);
 u64     get_exception_vector(u64 pstate);
 
-static u64 inline get_shared_kvm(u32 vmid) {
-    //return SHARED_KVM_START + vmid * sizeof(struct kvm);
-    u64 shared_kvm_start = (u64)kvm_ksym_ref(shared_data_start);
-    return shared_kvm_start + vmid * sizeof(struct kvm);
+static u64 inline get_shared_kvm(u32 vmid){
+	//return SHARED_KVM_START + vmid * sizeof(struct kvm);
+	u64 shared_kvm_start = (u64)kvm_ksym_ref(shared_data_start);
+	return shared_kvm_start + vmid * sizeof(struct kvm);
 }
 
-static u64 inline get_shared_vcpu(u32 vmid, u32 vcpuid) {
-    u64 vcpu_off = sizeof(struct kvm) * EL2_MAX_VMID;
-    u64 shared_vcpu_start = (u64)kvm_ksym_ref(shared_data_start) + vcpu_off;
-    return shared_vcpu_start + (vmid * VCPU_PER_VM + vcpuid) * sizeof(struct kvm_vcpu);
+static u64 inline get_shared_vcpu(u32 vmid, u32 vcpuid){
+	u64 vcpu_off = sizeof(struct kvm) * EL2_MAX_VMID;
+	u64 shared_vcpu_start = (u64)kvm_ksym_ref(shared_data_start) + vcpu_off;
+	return shared_vcpu_start +
+	       (vmid * VCPU_PER_VM + vcpuid) * sizeof(struct kvm_vcpu);
 }
 
-static u64 inline get_sys_reg_desc_val(u32 index) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->s2_sys_reg_descs[index].val;
+static u64 inline get_sys_reg_desc_val(u32 index){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->s2_sys_reg_descs[index].val;
 }
 
-static void inline fetch_from_doracle(u32 vmid, u64 pfn, u64 pgnum) {
+static void inline fetch_from_doracle(u32 vmid, u64 pfn, u64 pgnum){
 	return;
 }
 extern void reset_fp_regs(u32 vmid, int vcpu_id);
 
-static u64 inline get_vm_fault_addr(u32 vmid, u32 vcpuid) {
+static u64 inline get_vm_fault_addr(u32 vmid, u32 vcpuid){
 	u64 hpfar;
 	hpfar = get_shadow_ctxt(vmid, vcpuid, V_HPFAR_EL2);
 	return ((hpfar & HPFAR_MASK) * 256UL);
 }
 
-static void inline mem_load_raw(u64 gfn, u32 reg) {
+static void inline mem_load_raw(u64 gfn, u32 reg){
 }
 
-static void inline mem_store_raw(u64 gfn, u32 reg) {
+static void inline mem_store_raw(u64 gfn, u32 reg){
 }
 /*
 void    acquire_lock_pt(u32 vmid);
@@ -91,22 +94,23 @@ u64     get_pt_vttbr(u32 vmid);
 void    set_pt_vttbr(u32 vmid, u64 vttbr);
 */
 
-static void inline acquire_lock_pt(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_lock(&el2_data->vm_info[vmid].shadow_pt_lock);
+static void inline acquire_lock_pt(u32 vmid)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->vm_info[vmid].shadow_pt_lock);
 };
 
-static void inline release_lock_pt(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_unlock(&el2_data->vm_info[vmid].shadow_pt_lock);
+static void inline release_lock_pt(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->vm_info[vmid].shadow_pt_lock);
 };
 
-static u64 inline pt_load(u32 vmid, u64 addr) {
+static u64 inline pt_load(u32 vmid, u64 addr){
 	unsigned long *ptr = __el2_va(addr);
 	return (u64)*ptr;
 };
 
-static void inline pt_store(u32 vmid, u64 addr, u64 value) {
+static void inline pt_store(u32 vmid, u64 addr, u64 value){
 	unsigned long *ptr = __el2_va(addr);
 	*ptr = value;
 };
@@ -115,32 +119,32 @@ static void inline pt_store(u32 vmid, u64 addr, u64 value) {
 #define PGD_BASE (PAGE_SIZE * 2)
 #define PUD_BASE (PGD_BASE + (PAGE_SIZE * 16))
 #define PMD_BASE SZ_2M
-static u64 inline get_pgd_next(u32 vmid) {
+static u64 inline get_pgd_next(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	return el2_data->vm_info[vmid].pgd_pool;
 };
 
-static void inline set_pgd_next(u32 vmid, u64 next) {
+static void inline set_pgd_next(u32 vmid, u64 next){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	el2_data->vm_info[vmid].pgd_pool = next;
 };
 
-static u64 inline get_pud_next(u32 vmid) {
+static u64 inline get_pud_next(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	return el2_data->vm_info[vmid].pud_pool;
 };
 
-static void inline set_pud_next(u32 vmid, u64 next) {
+static void inline set_pud_next(u32 vmid, u64 next){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	el2_data->vm_info[vmid].pud_pool = next;
 };
 
-static u64 inline get_pmd_next(u32 vmid) {
+static u64 inline get_pmd_next(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	return el2_data->vm_info[vmid].pmd_pool;
 };
 
-static void inline set_pmd_next(u32 vmid, u64 next) {
+static void inline set_pmd_next(u32 vmid, u64 next){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	el2_data->vm_info[vmid].pmd_pool = next;
 };
@@ -148,13 +152,13 @@ static void inline set_pmd_next(u32 vmid, u64 next) {
 #define HOST_PUD_BASE (PGD_BASE + PAGE_SIZE * 128)
 #define HOST_PMD_BASE (SZ_2M * 2)
 
-static u64 inline pgd_pool_end(u32 vmid) {
+static u64 inline pgd_pool_end(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	u64 pool_start = el2_data->vm_info[vmid].page_pool_start;
 	return pool_start + PUD_BASE;
 }
 
-static u64 inline pud_pool_end(u32 vmid) {
+static u64 inline pud_pool_end(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	u64 pool_start = el2_data->vm_info[vmid].page_pool_start;
 	if (vmid == HOSTVISOR)
@@ -163,7 +167,7 @@ static u64 inline pud_pool_end(u32 vmid) {
 		return pool_start + PMD_BASE;
 }
 
-static u64 inline pmd_pool_end(u32 vmid) {
+static u64 inline pmd_pool_end(u32 vmid){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	u64 pool_start = el2_data->vm_info[vmid].page_pool_start;
 	if (vmid == COREVISOR)
@@ -180,27 +184,27 @@ u64     get_mem_region_size(u32 index);
 u64     get_mem_region_index(u32 index);
 u64     get_mem_region_flag(u32 index);
 */
-static u32 inline get_mem_region_cnt(void) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u32 inline get_mem_region_cnt(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	return el2_data->regions_cnt;
 }
 
-static u64 inline get_mem_region_base(u32 index) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u64 inline get_mem_region_base(u32 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	return el2_data->regions[index].base;
 }
-static u64 inline get_mem_region_size(u32 index) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u64 inline get_mem_region_size(u32 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	return el2_data->regions[index].size;
 }
 
-static u64 inline get_mem_region_index(u32 index) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u64 inline get_mem_region_index(u32 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	return el2_data->s2_memblock_info[index].index;
 }
 
-static u64 inline get_mem_region_flag(u32 index) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u64 inline get_mem_region_flag(u32 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	return el2_data->regions[index].flags;
 }
 
@@ -213,46 +217,150 @@ u32     get_s2_page_count(u64 index);
 void    set_s2_page_count(u64 index, u32 count);
 */
 
-static void inline acquire_lock_s2page(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_lock(&el2_data->s2pages_lock);
+static void inline acquire_lock_s2page(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->s2pages_lock);
+}
+
+static void inline release_lock_s2page(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->s2pages_lock);
+}
+
+static u32 inline get_s2_page_vmid(u64 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].vmid;
+}
+
+static void inline set_s2_page_vmid(u64 index, u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].vmid = vmid;
 }
 
-static void inline release_lock_s2page(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_unlock(&el2_data->s2pages_lock);
+static u32 inline get_s2_page_count(u64 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].count;
 }
 
-static u32 inline get_s2_page_vmid(u64 index) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->s2_pages[index].vmid;
+static void inline set_s2_page_count(u64 index, u32 count){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].count = count;
 }
 
-static void inline set_s2_page_vmid(u64 index, u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->s2_pages[index].vmid = vmid;
+static u64 inline get_s2_page_gfn(u64 index){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].gfn;
 }
 
-static u32 inline get_s2_page_count(u64 index) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->s2_pages[index].count;
+static void inline set_s2_page_gfn(u64 index, u64 gfn){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].gfn = gfn;
 }
 
-static void inline set_s2_page_count(u64 index, u32 count) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->s2_pages[index].count = count;
+static u64 inline get_host_ttbr1(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+    return el2_data->host_ttbr1;
 }
 
-static u64 inline get_s2_page_gfn(u64 index) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->s2_pages[index].gfn;
+static void inline set_host_ttbr1(u64 addr)
+{
+	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+    el2_data->host_ttbr1 = addr;
 }
 
-static void inline set_s2_page_gfn(u64 index, u64 gfn) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->s2_pages[index].gfn = gfn;
+static u64 inline get_host_zero_page(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+    return el2_data->host_zero_page;
+}
+
+#ifdef CONFIG_KERNEL_INT
+static void inline set_s2_page_subcount(u64 index, u32 subcount)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].subcount = subcount;
 }
 
+static u32 inline get_s2_page_subcount(u64 index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].subcount;
+}
+
+static void inline set_s2_page_dynamic(u64 index, u32 dynamic)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].dynamic = dynamic;
+}
+
+static u32 inline get_s2_page_dynamic(u64 index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].dynamic;
+}
+
+static void inline set_s2_page_kpt_index(u64 index, u64 kpt_index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].kpt_index = kpt_index;
+}
+
+static u64 inline get_s2_page_kpt_index(u64 index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].kpt_index;
+}
+
+static void inline set_s2_page_el1_va(u64 index, u64 el1_va)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].el1_va = el1_va;
+}
+
+static u64 inline get_s2_page_el1_va(u64 index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].el1_va;
+}
+
+void el2_pt_dump(void);
+
+
+
+void __hyp_text set_pfn_kpt_index(u64 pfn, u64 kpt_index);
+u64 __hyp_text get_pfn_kpt_index(u64 pfn);
+void __hyp_text set_pfn_el1_va(u64 pfn, u64 el1_va);
+u64 __hyp_text get_pfn_el1_va(u64 pfn);
+u64 __hyp_text get_pfn_s2_perm(u64 pfn, u32 lvl);
+
+
+
+
+u32 __hyp_text el2_load_module(u64 p_hdr, u64 mod_percpu, u64 mod_arch, u64 checklists, u32 entsize);
+u32 __hyp_text el2_free_module(u32 mod_id);
+u32 __hyp_text el2_free_mod_init(u32 mod_id);
+void __hyp_text el2_do_alloc_el0_pgd(u64 addr);
+void __hyp_text el2_do_free_el0_pgd(u64 addr);
+
+u32 __hyp_text el2_do_switch_mm(u64 ttbr0, u64 asid);
+
+void __hyp_text test_el2(u64 struct_addr1, u64 struct_addr2);
+void __hyp_text init_el1_pts(void);
+void __hyp_text init_s2_page(void);
+
+u64 __hyp_text translate_to_phys(u64 v_addr);
+void __hyp_text host_kpt_handler(u64 addr, u32 hsr);
+
+#define ESR_EL2_DFSC_MASK (63UL)
+#define is_WP_fault(x, y) (x <= 0xf && x >= 0xc && y == 1)
+#define kint_pfn_pmd(pfn) (pfn << PAGE_SHIFT) & HUGE_PMD_MASK
+#define kint_mk_pmd(pfn, prot) ((kint_pfn_pmd(pfn)) | prot)
+#define kint_pfn_pud(pfn) (pfn << PAGE_SHIFT) & HUGE_PUD_MASK
+#define kint_mk_pud(pfn, prot) ((kint_pfn_pud(pfn)) | prot)
+
+#endif
+
 /*
 void    acquire_lock_vm(u32 vmid);
 void    release_lock_vm(u32 vmid);
@@ -279,134 +387,136 @@ void    set_vm_remap_addr(u32 vmid, u32 load_idx, u64 remap_addr);
 u64     get_vm_mapped_pages(u32 vmid, u32 load_idx);
 void    set_vm_mapped_pages(u32 vmid, u32 load_idx, u64 mapped);
 */
-static void inline acquire_lock_vm(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_lock(&el2_data->vm_info[vmid].vm_lock);
+static void inline acquire_lock_vm(u32 vmid)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->vm_info[vmid].vm_lock);
 }
 
-static void inline release_lock_vm(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_unlock(&el2_data->vm_info[vmid].vm_lock);
+static void inline release_lock_vm(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->vm_info[vmid].vm_lock);
 }
 
-static u32 inline get_vm_state(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].state;
+static u32 inline get_vm_state(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].state;
 }
 
-static void inline set_vm_state(u32 vmid, u32 state) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].state = state;
+static void inline set_vm_state(u32 vmid, u32 state){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].state = state;
 }
 
-static u32 inline get_vcpu_first_run(u32 vmid, u32 vcpuid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].int_vcpus[vcpuid].first_run;
+static u32 inline get_vcpu_first_run(u32 vmid, u32 vcpuid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].int_vcpus[vcpuid].first_run;
 }
 
-static void inline set_vcpu_first_run(u32 vmid, u32 vcpuid, u32 state) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].int_vcpus[vcpuid].first_run = state;
+static void inline set_vcpu_first_run(u32 vmid, u32 vcpuid, u32 state){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].int_vcpus[vcpuid].first_run = state;
 }
 
-static u32 inline get_vcpu_state(u32 vmid, u32 vcpuid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].int_vcpus[vcpuid].state;
+static u32 inline get_vcpu_state(u32 vmid, u32 vcpuid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].int_vcpus[vcpuid].state;
 }
 
-static void inline set_vcpu_state(u32 vmid, u32 vcpuid, u32 state) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].int_vcpus[vcpuid].state = state;
+static void inline set_vcpu_state(u32 vmid, u32 vcpuid, u32 state){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].int_vcpus[vcpuid].state = state;
 }
 
-static void inline set_vm_power(u32 vmid, u32 power) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].powered_on = power;
+static void inline set_vm_power(u32 vmid, u32 power){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].powered_on = power;
 }
 
-static u32 inline get_vm_power(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].powered_on;
+static u32 inline get_vm_power(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].powered_on;
 }
 
-static u32 inline get_vm_inc_exe(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].inc_exe;
+static u32 inline get_vm_inc_exe(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].inc_exe;
 }
 
-static void inline set_vm_inc_exe(u32 vmid, u32 inc_exe) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].inc_exe = inc_exe;
+static void inline set_vm_inc_exe(u32 vmid, u32 inc_exe){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].inc_exe = inc_exe;
 }
 
-static u64 inline get_vm_kvm(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return (u64)el2_data->vm_info[vmid].kvm;
+static u64 inline get_vm_kvm(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return (u64)el2_data->vm_info[vmid].kvm;
 }
 
-static void inline set_vm_kvm(u32 vmid, u64 kvm) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].kvm = (struct kvm*)kvm;
+static void inline set_vm_kvm(u32 vmid, u64 kvm){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].kvm = (struct kvm *)kvm;
 }
 
-static u64 inline get_vm_vcpu(u32 vmid, u32 vcpuid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return (u64)el2_data->vm_info[vmid].int_vcpus[vcpuid].vcpu;
+static u64 inline get_vm_vcpu(u32 vmid, u32 vcpuid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return (u64)el2_data->vm_info[vmid].int_vcpus[vcpuid].vcpu;
 }
 
-static void inline set_vm_vcpu(u32 vmid, u32 vcpuid, u64 vcpu) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    el2_data->vm_info[vmid].int_vcpus[vcpuid].vcpu = (struct kvm_vcpu*)vcpu;
+static void inline set_vm_vcpu(u32 vmid, u32 vcpuid, u64 vcpu){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->vm_info[vmid].int_vcpus[vcpuid].vcpu =
+		(struct kvm_vcpu *)vcpu;
 }
 
-static u32 inline get_vm_next_load_idx(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    return el2_data->vm_info[vmid].load_info_cnt;
+static u32 inline get_vm_next_load_idx(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->vm_info[vmid].load_info_cnt;
 }
 
-static void inline set_vm_next_load_idx(u32 vmid, u32 load_idx) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->vm_info[vmid].load_info_cnt = load_idx;
+static void inline set_vm_next_load_idx(u32 vmid, u32 load_idx){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->vm_info[vmid].load_info_cnt = load_idx;
 }
 
-static u64 inline get_vm_load_addr(u32 vmid, u32 load_idx) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->vm_info[vmid].load_info[load_idx].load_addr;
+static u64 inline get_vm_load_addr(u32 vmid, u32 load_idx){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->vm_info[vmid].load_info[load_idx].load_addr;
 }
 
-static void inline set_vm_load_addr(u32 vmid, u32 load_idx, u64 load_addr) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->vm_info[vmid].load_info[load_idx].load_addr = load_addr;
+static void inline set_vm_load_addr(u32 vmid, u32 load_idx, u64 load_addr){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->vm_info[vmid].load_info[load_idx].load_addr = load_addr;
 }
 
-static u64 inline get_vm_load_size(u32 vmid, u32 load_idx) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->vm_info[vmid].load_info[load_idx].size;
+static u64 inline get_vm_load_size(u32 vmid, u32 load_idx){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->vm_info[vmid].load_info[load_idx].size;
 }
 
-static void inline set_vm_load_size(u32 vmid, u32 load_idx, u64 size) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->vm_info[vmid].load_info[load_idx].size = size;
+static void inline set_vm_load_size(u32 vmid, u32 load_idx, u64 size){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->vm_info[vmid].load_info[load_idx].size = size;
 }
 
-static u64 inline get_vm_remap_addr(u32 vmid, u32 load_idx) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->vm_info[vmid].load_info[load_idx].el2_remap_addr;
+static u64 inline get_vm_remap_addr(u32 vmid, u32 load_idx){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->vm_info[vmid].load_info[load_idx].el2_remap_addr;
 }
 
-static void inline set_vm_remap_addr(u32 vmid, u32 load_idx, u64 remap_addr) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->vm_info[vmid].load_info[load_idx].el2_remap_addr = remap_addr;
+static void inline set_vm_remap_addr(u32 vmid, u32 load_idx, u64 remap_addr){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->vm_info[vmid].load_info[load_idx].el2_remap_addr = remap_addr;
 }
 
-static u64 inline get_vm_mapped_pages(u32 vmid, u32 load_idx) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->vm_info[vmid].load_info[load_idx].el2_mapped_pages;
+static u64 inline get_vm_mapped_pages(u32 vmid, u32 load_idx){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->vm_info[vmid].load_info[load_idx].el2_mapped_pages;
 }
 
-static void inline set_vm_mapped_pages(u32 vmid, u32 load_idx, u64 mapped) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->vm_info[vmid].load_info[load_idx].el2_mapped_pages = mapped;
+static void inline set_vm_mapped_pages(u32 vmid, u32 load_idx, u64 mapped){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->vm_info[vmid].load_info[load_idx].el2_mapped_pages = mapped;
 }
 
 /*
@@ -417,34 +527,34 @@ void    set_next_vmid(u32 vmid);
 u64     get_next_remap_ptr(void);
 void    set_next_remap_ptr(u64 remap);
 */
-static void inline acquire_lock_core(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_lock(&el2_data->abs_lock);
+static void inline acquire_lock_core(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->abs_lock);
 }
 
-static void inline release_lock_core(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_unlock(&el2_data->abs_lock);
+static void inline release_lock_core(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->abs_lock);
 }
 
-static u32 inline get_next_vmid(void) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->next_vmid;
+static u32 inline get_next_vmid(void){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->next_vmid;
 }
 
-static void inline set_next_vmid(u32 vmid) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->next_vmid = vmid;
+static void inline set_next_vmid(u32 vmid){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->next_vmid = vmid;
 }
 
-static u64 inline get_next_remap_ptr(void) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    return el2_data->last_remap_ptr + EL2_REMAP_START;
+static u64 inline get_next_remap_ptr(void){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	return el2_data->last_remap_ptr + EL2_REMAP_START;
 }
 
-static void inline set_next_remap_ptr(u64 remap) {
-    struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
-    el2_data->last_remap_ptr = remap;
+static void inline set_next_remap_ptr(u64 remap){
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	el2_data->last_remap_ptr = remap;
 }
 
 //int     get_cur_vmid(void);
@@ -452,7 +562,7 @@ static void inline set_next_remap_ptr(u64 remap) {
 //u64     get_int_gpr(u32 vmid, u32 vcpuid, u32 index);
 //u64     get_int_pc(u32 vmid, u32 vcpuid);
 //u64     get_int_pstate(u32 vmid, u32 vcpuid);
-static u64 inline get_int_gpr(u32 vmid, u32 vcpuid, u32 index) {
+static u64 inline get_int_gpr(u32 vmid, u32 vcpuid, u32 index){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -463,7 +573,7 @@ static u64 inline get_int_gpr(u32 vmid, u32 vcpuid, u32 index) {
 	return vcpu->arch.ctxt.gp_regs.regs.regs[index];
 }
 
-static u64 inline get_int_pc(u32 vmid, u32 vcpuid) {
+static u64 inline get_int_pc(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -472,7 +582,7 @@ static u64 inline get_int_pc(u32 vmid, u32 vcpuid) {
 	return vcpu->arch.ctxt.gp_regs.regs.pc;
 }
 
-static u64 inline get_int_pstate(u32 vmid, u32 vcpuid) {
+static u64 inline get_int_pstate(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -482,32 +592,32 @@ static u64 inline get_int_pstate(u32 vmid, u32 vcpuid) {
 }
 
 //void	set_int_gpr(u32 vmid, u32 vcpuid, u32 index, u64 value);
-static void inline set_int_gpr(u32 vmid, u32 vcpuid, u32 index, u64 value) {
-       struct shared_data *shared_data;
-       int offset = VCPU_IDX(vmid, vcpuid);
-       struct kvm_vcpu *vcpu;
-       if (index >= 32)
-               __hyp_panic();
-       shared_data = kern_hyp_va(kvm_ksym_ref(shared_data_start));
-       vcpu = &shared_data->vcpu_pool[offset];
-       vcpu->arch.ctxt.gp_regs.regs.regs[index] = value;
-}
-
-void	set_int_pstate(u32 vmid, u32 vcpuid, u64 value);
-void    clear_shadow_gp_regs(u32 vmid, u32 vcpuid);
-void    int_to_shadow_fp_regs(u32 vmid, u32 vcpuid);
-void    int_to_shadow_decrypt(u32 vmid, u32 vcpuid);
-void    shadow_to_int_encrypt(u32 vmid, u32 vcpuid);
+static void inline set_int_gpr(u32 vmid, u32 vcpuid, u32 index, u64 value){
+	struct shared_data *shared_data;
+	int offset = VCPU_IDX(vmid, vcpuid);
+	struct kvm_vcpu *vcpu;
+	if (index >= 32)
+		__hyp_panic();
+	shared_data = kern_hyp_va(kvm_ksym_ref(shared_data_start));
+	vcpu = &shared_data->vcpu_pool[offset];
+	vcpu->arch.ctxt.gp_regs.regs.regs[index] = value;
+}
+
+void set_int_pstate(u32 vmid, u32 vcpuid, u64 value);
+void clear_shadow_gp_regs(u32 vmid, u32 vcpuid);
+void int_to_shadow_fp_regs(u32 vmid, u32 vcpuid);
+void int_to_shadow_decrypt(u32 vmid, u32 vcpuid);
+void shadow_to_int_encrypt(u32 vmid, u32 vcpuid);
 //u32     get_shadow_dirty_bit(u32 vmid, u32 vcpuid);
 //void    set_shadow_dirty_bit(u32 vmid, u32 vcpuid, u64 value);
-static u32 inline get_shadow_dirty_bit(u32 vmid, u32 vcpuid) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u32 inline get_shadow_dirty_bit(u32 vmid, u32 vcpuid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	int offset = VCPU_IDX(vmid, vcpuid);
 	return el2_data->shadow_vcpu_ctxt[offset].dirty;
 }
 
-static void inline set_shadow_dirty_bit(u32 vmid, u32 vcpuid, u64 value) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static void inline set_shadow_dirty_bit(u32 vmid, u32 vcpuid, u64 value){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	int offset = VCPU_IDX(vmid, vcpuid);
 	if (value)
 		el2_data->shadow_vcpu_ctxt[offset].dirty |= value;
@@ -517,7 +627,7 @@ static void inline set_shadow_dirty_bit(u32 vmid, u32 vcpuid, u64 value) {
 //u64     get_int_new_pte(u32 vmid, u32 vcpuid);
 //u32     get_int_new_level(u32 vmid, u32 vcpuid);
 //bool	get_int_writable(u32 vmid, u32 vcpuid);
-static bool inline get_int_writable(u32 vmid, u32 vcpuid) {
+static bool inline get_int_writable(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -526,7 +636,7 @@ static bool inline get_int_writable(u32 vmid, u32 vcpuid) {
 	return vcpu->arch.walk_result.writable;
 }
 
-static u64 inline get_int_new_pte(u32 vmid, u32 vcpuid) {
+static u64 inline get_int_new_pte(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -535,7 +645,7 @@ static u64 inline get_int_new_pte(u32 vmid, u32 vcpuid) {
 	return vcpu->arch.walk_result.output;
 }
 
-static u32 inline get_int_new_level(u32 vmid, u32 vcpuid) {
+static u32 inline get_int_new_level(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -547,13 +657,13 @@ static u32 inline get_int_new_level(u32 vmid, u32 vcpuid) {
 //u32     get_shadow_esr(u32 vmid, u32 vcpuid);
 //u32     get_int_esr(u32 vmid, u32 vcpuid);
 
-static u32 inline get_shadow_esr(u32 vmid, u32 vcpuid) {
-    	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static u32 inline get_shadow_esr(u32 vmid, u32 vcpuid){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	int offset = VCPU_IDX(vmid, vcpuid);
 	return el2_data->shadow_vcpu_ctxt[offset].esr;
 }
 
-static u32 inline get_int_esr(u32 vmid, u32 vcpuid) {
+static u32 inline get_int_esr(u32 vmid, u32 vcpuid){
 	struct shared_data *shared_data;
 	int offset = VCPU_IDX(vmid, vcpuid);
 	struct kvm_vcpu *vcpu;
@@ -565,67 +675,65 @@ static u32 inline get_int_esr(u32 vmid, u32 vcpuid) {
 extern void test_aes(struct el2_data *el2_data);
 
 //for image verification
-uint8_t* get_vm_public_key(u32 vmid);
+uint8_t *get_vm_public_key(u32 vmid);
 void set_vm_public_key(u32 vmid);
-uint8_t* get_vm_load_signature(u32 vmid, u32 load_idx);
+uint8_t *get_vm_load_signature(u32 vmid, u32 load_idx);
 void set_vm_load_signature(u32 vmid, u32 load_idx);
 
 //for SMMU
 #define SMMU_POOL_START 65536UL
 #define SMMU_PGD_START 131072UL
 #define SMMU_PMD_START 196608UL
-#define SMMU_POOL_END  SMMU_PAGES_SIZE	
+#define SMMU_POOL_END SMMU_PAGES_SIZE
 
-#define SMMU_PMD_BASE	(PAGE_SIZE * 256)
-static void inline acquire_lock_smmu(void) {
-	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+#define SMMU_PMD_BASE (PAGE_SIZE * 256)
+static void inline acquire_lock_smmu(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	stage2_spin_lock(&el2_data->smmu_lock);
 };
-static void inline release_lock_smmu(void) {
-	struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
+static void inline release_lock_smmu(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
 	stage2_spin_unlock(&el2_data->smmu_lock);
 };
 
-static u64 inline get_smmu_pgd_next(void) {
+static u64 inline get_smmu_pgd_next(void){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	return el2_data->smmu_pgd_pool;
 };
 
-static void inline set_smmu_pgd_next(u64 next) {
+static void inline set_smmu_pgd_next(u64 next){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	el2_data->smmu_pgd_pool = next;
 };
 
-static u64 inline smmu_pgd_end(void)
-{
+static u64 inline smmu_pgd_end(void){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	u64 pool_start = el2_data->smmu_page_pool_start;
 	return pool_start + SMMU_PMD_BASE;
 };
 
-static u64 inline get_smmu_pmd_next(void) {
+static u64 inline get_smmu_pmd_next(void){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	return el2_data->smmu_pmd_pool;
 };
 
-static void inline set_smmu_pmd_next(u64 next) {
+static void inline set_smmu_pmd_next(u64 next){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	el2_data->smmu_pmd_pool = next;
 };
 
-static u64 inline smmu_pmd_end(void)
-{
+static u64 inline smmu_pmd_end(void){
 	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
 	u64 pool_start = el2_data->smmu_page_pool_start;
 	return pool_start + SMMU_POOL_END;
 }
 
-static u64 inline smmu_pt_load(u64 addr) {
+static u64 inline smmu_pt_load(u64 addr){
 	unsigned long *ptr = __el2_va(addr);
 	return (u64)*ptr;
 };
 
-static void inline smmu_pt_store(u64 addr, u64 value) {
+static void inline smmu_pt_store(u64 addr, u64 value){
 	unsigned long *ptr = __el2_va(addr);
 	*ptr = value;
 };
@@ -675,24 +783,147 @@ static u64 inline get_phys_mem_start(void)
 	return el2_data->phys_mem_start;
 }
 
-static void inline acquire_lock_spt(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_lock(&el2_data->spt_lock);
+static bool inline check_host_s1pgtable(u64 addr)
+{
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	u64 base, size;
+	base = el2_data->host_s1_pgtable_mem_base;
+	size = el2_data->host_s1_pgtable_mem_size;
+
+	return ((addr >= base) && (addr < base + size)) ? true : false;
+}
+
+static bool inline check_host_module(u64 addr)
+{
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	u64 ro_base, ro_size, text_base, text_size;
+	ro_base = el2_data->host_s1_module_ro_base;
+	ro_size = el2_data->host_s1_module_ro_size;
+	text_base = el2_data->host_s1_module_text_base;
+	text_size = el2_data->host_s1_module_text_size;
+
+	return (((addr >= ro_base) && (addr < ro_base + ro_size))
+			|| ((addr >= text_base) && (addr < text_base + text_size))) ? true : false;
+}
+
+static bool inline check_host_vdso(u64 addr)
+{
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	u64 base, end;
+	base = el2_data->vdso_start;
+	end = el2_data->vdso_end;
+
+	return ((addr >= base) && (addr < end)) ? true : false;
+}
+
+static void inline acquire_lock_spt(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->spt_lock);
 };
 
-static void inline release_lock_spt(void) {
-    struct el2_data *el2_data = kern_hyp_va((void*)&el2_data_start);
-    stage2_spin_unlock(&el2_data->spt_lock);
+static void inline release_lock_spt(void){
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->spt_lock);
 };
 
 void encrypt_buf(u32 vmid, u64 in_buf, u64 out_buf, uint32_t len);
 void decrypt_buf(u32 vmid, u64 in_buf, u64 out_buf, uint32_t len);
 
-static u64 inline get_tmp_buf(void) {
-	u64 ret = (u64)kern_hyp_va((void*)&stage2_tmp_pgs_start);
+static u64 inline get_tmp_buf(void){
+	u64 ret = (u64)kern_hyp_va((void *)&stage2_tmp_pgs_start);
 	return ret;
 };
 
+#ifdef CONFIG_KERNEL_INT
+
+static void inline acquire_lock_host_kpt(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_lock(&el2_data->host_kpt_lock);
+};
+static void inline release_lock_host_kpt(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	stage2_spin_unlock(&el2_data->host_kpt_lock);
+};
+
+static u32 inline get_s2_page_subid(u64 index)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->s2_pages[index].subid;
+}
+
+static void inline set_s2_page_subid(u64 index, u32 subid)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	el2_data->s2_pages[index].subid = subid;
+}
+
+static bool inline in_kint_range(u64 addr, u64 align)
+{
+	struct el2_data *el2_data = kern_hyp_va(kvm_ksym_ref(el2_data_start));
+	u64 kernel_start, kernel_end, pool_start, pool_end;
+
+	kernel_start = el2_data->text & ~(align - 1);
+	kernel_end = ALIGN(el2_data->edata, align);
+
+	pool_start = el2_data->host_s1_mem_base & ~(align - 1);
+	pool_end = ALIGN(el2_data->host_s1_mem_base + el2_data->host_s1_mem_size,
+					align);
+
+	return (((addr >= kernel_start) && (addr < kernel_end))
+		   || ((addr >= pool_start) && (addr < pool_end)))
+			? true : false;
+}
+
+static u64 inline get_text(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->text;
+};
+
+static u64 inline get_etext(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->etext;
+};
+
+static u64 inline get_rodata(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->rodata;
+};
+
+static u64 inline get_erodata(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->erodata;
+};
+
+static u64 inline get_inittext_begin(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->init_text_begin;
+};
+
+static u64 inline get_inittext_end(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->init_text_end;
+};
+
+static u64 inline get_data(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->data;
+};
+
+static u64 inline get_edata(void)
+{
+	struct el2_data *el2_data = kern_hyp_va((void *)&el2_data_start);
+	return el2_data->edata;
+};
+#endif
 /*
  * PTAlloc
  */
@@ -711,6 +942,7 @@ u64 walk_pgd(u32 vmid, u64 vttbr, u64 addr, u32 alloc);
 u64 walk_pud(u32 vmid, u64 pgd, u64 addr, u32 alloc);
 u64 walk_pmd(u32 vmid, u64 pud, u64 addr, u32 alloc);
 u64 walk_pte(u32 vmid, u64 pmd, u64 addr);
+void v_set_pud(u32 vmid, u64 pgd, u64 addr, u64 pud);
 void v_set_pmd(u32 vmid, u64 pud, u64 addr, u64 pmd);
 void v_set_pte(u32 vmid, u64 pmd, u64 addr, u64 pte);
 u64 walk_smmu_pgd(u64 ttbr, u64 addr, u32 alloc);
@@ -751,6 +983,14 @@ u64 get_s2_page_index(u64 addr);
 /*
  * PageManager
  */
+#ifdef CONFIG_KERNEL_INT
+void set_pfn_subcount(u64 pfn, u32 subcount);
+u32 get_pfn_subcount(u64 pfn);
+u32 get_pfn_kpage_init(u64 pfn);
+void init_pfn_subowner(u64 pfn);
+u32 get_pfn_subowner(u64 pfn);
+void set_pfn_subowner(u64 pfn, u32 subid);
+#endif
 
 u32 get_pfn_owner(u64 pfn);
 void set_pfn_owner(u64 pfn, u32 vmid);
@@ -849,7 +1089,6 @@ void v_hypsec_inject_undef(u32 vmid, u32 vcpuid);
 void v_update_exception_gp_regs(u32 vmid, u32 vcpuid);
 void post_handle_shadow_s2pt_fault(u32 vmid, u32 vcpuid, u64 addr);
 
-
 /*
  * VCPUOps
  */
diff --git a/arch/arm64/sekvm/sysreg-sr-opt.c b/arch/arm64/sekvm/sysreg-sr-opt.c
index cf8fb1ae..fbe04c7d 100644
--- a/arch/arm64/sekvm/sysreg-sr-opt.c
+++ b/arch/arm64/sekvm/sysreg-sr-opt.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/compiler.h>
 #include <linux/kvm_host.h>
 
diff --git a/gdb_startup.sh b/gdb_startup.sh
new file mode 100755
index 00000000..ed8adc23
--- /dev/null
+++ b/gdb_startup.sh
@@ -0,0 +1 @@
+gdb-multiarch --nx -ex "source sekvm-gdb.py" -ex "target remote localhost:1234" vmlinux
diff --git a/include/linux/linkage.h b/include/linux/linkage.h
index d7618c41..644a6e32 100644
--- a/include/linux/linkage.h
+++ b/include/linux/linkage.h
@@ -39,6 +39,8 @@
 #define __page_aligned_data	__section(.data..page_aligned) __aligned(PAGE_SIZE)
 #define __page_aligned_bss	__section(.bss..page_aligned) __aligned(PAGE_SIZE)
 
+#define __block_aligned_bss __section(.bss..page_aligned) __aligned(SZ_2M)
+
 /*
  * For assembly routines.
  *
diff --git a/include/linux/memblock.h b/include/linux/memblock.h
index ca59883c..0ff7fc89 100644
--- a/include/linux/memblock.h
+++ b/include/linux/memblock.h
@@ -339,6 +339,33 @@ bool memblock_is_region_memory(phys_addr_t base, phys_addr_t size);
 bool memblock_is_reserved(phys_addr_t addr);
 bool memblock_is_region_reserved(phys_addr_t base, phys_addr_t size);
 
+#ifdef CONFIG_VERIFIED_KVM
+extern u64 host_s1_pgtable_mem_base;
+extern u64 host_s1_pgtable_early_mem_base;
+
+static inline phys_addr_t sekvm_memblock_alloc(phys_addr_t size,
+											phys_addr_t align)
+{
+	/* We use the top-down allocation method on early fixed reserved mem */
+	u64 alloc = ALIGN(size, align);
+
+	BUG_ON(!host_s1_pgtable_early_mem_base);
+
+	if (!size)
+			return 0;
+
+	if (host_s1_pgtable_mem_base + alloc > host_s1_pgtable_early_mem_base)
+	{
+			pr_info("[SeKVM]: Failed to get reserved mem\n");
+			return 0;
+	}
+
+	host_s1_pgtable_early_mem_base -= alloc;
+
+	return host_s1_pgtable_early_mem_base;
+}
+#endif
+
 extern void __memblock_dump_all(void);
 
 static inline void memblock_dump_all(void)
diff --git a/include/linux/module.h b/include/linux/module.h
index d44df9b2..54dd671c 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -522,6 +522,14 @@ static inline bool within_module(unsigned long addr, const struct module *mod)
 	return within_module_init(addr, mod) || within_module_core(addr, mod);
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+static inline bool within_module_range(unsigned long addr)
+{
+	return module_alloc_base <= addr &&
+			addr < (module_alloc_base + MODULES_VSIZE);
+}
+#endif
+
 /* Search for module by name: must hold module_mutex. */
 struct module *find_module(const char *name);
 
diff --git a/include/linux/moduleloader.h b/include/linux/moduleloader.h
index 31013c2e..7fd1ea4f 100644
--- a/include/linux/moduleloader.h
+++ b/include/linux/moduleloader.h
@@ -26,6 +26,10 @@ unsigned int arch_mod_section_prepend(struct module *mod, unsigned int section);
    sections.  Returns NULL on failure. */
 void *module_alloc(unsigned long size);
 
+#ifdef CONFIG_VERIFIED_KVM
+void *sekvm_module_alloc(unsigned long flag, unsigned long size);
+#endif
+
 /* Free memory returned from module_alloc. */
 void module_memfree(void *module_region);
 
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index 398e9c95..4fc18ef1 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -21,6 +21,9 @@ struct notifier_block;		/* in notifier.h */
 #define VM_UNINITIALIZED	0x00000020	/* vm_struct is not fully initialized */
 #define VM_NO_GUARD		0x00000040      /* don't add guard page */
 #define VM_KASAN		0x00000080      /* has allocated kasan shadow memory */
+#define VM_SEKVM_RO		0x00000200		/* has enabled sekvm and kint */
+#define VM_SEKVM_TXT	0x00000400		/* has enabled sekvm and kint */
+#define VM_SEKVM_TMP	0x00000800		/* has enabled sekvm and kint */
 /* bits [20..32] reserved for arch specific ioremap internals */
 
 /*
diff --git a/kernel/module.c b/kernel/module.c
index f475f30e..83a864b6 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -67,6 +67,8 @@
 #include <uapi/linux/module.h>
 #include "module-internal.h"
 
+#include <asm/hypsec_host.h>
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/module.h>
 
@@ -87,6 +89,10 @@
 
 /* If this is set, the section belongs in the init part of the module */
 #define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
+#ifdef CONFIG_VERIFIED_KVM
+#define SEKVM_TEXT_OFFSET_MASK (1UL << (BITS_PER_LONG-2))
+#define SEKVM_RO_OFFSET_MASK (1UL << (BITS_PER_LONG-3))
+#endif
 
 /*
  * Mutex protects:
@@ -374,6 +380,30 @@ static unsigned int find_sec(const struct load_info *info, const char *name)
 	return 0;
 }
 
+#ifdef CONFIG_KERNEL_INT
+/*
+ * FIXME: hardcoded from now.
+ *  It would be better to dynamically change the number of sections
+ *  that need verification.
+ */
+#define MAX_VERIFY_SECTION_SIZE 100
+u32 *checklists;
+static u32 verify_entsize;
+static int hyp_checksum(struct module *mod, struct load_info *info)
+{	
+	int ret;
+
+	if (!checklists || verify_entsize == 0 || verify_entsize > MAX_VERIFY_SECTION_SIZE)
+			return -1;
+	ret = el2_mod_checksum((unsigned long)(info->hdr), (unsigned long)(mod->percpu),
+					(unsigned long)(&mod->arch), (unsigned long)(checklists), verify_entsize);
+
+	if (ret >= 0)
+			mod->arch.kint_modid = ret;
+	return (ret >= 0)? 0: -1;
+}
+#endif
+
 /* Find a module section, or NULL. */
 static void *section_addr(const struct load_info *info, const char *name)
 {
@@ -1025,6 +1055,10 @@ SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
 	/* Store the name of the last unloaded module for diagnostic purposes */
 	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));
 
+#ifdef CONFIG_KERNEL_INT
+	ret = hyp_free_module(mod->arch.kint_modid);
+#endif
+
 	free_module(mod);
 	return 0;
 out:
@@ -2271,6 +2305,7 @@ static int simplify_symbols(struct module *mod, const struct load_info *info)
 			break;
 
 		case SHN_UNDEF:
+#ifndef CONFIG_KERNEL_INT
 			ksym = resolve_symbol_wait(mod, info, name);
 			/* Ok if resolved.  */
 			if (ksym && !IS_ERR(ksym)) {
@@ -2285,15 +2320,18 @@ static int simplify_symbols(struct module *mod, const struct load_info *info)
 			pr_warn("%s: Unknown symbol %s (err %li)\n",
 				mod->name, name, PTR_ERR(ksym));
 			ret = PTR_ERR(ksym) ?: -ENOENT;
+#endif
 			break;
 
 		default:
 			/* Divert to percpu allocation if a percpu var. */
+#ifndef CONFIG_KERNEL_INT
 			if (sym[i].st_shndx == info->index.pcpu)
 				secbase = (unsigned long)mod_percpu(mod);
 			else
 				secbase = info->sechdrs[sym[i].st_shndx].sh_addr;
 			sym[i].st_value += secbase;
+#endif
 			break;
 		}
 	}
@@ -2326,8 +2364,10 @@ static int apply_relocations(struct module *mod, const struct load_info *info)
 			err = apply_relocate(info->sechdrs, info->strtab,
 					     info->index.sym, i, mod);
 		else if (info->sechdrs[i].sh_type == SHT_RELA)
+#ifndef CONFIG_KERNEL_INT
 			err = apply_relocate_add(info->sechdrs, info->strtab,
 						 info->index.sym, i, mod);
+#endif
 		if (err < 0)
 			break;
 	}
@@ -2389,6 +2429,7 @@ static void layout_sections(struct module *mod, struct load_info *info)
 			s->sh_entsize = get_offset(mod, &mod->core_layout.size, s, i);
 			pr_debug("\t%s\n", sname);
 		}
+
 		switch (m) {
 		case 0: /* executable */
 			mod->core_layout.size = debug_align(mod->core_layout.size);
@@ -2421,7 +2462,6 @@ static void layout_sections(struct module *mod, struct load_info *info)
 				continue;
 			s->sh_entsize = (get_offset(mod, &mod->init_layout.size, s, i)
 					 | INIT_OFFSET_MASK);
-			pr_debug("\t%s\n", sname);
 		}
 		switch (m) {
 		case 0: /* executable */
@@ -2672,7 +2712,6 @@ static void add_kallsyms(struct module *mod, const struct load_info *info)
 
 	/* Set up to point into init section. */
 	mod->kallsyms = mod->init_layout.base + info->mod_kallsyms_init_off;
-
 	mod->kallsyms->symtab = (void *)symsec->sh_addr;
 	mod->kallsyms->num_symtab = symsec->sh_size / sizeof(Elf_Sym);
 	/* Make sure we get permanent strtab: don't use info->strtab. */
@@ -2881,8 +2920,18 @@ static int copy_module_from_user(const void __user *umod, unsigned long len,
 		return err;
 
 	/* Suck in entire file: we'll want most of it. */
+#ifndef CONFIG_KERNEL_INT
 	info->hdr = __vmalloc(info->len,
 			GFP_KERNEL | __GFP_NOWARN, PAGE_KERNEL);
+#else
+	/*
+	 * If we applied default vmalloc API for module, it possibly
+	 * already injected writable stage 2 page in same 2mb-aligned
+	 * block which can bypass the remapped write-protected permission
+	 * applied to block during module authentication.
+	 */
+	info->hdr = sekvm_module_alloc(VM_SEKVM_RO | VM_SEKVM_TMP, info->len);
+#endif
 	if (!info->hdr)
 		return -ENOMEM;
 
@@ -2974,6 +3023,7 @@ static struct module *setup_load_info(struct load_info *info, int flags)
 				+ info->sechdrs[info->index.str].sh_offset;
 			break;
 		}
+
 	}
 
 	info->index.mod = find_sec(info, ".gnu.linkonce.this_module");
@@ -3139,14 +3189,176 @@ static int find_module_sections(struct module *mod, struct load_info *info)
 
 	return 0;
 }
+#ifdef CONFIG_VERIFIED_KVM
+static void *sekvm_mod_text_base;
+static void *sekvm_mod_ro_base;
+static u64 sekvm_core_text_size;
+static u64 sekvm_core_ro_size;
+static u64 sekvm_init_text_size;
+static u64 sekvm_init_ro_size;
+
+static void sekvm_divide_section(struct load_info *info)
+{
+	sekvm_core_text_size = sekvm_core_ro_size = 0UL;
+	sekvm_init_text_size = sekvm_init_ro_size = 0UL;
+	verify_entsize = 0U;
+	checklists = NULL;
+
+	/* NOTE: we only divide text and ro section */
+	static unsigned long const masks[][2] = {
+		{ SHF_EXECINSTR | SHF_ALLOC, 0 },
+		{ SHF_ALLOC, SHF_WRITE },
+	};
+
+	unsigned int m, i, k;
+	long ret;
+	unsigned int symidx, stridx;
+	symidx = info->index.sym;
+	stridx = info->index.str;
+
+	Elf_Shdr *symsect = info->sechdrs + symidx;
+	Elf_Shdr *strsect = info->sechdrs + stridx;
+
+#ifdef CONFIG_KERNEL_INT
+	/* Allocate a page to store verify sections information */
+	checklists = (unsigned int *)__vmalloc(PAGE_SIZE,
+					GFP_KERNEL | __GFP_NOWARN, PAGE_KERNEL);
+	if (!checklists)
+		return;
+	memset(checklists, 0, PAGE_SIZE);
+
+	k = 0;
+#endif
+	for(m = 0; m < ARRAY_SIZE(masks); ++m) {
+
+		unsigned long core_size;
+		core_size = 0UL;
+
+		for (i = 0; i < info->hdr->e_shnum; ++i) {
+			Elf_Shdr *s = &info->sechdrs[i];
+			const char *sname = info->secstrings + s->sh_name;
+
+			if ((s->sh_flags & masks[m][0]) != masks[m][0]
+			    || (s->sh_flags & masks[m][1])
+				|| (s->sh_entsize & (SEKVM_TEXT_OFFSET_MASK | SEKVM_RO_OFFSET_MASK))
+				|| strstarts(sname, ".init")
+				|| (i == symidx) || (i == stridx))
+				continue;
+
+			s->sh_entsize = ALIGN(core_size, s->sh_addralign ?: 1);
+			core_size = s->sh_entsize + s->sh_size;
+#ifdef CONFIG_KERNEL_INT
+			checklists[k++] = i;
+#endif
+			if (m == 0)
+				s->sh_entsize |= SEKVM_TEXT_OFFSET_MASK;
+			else
+				s->sh_entsize |= SEKVM_RO_OFFSET_MASK;
+		}
+
+		switch (m) {
+		case 0: /* executable */
+			sekvm_core_text_size = ALIGN(core_size, PAGE_SIZE);
+			break;
+		case 1: /* RO: text and ro-data */
+			sekvm_core_ro_size = ALIGN(core_size, PAGE_SIZE);
+			break;
+		}
+	}
+
+	for(m = 0; m < ARRAY_SIZE(masks); ++m) {
+
+		unsigned long init_size;
+		init_size = 0UL;
+
+		for (i = 0; i < info->hdr->e_shnum; ++i) {
+			Elf_Shdr *s = &info->sechdrs[i];
+			const char *sname = info->secstrings + s->sh_name;
+
+			if ((s->sh_flags & masks[m][0]) != masks[m][0]
+			    || (s->sh_flags & masks[m][1])
+				|| (s->sh_entsize & (SEKVM_TEXT_OFFSET_MASK | SEKVM_RO_OFFSET_MASK))
+				|| !strstarts(sname, ".init")
+				|| (i == symidx) || (i == stridx))
+				continue;
+
+			s->sh_entsize = ALIGN(init_size, s->sh_addralign ?: 1);
+			init_size = s->sh_entsize + s->sh_size;
+
+#ifdef CONFIG_KERNEL_INT
+			checklists[k++] = i;
+#endif
+			s->sh_entsize |= INIT_OFFSET_MASK;
+			if (m == 0)
+				s->sh_entsize |= SEKVM_TEXT_OFFSET_MASK;
+			else
+				s->sh_entsize |= SEKVM_RO_OFFSET_MASK;
+		}
+
+		switch (m) {
+		case 0: /* executable */
+			sekvm_init_text_size = ALIGN(init_size, PAGE_SIZE);
+			break;
+		case 1: /* RO: text and ro-data */
+			sekvm_init_ro_size = ALIGN(init_size, PAGE_SIZE);
+			break;
+		}
+	}
+
+
+#ifdef CONFIG_KALLSYMS
+	/* init */
+	symsect->sh_entsize = ALIGN(sekvm_init_ro_size, symsect->sh_addralign?: 1);
+	sekvm_init_ro_size = symsect->sh_entsize + symsect->sh_size;
+	symsect->sh_entsize |= (INIT_OFFSET_MASK | SEKVM_RO_OFFSET_MASK);
+
+	strsect->sh_entsize = ALIGN(sekvm_init_ro_size, strsect->sh_addralign?: 1);
+	sekvm_init_ro_size = strsect->sh_entsize + strsect->sh_size;
+	sekvm_init_ro_size = ALIGN(sekvm_init_ro_size, PAGE_SIZE);
+	strsect->sh_entsize |= (INIT_OFFSET_MASK | SEKVM_RO_OFFSET_MASK);
+#endif
+
+#ifdef CONFIG_KERNEL_INT
+	/*
+	 * By default, we might not trust host apply relocation
+	 * on protected sections. Therefore, we may also verify
+	 * the symtab and relocation info sections:
+	 * (sh_type == SHT_RELA || sh_type == SHT_SYMTAB)
+	 * that use to resolve symbol and apply relocation on
+	 * protected sections.
+	 *
+	 * We can choose not to do this, but in our design,
+	 * not including it now will result in verification failure.
+	 */
+#ifdef CONFIG_KALLSYMS
+	checklists[k++] = info->index.sym;
+	checklists[k++] = info->index.str;
+#endif
+	for(i = 0; i < info->hdr->e_shnum; ++i){
+		Elf_Shdr *s = &info->sechdrs[i];
+		if (s->sh_type == SHT_RELA) {
+			for (m = 0; m < k; ++m) {
+				if (s->sh_info == checklists[m]) {
+					checklists[k++] = i;
+					break;
+				}
+			}
+		}
+	}
+	verify_entsize = k;
+}
+#endif
+#endif	/* CONFIG_VERIFIED_KVM */
 
 static int move_module(struct module *mod, struct load_info *info)
 {
+
 	int i;
 	void *ptr;
 
 	/* Do the allocs. */
 	ptr = module_alloc(mod->core_layout.size);
+
 	/*
 	 * The pointer to this block is stored in the module structure
 	 * which is inside the block. Just mark it as not being a
@@ -3159,6 +3371,40 @@ static int move_module(struct module *mod, struct load_info *info)
 	memset(ptr, 0, mod->core_layout.size);
 	mod->core_layout.base = ptr;
 
+#ifdef CONFIG_VERIFIED_KVM
+	sekvm_divide_section(info);
+	/* Just ensure it, we need to shift offset about init sections */
+	BUG_ON(!PAGE_ALIGNED(sekvm_core_text_size));
+	BUG_ON(!PAGE_ALIGNED(sekvm_core_ro_size));
+
+#ifdef CONFIG_KERNEL_INT
+	if (!checklists)
+		return -ENOMEM;
+#endif
+	/* text*/
+	ptr = sekvm_module_alloc(VM_SEKVM_TXT, sekvm_core_text_size + sekvm_init_text_size);
+	kmemleak_not_leak(ptr);
+	if (!ptr) {
+		module_memfree(mod->core_layout.base);
+		return -ENOMEM;
+	}
+
+	memset(ptr, 0, sekvm_core_text_size + sekvm_init_text_size);
+	sekvm_mod_text_base = ptr;
+
+	/* ro */
+	ptr = sekvm_module_alloc(VM_SEKVM_RO, sekvm_core_ro_size + sekvm_init_ro_size);
+	kmemleak_not_leak(ptr);
+	if (!ptr) {
+		module_memfree(mod->core_layout.base);
+		module_memfree(sekvm_mod_text_base);
+		return -ENOMEM;
+	}
+
+	memset(ptr, 0, sekvm_core_ro_size + sekvm_init_ro_size);
+	sekvm_mod_ro_base = ptr;
+#endif
+
 	if (mod->init_layout.size) {
 		ptr = module_alloc(mod->init_layout.size);
 		/*
@@ -3170,8 +3416,11 @@ static int move_module(struct module *mod, struct load_info *info)
 		kmemleak_ignore(ptr);
 		if (!ptr) {
 			module_memfree(mod->core_layout.base);
+			module_memfree(sekvm_mod_text_base);
+			module_memfree(sekvm_mod_ro_base);
 			return -ENOMEM;
 		}
+
 		memset(ptr, 0, mod->init_layout.size);
 		mod->init_layout.base = ptr;
 	} else
@@ -3186,14 +3435,45 @@ static int move_module(struct module *mod, struct load_info *info)
 		if (!(shdr->sh_flags & SHF_ALLOC))
 			continue;
 
+#ifndef CONFIG_VERIFIED_KVM
 		if (shdr->sh_entsize & INIT_OFFSET_MASK)
 			dest = mod->init_layout.base
 				+ (shdr->sh_entsize & ~INIT_OFFSET_MASK);
 		else
 			dest = mod->core_layout.base + shdr->sh_entsize;
-
+#else
+		if (shdr->sh_entsize & SEKVM_TEXT_OFFSET_MASK)
+		{
+			shdr->sh_entsize &= ~SEKVM_TEXT_OFFSET_MASK;
+			if (shdr->sh_entsize & INIT_OFFSET_MASK)
+				/* Shift offset of core text size */
+				dest = sekvm_mod_text_base + sekvm_core_text_size
+					+ (shdr->sh_entsize & ~INIT_OFFSET_MASK);
+			else
+				dest = sekvm_mod_text_base + shdr->sh_entsize;
+		}
+		else if (shdr->sh_entsize & SEKVM_RO_OFFSET_MASK)
+		{
+			shdr->sh_entsize &= ~SEKVM_RO_OFFSET_MASK;
+			if (shdr->sh_entsize & INIT_OFFSET_MASK)
+				/* Shift offset of core ro size */
+				dest = sekvm_mod_ro_base + sekvm_core_ro_size
+					+ (shdr->sh_entsize & ~INIT_OFFSET_MASK);
+			else
+				dest = sekvm_mod_ro_base + shdr->sh_entsize;
+		}
+		else
+		{
+			if (shdr->sh_entsize & INIT_OFFSET_MASK)
+				dest = mod->init_layout.base
+					+ (shdr->sh_entsize & ~INIT_OFFSET_MASK);
+			else
+				dest = mod->core_layout.base + shdr->sh_entsize;
+		}
+#endif
 		if (shdr->sh_type != SHT_NOBITS)
 			memcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);
+
 		/* Update sh_addr to point to copy in image. */
 		shdr->sh_addr = (unsigned long)dest;
 		pr_debug("\t0x%lx %s\n",
@@ -3263,6 +3543,11 @@ static void flush_module_icache(const struct module *mod)
 				   + mod->init_layout.size);
 	flush_icache_range((unsigned long)mod->core_layout.base,
 			   (unsigned long)mod->core_layout.base + mod->core_layout.size);
+#ifdef CONFIG_VERIFIED_KVM
+	flush_icache_range((unsigned long)sekvm_mod_text_base,
+					(unsigned long)sekvm_mod_text_base
+					+ sekvm_core_text_size + sekvm_init_text_size);
+#endif
 
 	set_fs(old_fs);
 }
@@ -3490,6 +3775,10 @@ static noinline int do_init_module(struct module *mod)
 	if (!mod->async_probe_requested && (current->flags & PF_USED_ASYNC))
 		async_synchronize_full();
 
+
+#ifdef CONFIG_KERNEL_INT
+	ret = hyp_unload_init_mod(mod->arch.kint_modid);
+#endif
 	ftrace_free_mem(mod, mod->init_layout.base, mod->init_layout.base +
 			mod->init_layout.size);
 	mutex_lock(&module_mutex);
@@ -3527,6 +3816,9 @@ static noinline int do_init_module(struct module *mod)
 	return 0;
 
 fail_free_freeinit:
+#ifdef CONFIG_KERNEL_INT
+	ret = hyp_unload_init_mod(mod->arch.kint_modid);
+#endif
 	kfree(freeinit);
 fail:
 	/* Try to protect us from buggy refcounters. */
@@ -3659,6 +3951,7 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	struct module *mod;
 	long err;
 	char *after_dashes;
+	int i; 
 
 	err = module_sig_check(info, flags);
 	if (err)
@@ -3693,7 +3986,7 @@ static int load_module(struct load_info *info, const char __user *uargs,
 #endif
 
 	/* To avoid stressing percpu allocator, do this once we're unique. */
-	err = percpu_modalloc(mod, info);
+	err = percpu_modalloc(mod, info); 
 	if (err)
 		goto unlink_mod;
 
@@ -3717,12 +4010,21 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	/* Set up MODINFO_ATTR fields */
 	setup_modinfo(mod, info);
 
+#ifdef CONFIG_KERNEL_INT
+	err = hyp_checksum(mod, info);
+	vfree(checklists);
+	if (err < 0)
+		goto hyp_checksum_fail;
+
+#endif
+	
 	/* Fix up syms, so that st_value is a pointer to location. */
 	err = simplify_symbols(mod, info);
 	if (err < 0)
 		goto free_modinfo;
 
-	err = apply_relocations(mod, info);
+	err = apply_relocations(mod, info);  // random modification might come from here : 
+										 // We seems to have random modification of instruction
 	if (err < 0)
 		goto free_modinfo;
 
@@ -3809,6 +4111,8 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	kfree(mod->args);
  free_arch_cleanup:
 	module_arch_cleanup(mod);
+ hyp_checksum_fail:
+	printk("Hyp checksum failed, Je sais pas comment cancel le module loading\n");
  free_modinfo:
 	free_modinfo(mod);
  free_unload:
@@ -3875,6 +4179,12 @@ SYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)
 		return err;
 	info.hdr = hdr;
 	info.len = size;
+#ifdef CONFIG_KERNEL_INT
+	/* FIXME: Move the file to SeKVM allocate region. So dirty..Weeeee*/
+	info.hdr = sekvm_module_alloc(VM_SEKVM_RO | VM_SEKVM_TMP, info.len);
+	memcpy(info.hdr, hdr, info.len);
+	vfree(hdr);
+#endif
 
 	return load_module(&info, uargs, flags);
 }
diff --git a/mm/Makefile b/mm/Makefile
index 8716bdab..98b71f5b 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -106,3 +106,4 @@ obj-$(CONFIG_HARDENED_USERCOPY) += usercopy.o
 obj-$(CONFIG_PERCPU_STATS) += percpu-stats.o
 obj-$(CONFIG_HMM) += hmm.o
 obj-$(CONFIG_MEMFD_CREATE) += memfd.o
+obj-$(CONFIG_VERIFIED_KVM) += sekvm_vmap.o
diff --git a/mm/sekvm_vmap.c b/mm/sekvm_vmap.c
new file mode 100644
index 00000000..36f31d07
--- /dev/null
+++ b/mm/sekvm_vmap.c
@@ -0,0 +1,120 @@
+/*
+ * Copied from ./mm/vmalloc.c
+ * FIXME: no unmap now
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+
+extern void *host_alloc_mod_pages(unsigned short order, bool ro);
+
+static int sekvm_vmap_pte_range(pmd_t *pmd, unsigned long addr,
+		unsigned long end, pgprot_t prot, int *nr, unsigned long flags)
+{
+	pte_t *pte;
+	void *page;
+	u64 pfn;
+
+	/*
+	 * nr is a running index into the array which helps higher level
+	 * callers keep track of where we're up to.
+	 */
+
+	pte = pte_alloc_kernel(pmd, addr);
+	if (!pte)
+		return -ENOMEM;
+	do {
+
+		if (WARN_ON(!pte_none(*pte)))
+			return -EBUSY;
+		
+		/* Only handle module page now */
+		if (flags & VM_SEKVM_RO)
+			page = host_alloc_mod_pages(0, true);
+		else if (flags & VM_SEKVM_TXT)
+			page = host_alloc_mod_pages(0, false);
+		else
+			return -ENOMEM;
+		
+		if(!page)	
+			return -ENOMEM;
+		
+		pfn = __pa(page) >> PAGE_SHIFT;
+		set_pte_at(&init_mm, addr, pte, pfn_pte(pfn, prot));
+		(*nr)++;
+	} while (pte++, addr += PAGE_SIZE, addr != end);
+	return 0;
+}
+
+static int sekvm_vmap_pmd_range(pud_t *pud, unsigned long addr,
+		unsigned long end, pgprot_t prot, int *nr, unsigned long flags)
+{
+	pmd_t *pmd;
+	unsigned long next;
+
+	pmd = pmd_alloc(&init_mm, pud, addr);
+	if (!pmd)
+		return -ENOMEM;
+	do {
+		next = pmd_addr_end(addr, end);
+		if (sekvm_vmap_pte_range(pmd, addr, next, prot, nr, flags))
+			return -ENOMEM;
+	} while (pmd++, addr = next, addr != end);
+	return 0;
+}
+
+static int sekvm_vmap_pud_range(p4d_t *p4d, unsigned long addr,
+		unsigned long end, pgprot_t prot, int *nr, unsigned long flags)
+{
+	pud_t *pud;
+	unsigned long next;
+
+	pud = pud_alloc(&init_mm, p4d, addr);
+	if (!pud)
+		return -ENOMEM;
+	do {
+		next = pud_addr_end(addr, end);
+		if (sekvm_vmap_pmd_range(pud, addr, next, prot, nr, flags))
+			return -ENOMEM;
+	} while (pud++, addr = next, addr != end);
+	return 0;
+}
+
+static int sekvm_vmap_p4d_range(pgd_t *pgd, unsigned long addr,
+		unsigned long end, pgprot_t prot, int *nr, unsigned long flags)
+{
+	p4d_t *p4d;
+	unsigned long next;
+
+	p4d = p4d_alloc(&init_mm, pgd, addr);
+	if (!p4d)
+		return -ENOMEM;
+	do {
+		next = p4d_addr_end(addr, end);
+		if (sekvm_vmap_pud_range(p4d, addr, next, prot, nr, flags))
+			return -ENOMEM;
+	} while (p4d++, addr = next, addr != end);
+	return 0;
+}
+
+int sekvm_vmap_page_range(unsigned long start, unsigned long end,
+				   pgprot_t prot, unsigned long flags)
+{
+	pgd_t *pgd;
+	unsigned long next;
+	unsigned long addr = start;
+	int err = 0;
+	int nr = 0;
+
+	BUG_ON(addr >= end);
+	pgd = pgd_offset_k(addr);
+	do {
+		next = pgd_addr_end(addr, end);
+		err = sekvm_vmap_p4d_range(pgd, addr, next, prot, &nr, flags);
+		if (err)
+			return err;
+	} while (pgd++, addr = next, addr != end);
+
+	return nr;
+}
diff --git a/mm/sparse-vmemmap.c b/mm/sparse-vmemmap.c
index bd0276d5..5be8e0ff 100644
--- a/mm/sparse-vmemmap.c
+++ b/mm/sparse-vmemmap.c
@@ -46,9 +46,25 @@ static void * __ref __earlyonly_bootmem_alloc(int node,
 					    BOOTMEM_ALLOC_ACCESSIBLE, node);
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+extern void *host_alloc_pt_pages(unsigned short order);
+static void * __ref __sekvm_bootmem_alloc(phys_addr_t size,
+				phys_addr_t align)
+{
+	return host_alloc_pt_pages(0);
+}
+#endif
+
 static void *vmemmap_buf;
 static void *vmemmap_buf_end;
 
+#ifdef CONFIG_VERIFIED_KVM
+void * __meminit sekvm_vmemmap_alloc_block(unsigned long size, int node)
+{
+	return __sekvm_bootmem_alloc(size, PAGE_SIZE);
+}
+#endif
+
 void * __meminit vmemmap_alloc_block(unsigned long size, int node)
 {
 	/* If the main allocator is up use that, fallback to bootmem. */
@@ -165,6 +181,19 @@ pte_t * __meminit vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node)
 	return pte;
 }
 
+#ifdef CONFIG_VERIFIED_KVM
+static void * __meminit sekvm_vmemmap_alloc_block_zero(unsigned long size, int node)
+{
+	void *p = sekvm_vmemmap_alloc_block(size, node);
+
+	if (!p)
+		return NULL;
+	memset(p, 0, size);
+
+	return p;
+}
+#endif
+
 static void * __meminit vmemmap_alloc_block_zero(unsigned long size, int node)
 {
 	void *p = vmemmap_alloc_block(size, node);
@@ -180,7 +209,11 @@ pmd_t * __meminit vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node)
 {
 	pmd_t *pmd = pmd_offset(pud, addr);
 	if (pmd_none(*pmd)) {
+#ifndef CONFIG_VERIFIED_KVM
 		void *p = vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#else
+		void *p = sekvm_vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#endif
 		if (!p)
 			return NULL;
 		pmd_populate_kernel(&init_mm, pmd, p);
@@ -192,7 +225,11 @@ pud_t * __meminit vmemmap_pud_populate(p4d_t *p4d, unsigned long addr, int node)
 {
 	pud_t *pud = pud_offset(p4d, addr);
 	if (pud_none(*pud)) {
+#ifndef CONFIG_VERIFIED_KVM
 		void *p = vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#else
+		void *p = sekvm_vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#endif
 		if (!p)
 			return NULL;
 		pud_populate(&init_mm, pud, p);
@@ -216,7 +253,11 @@ pgd_t * __meminit vmemmap_pgd_populate(unsigned long addr, int node)
 {
 	pgd_t *pgd = pgd_offset_k(addr);
 	if (pgd_none(*pgd)) {
+#ifndef CONFIG_VERIFIED_KVM
 		void *p = vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#else
+		void *p = sekvm_vmemmap_alloc_block_zero(PAGE_SIZE, node);
+#endif
 		if (!p)
 			return NULL;
 		pgd_populate(&init_mm, pgd, p);
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index cfea25be..20db26d9 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1334,6 +1334,23 @@ void unmap_kernel_range(unsigned long addr, unsigned long size)
 }
 EXPORT_SYMBOL_GPL(unmap_kernel_range);
 
+#ifdef CONFIG_VERIFIED_KVM
+extern int sekvm_vmap_page_range(unsigned long start, unsigned long end,
+			   pgprot_t prot, unsigned long flags);
+static int sekvm_map_vm_area(struct vm_struct *area, pgprot_t prot)
+{
+	unsigned long addr = (unsigned long)area->addr;
+	unsigned long end = addr + get_vm_area_size(area);
+	unsigned long flags = area->flags;
+	int err;
+
+	err = sekvm_vmap_page_range(addr, end, prot, flags);
+	flush_cache_vmap(addr, end);
+
+	return err > 0 ? 0 : err;
+}
+#endif
+
 int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)
 {
 	unsigned long addr = (unsigned long)area->addr;
@@ -1516,6 +1533,11 @@ static void __vunmap(const void *addr, int deallocate_pages)
 	debug_check_no_obj_freed(area->addr, get_vm_area_size(area));
 
 	remove_vm_area(addr);
+#ifdef CONFIG_VERIFIED_KVM
+	/* In SeKVM, module area area->pages[] == NULL */
+	if (area->flags & VM_SEKVM_RO || area->flags & VM_SEKVM_TXT)
+			deallocate_pages = 0;
+#endif
 	if (deallocate_pages) {
 		int i;
 
@@ -1665,6 +1687,23 @@ static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,
 	array_size = (nr_pages * sizeof(struct page *));
 
 	area->nr_pages = nr_pages;
+
+#ifdef CONFIG_VERIFIED_KVM
+	if ((area->flags & VM_SEKVM_TMP)
+		|| ((area->flags & VM_SEKVM_TXT || area->flags & VM_SEKVM_RO)
+		&& within_module_range((u64)area->addr)
+		&& within_module_range((u64)(area->addr + area->size))))
+	{
+		area->pages = NULL;
+		if (sekvm_map_vm_area(area, prot)) {
+			remove_vm_area(area->addr);
+			kfree(area);
+			return NULL;
+		}
+		return area->addr;
+	}
+#endif
+
 	/* Please note that the recursion is strictly bounded. */
 	if (array_size > PAGE_SIZE) {
 		pages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,
diff --git a/scripts/dtc/dtc-lexer.l b/scripts/dtc/dtc-lexer.l
index 615b7ec6..a26c7636 100644
--- a/scripts/dtc/dtc-lexer.l
+++ b/scripts/dtc/dtc-lexer.l
@@ -38,7 +38,7 @@ LINECOMMENT	"//".*\n
 #include "srcpos.h"
 #include "dtc-parser.tab.h"
 
-YYLTYPE yylloc;
+extern YYLTYPE yylloc;
 extern bool treesource_error;
 
 /* CAUTION: this will stop working if we ever use yyless() or yyunput() */
diff --git a/arch/arm64/configs/hypsec19_defconfig b/secvma_defconfig
similarity index 99%
rename from arch/arm64/configs/hypsec19_defconfig
rename to secvma_defconfig
index f2ed40d6..1ecccf53 100644
--- a/arch/arm64/configs/hypsec19_defconfig
+++ b/secvma_defconfig
@@ -4,7 +4,7 @@
 #
 
 #
-# Compiler: gcc (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609
+# Compiler: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
 #
 CONFIG_ARM64=y
 CONFIG_64BIT=y
@@ -35,7 +35,7 @@ CONFIG_ARCH_SUPPORTS_UPROBES=y
 CONFIG_ARCH_PROC_KCORE_TEXT=y
 CONFIG_MULTI_IRQ_HANDLER=y
 CONFIG_CC_IS_GCC=y
-CONFIG_GCC_VERSION=50400
+CONFIG_GCC_VERSION=90300
 CONFIG_CLANG_VERSION=0
 CONFIG_IRQ_WORK=y
 CONFIG_BUILDTIME_EXTABLE_SORT=y
@@ -467,6 +467,7 @@ CONFIG_SOCIONEXT_SYNQUACER_PREITS=y
 CONFIG_HISILICON_ERRATUM_161600802=y
 CONFIG_QCOM_FALKOR_ERRATUM_E1041=y
 CONFIG_VERIFIED_KVM=y
+CONFIG_KERNEL_INT=y
 CONFIG_ARM64_4K_PAGES=y
 # CONFIG_ARM64_16K_PAGES is not set
 # CONFIG_ARM64_64K_PAGES is not set
@@ -2885,7 +2886,13 @@ CONFIG_JBD2=y
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
+CONFIG_XFS_FS=m
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
 # CONFIG_GFS2_FS is not set
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
@@ -3102,6 +3109,8 @@ CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
 CONFIG_HAVE_ARCH_KASAN=y
 # CONFIG_KASAN is not set
 CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
 # CONFIG_DEBUG_SHIRQ is not set
 
 #
@@ -3409,7 +3418,7 @@ CONFIG_CRC32_SLICEBY8=y
 # CONFIG_CRC32_BIT is not set
 # CONFIG_CRC4 is not set
 CONFIG_CRC7=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 # CONFIG_CRC8 is not set
 CONFIG_AUDIT_GENERIC=y
 CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
diff --git a/virt/kvm/arm/arm.c b/virt/kvm/arm/arm.c
index 47baefdd..fe62852c 100644
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@ -114,11 +114,18 @@ static void install_el2_runtime(void *discard)
 }
 #endif
 
+#ifdef CONFIG_VERIFIED_KVM
+bool sekvm_installed = false;
+#endif
 int kvm_arch_hardware_setup(void)
 {
 #ifdef CONFIG_VERIFIED_KVM
 	on_each_cpu(install_el2_runtime, NULL, 1);
 	printk("HypSec EL2 runtime is installed\n");
+	sekvm_installed = true;
+#endif
+#ifdef CONFIG_KERNEL_INT
+ 	printk("K-Int EL2 runtime is installed\n");
 #endif
 	return 0;
 }
@@ -1876,7 +1883,6 @@ int kvm_arch_init(void *opaque)
 		kvm_info("VHE mode initialized successfully\n");
 	else
 		kvm_info("Hyp mode initialized successfully\n");
-
 	return 0;
 
 out_hyp:
@@ -1898,4 +1904,4 @@ static int arm_init(void)
 	return rc;
 }
 
-late_initcall(arm_init);
+late_initcall_sync(arm_init);
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index b0b77d45..413bd22d 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -3980,8 +3980,8 @@ int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 {
 	int r;
 	int cpu;
-
 	r = kvm_arch_init(opaque);
+	
 	if (r)
 		goto out_fail;
 
